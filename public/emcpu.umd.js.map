{"version":3,"file":"emcpu.umd.js","sources":["../cpu/utils.js","../cpu/memory.js","../cpu/io.js","../cpu/cpu.js"],"sourcesContent":["const _console = console;\n\nlet mode = \"prod\";\n\nexport function getMode() {\n    return mode;\n}\n\nexport function setMode(m) {\n    if (m !== \"dev\" && m !== \"prod\") throw new Error(\"Invalid mode\");\n    mode = m;\n}\n\nexport function log(...args) {\n    if (mode === \"dev\") _console.log(...args);\n}\n","export class Memory {\n    constructor(size) {\n        this.buffer = new ArrayBuffer(size);\n        this.view = new DataView(this.buffer);\n        new Uint8Array(this.buffer).fill(0); \n    }\n\n    // Read methods\n    readUint8(addr) { return this.view.getUint8(addr); }\n    readUint16(addr) { return this.view.getUint16(addr, true); } // true for little-endian\n    readUint32(addr) { return this.view.getUint32(addr, true); }\n    readBigUint64(addr) { return this.view.getBigUint64(addr, true); }\n\n    // Write methods\n    writeUint8(addr, value) { this.view.setUint8(addr, Number(value)); }\n    writeUint16(addr, value) { this.view.setUint16(addr, Number(value), true); } // true for little-endian\n    writeUint32(addr, value) { this.view.setUint32(addr, Number(value), true); }\n    writeBigUint64(addr, value) { this.view.setBigUint64(addr, value, true); }\n\n    // Helper to load binary data into memory (eg. boot sector)\n    load(addr, data) {\n        const sourceUint8Array = new Uint8Array(data);\n        const mainBufferView = new Uint8Array(this.buffer);\n\n        if (Number(addr) < 0 || (Number(addr) + sourceUint8Array.byteLength) > mainBufferView.byteLength) {\n            throw new Error(`Memory.load: Attempted to load 0x${sourceUint8Array.byteLength.toString(16)} bytes at 0x${addr.toString(16)} which is outside the allocated memory bounds (0x0 to 0x${mainBufferView.byteLength.toString(16)}).`);\n        }\n\n        mainBufferView.set(sourceUint8Array, Number(addr));\n        console.log(`Memory.load: Loaded 0x${sourceUint8Array.byteLength.toString(16)} bytes to 0x${addr.toString(16)}`);\n    }\n}","import { log } from \"./utils.js\";\n\nexport class IOManager {\n    constructor() {\n        this.devices = new Map();\n    }\n\n    registerDevice(ports, device) {\n        const portArray = Array.isArray(ports) ? ports : [ports];\n        for (const port of portArray) {\n            this.devices.set(port, device);\n            log(`Registered device ${device.name} at port ${port}`);\n        }\n    }\n\n    portIn(port, size) {\n        const device = this.devices.get(port);\n        if (device && device.portIn) {\n            return device.portIn(port, size);\n        }\n        return 0;\n    }\n\n    portOut(port, value, size) {\n        const device = this.devices.get(port);\n        if (device && device.portOut) {\n            device.portOut(port, value, size);\n        }\n    }\n}\n\nexport class Device {\n    /**\n     * @param {string} name A descriptive name for the device for logging/debugging.\n     */\n    constructor(name = 'Unnamed Device') {\n        this.name = name;\n    }\n\n    /**\n     * Handles a read from an I/O port associated with this device.\n     * @param {number} port The port number being read from.\n     * @param {number} size The size of the read in bytes (1, 2, or 4).\n     * @returns {number} The value to be returned to the CPU.\n     */\n    portIn(port, size) {\n        // Default behavior for a write-only or unimplemented device.\n        // Real hardware often returns 0xFF on reads from empty ports, but 0 is also fine.\n        return 0;\n    }\n\n    /**\n     * Handles a write to an I/O port associated with this device.\n     * @param {number} port The port number being written to.\n     * @param {number} value The value being written by the CPU.\n     * @param {number} size The size of the write in bytes (1, 2, or 4).\n     */\n    portOut(port, value, size) {\n        // Default behavior for a read-only or unimplemented device is to do nothing.\n        // This is exactly like real hardware.\n    }\n}\n","import * as utils from \"./utils\";\nimport { Memory } from \"./memory.js\";\nimport { IOManager } from \"./io.js\";\n\nexport class PageFaultException extends Error {\n    constructor(message, errorCode) {\n        super(message);\n        this.name = \"PageFaultException\";\n        this.errorCode = errorCode;\n    }\n}\n\nexport class CPU {\n    // --- STATIC CONSTANTS ---\n    static CR0_PE = 1n << 0n;  // Protected Mode Enable\n    static CR0_PG = 1n << 31n; // Paging Enable\n\n    static CR4_PAE = 1n << 5n; // Physical Address Extension\n\n    static FLAG_CF_BIT = 0n;\n    static FLAG_ZF_BIT = 6n;\n    static FLAG_SF_BIT = 7n;\n    static FLAG_IF_BIT = 9n;\n    static FLAG_OF_BIT = 11n;\n\n    static EFER_LME = 1n << 8n; // Long Mode Enable\n    static EFER_NXE = 1n << 11n; // No-Execute Enable (for future NX bit support)\n\n    // Constants for Page Table Entry (PTE) bits\n    // These apply to PML4E, PDPTE, PDE, PTE\n    static PTE_PRESENT       = 1n << 0n;   // P: Present (must be 1 for valid entry)\n    static PTE_READ_WRITE    = 1n << 1n;   // RW: Read/Write (0=read-only, 1=read/write)\n    static PTE_USER_SUPER    = 1n << 2n;   // US: User/Supervisor (0=supervisor-only, 1=user/supervisor)\n    static PTE_WRITE_THROUGH = 1n << 3n;   // PWT: Page Write-Through\n    static PTE_CACHE_DISABLE = 1n << 4n;   // PCD: Page Cache Disable\n    static PTE_ACCESSED      = 1n << 5n;   // A: Accessed (set by CPU on access)\n    static PTE_DIRTY         = 1n << 6n;   // D: Dirty (set by CPU on write) - only for last-level entries (PTE, PDE for 2MB, PDPTE for 1GB)\n    static PTE_PAGE_SIZE     = 1n << 7n;   // PS: Page Size (0=4KB, 1=2MB or 1GB depending on level)\n    static PTE_GLOBAL        = 1n << 8n;   // G: Global (prevents TLB flush on CR3 load - for kernel pages)\n    // Bits 9-11 are ignored for software use\n    // Bits 12-51 for physical page address (for 4KB pages) or bits 21-51 for 2MB/1GB pages\n    // Bits 52-62 ignored for software use\n    // Bit 63 (NXE in EFER, if enabled) for No-Execute\n\n    /**\n     * Creates a minimal 4-level page table structure to identity-map a range of virtual addresses to physical.\n     * Assumes 4KB pages.\n     * @param {Memory} memory The emulated memory object.\n     * @param {BigInt} virtualStart The starting virtual address to map.\n     * @param {BigInt} physicalStart The starting physical address to map.\n     * @param {BigInt} sizeBytes The size of the region to map (must be a multiple of 4KB).\n     * @param {BigInt} pageTableBasePhysAddr The base physical address where page tables will be stored.\n     * @returns {BigInt} The physical address of the PML4 table.\n     */\n    static setupIdentityPaging(memory, virtualStart, physicalStart, sizeBytes, pageTableBasePhysAddr) {\n        const PAGE_SIZE = 4096n; // 4KB\n        if (sizeBytes % PAGE_SIZE !== 0n) {\n            throw new Error(\"Mapped size must be a multiple of 4KB.\");\n        }\n        const numPages = sizeBytes / PAGE_SIZE;\n\n        let currentTableAddr = pageTableBasePhysAddr;\n\n        const pml4TablePhys = currentTableAddr;\n        currentTableAddr += PAGE_SIZE;\n\n        const pdptTablePhys = currentTableAddr;\n        currentTableAddr += PAGE_SIZE;\n\n        const pdTablePhys = currentTableAddr;\n        currentTableAddr += PAGE_SIZE;\n\n        const ptTablePhys = currentTableAddr;\n        currentTableAddr += PAGE_SIZE;\n\n        utils.log(`Setting up identity map from VA 0x${virtualStart.toString(16)} to PA 0x${physicalStart.toString(16)}, size 0x${sizeBytes.toString(16)}`);\n        utils.log(`  PML4 Table at PA 0x${pml4TablePhys.toString(16)}`);\n        utils.log(`  PDPT Table at PA 0x${pdptTablePhys.toString(16)}`);\n        utils.log(`  PD Table at PA 0x${pdTablePhys.toString(16)}`);\n        utils.log(`  PT Table at PA 0x${ptTablePhys.toString(16)}`);\n\n\n        // Initialize all tables to 0\n        for (let i = 0n; i < PAGE_SIZE / 8n; i++) {\n            memory.writeBigUint64(Number(pml4TablePhys + i * 8n), 0n);\n            memory.writeBigUint64(Number(pdptTablePhys + i * 8n), 0n);\n            memory.writeBigUint64(Number(pdTablePhys + i * 8n), 0n);\n            memory.writeBigUint64(Number(ptTablePhys + i * 8n), 0n);\n        }\n\n        // Helper for writing and verifying page table entries\n        const writeAndVerifyPTE = (addr, value, description) => {\n            memory.writeBigUint64(Number(addr), value);\n            const readBack = memory.readBigUint64(Number(addr));\n            if (readBack !== value) {\n                console.error(`ERROR: ${description} write mismatch at 0x${addr.toString(16)}! Written: 0x${value.toString(16)}, Readback: 0x${readBack.toString(16)}`);\n                throw new Error(\"Page table write verification failed.\");\n            } else {\n                utils.log(`  VERIFIED: ${description} at 0x${addr.toString(16)} is 0x${readBack.toString(16)}`);\n            }\n        };\n\n        // Map the first entry in each table to point to the next table\n        // PML4[0] -> PDPT[0]\n        let pml4e_value = pdptTablePhys | CPU.PTE_PRESENT | CPU.PTE_READ_WRITE | CPU.PTE_USER_SUPER;\n        writeAndVerifyPTE(pml4TablePhys, pml4e_value, `PML4E[0] -> PDPT[0]`);\n\n        // PDPT[0] -> PD[0]\n        let pdpte_value = pdTablePhys | CPU.PTE_PRESENT | CPU.PTE_READ_WRITE | CPU.PTE_USER_SUPER;\n        writeAndVerifyPTE(pdptTablePhys, pdpte_value, `PDPTE[0] -> PD[0]`);\n\n        // PD[0] -> PT[0]\n        let pde_value = ptTablePhys | CPU.PTE_PRESENT | CPU.PTE_READ_WRITE | CPU.PTE_USER_SUPER;\n        writeAndVerifyPTE(pdTablePhys, pde_value, `PDE[0] -> PT[0]`); \n\n        // Now, map the actual pages in the Page Table\n        for (let i = 0n; i < numPages; i++) {\n            const currentVirtualPage = virtualStart + i * PAGE_SIZE;\n            const currentPhysicalPage = physicalStart + i * PAGE_SIZE;\n            \n            let pte_value = currentPhysicalPage | CPU.PTE_PRESENT | CPU.PTE_READ_WRITE | CPU.PTE_USER_SUPER;\n            // The index into the Page Table depends on the virtual address's bits 12-20\n            const ptIndex = (currentVirtualPage >> 12n) & 0x1FFn;\n            const pteWriteAddr = ptTablePhys + ptIndex * 8n; // Calculate the specific address for this PTE\n\n            // For detailed debugging, log every 100th page, or specific pages (like 0x7C00 or 0x8000)\n            if (i % 100n === 0n || currentVirtualPage === 0x7C00n || currentVirtualPage === 0x8000n) { \n                writeAndVerifyPTE(pteWriteAddr, pte_value, `PTE for VA 0x${currentVirtualPage.toString(16)}`);\n            } else {\n                // If not logging, just perform the write\n                memory.writeBigUint64(Number(pteWriteAddr), pte_value);\n            }\n        }\n\n        return pml4TablePhys; // Return the base address of the PML4 table for CR3\n    }\n\n    constructor(memory = new Memory(1024 * 1024 * 1), io = new IOManager()) {\n        this.memory = memory;\n        this.io = io;\n\n        // Interrupt Descriptor Table Register\n        this.idtr = {\n            base: 0n,\n            limit: 0\n        }\n\n        // Global Descriptor Table Register\n        this.gdtr = {\n            base: 0n,\n            limit: 0\n        }\n\n        // Interrupt Queue\n        this.interruptQueue = [];\n\n        // General Purpose Registers\n        this.rax = 0n; this.rbx = 0n; this.rcx = 0n; this.rdx = 0n;\n        this.rsp = 0n; this.rbp = 0n; this.rsi = 0n; this.rdi = 0n;\n        this.r8 = 0n; this.r9 = 0n; this.r10 = 0n; this.r11 = 0n;\n        this.r12 = 0n; this.r13 = 0n; this.r14 = 0n; this.r15 = 0n;\n\n        // Segment Registers\n        this.cs = 0n;\n        this.ds = 0n;\n        this.ss = 0n;\n        this.es = 0n;\n        this.fs = 0n;\n        this.gs = 0n;\n\n        // RFLAGS Register\n        this.rflags = 0n;\n\n        // Instruction Pointer\n        this.rip = 0n;\n\n        // Flags\n        this.halted = false;\n        this.flags = {\n            cf: 0, // Carry Flag\n            zf: 0, // Zero Flag\n            sf: 0, // Sign Flag\n            of: 0, // Overflow Flag\n            if: 1, // Interrupt Flag\n            // TODO: Add more flags\n        }\n\n        // CPU Modes and Control Registers\n        this.mode = \"real\"; // real, protected, long\n        this.cr0 = 0n; // Control Register 0\n        this.cr3 = 0n; // Control Register 3\n        this.cr4 = 0n; // Control Register 4\n        this.efer = 0n; // Extended Feature Enable Register\n\n        // Mapping register names to their internal names\n        this.registers = {\n            // Full 64-bit\n            'rax': 'rax', 'rcx': 'rcx', 'rdx': 'rdx', 'rbx': 'rbx',\n            'rsp': 'rsp', 'rbp': 'rbp', 'rsi': 'rsi', 'rdi': 'rdi',\n            'r8': 'r8', 'r9': 'r9', 'r10': 'r10', 'r11': 'r11',\n            'r12': 'r12', 'r13': 'r13', 'r14': 'r14', 'r15': 'r15',\n            // 32-bit (low half of 64-bit)\n            'eax': 'rax', 'ecx': 'rcx', 'edx': 'rdx', 'ebx': 'rbx',\n            'esp': 'rsp', 'ebp': 'rbp', 'esi': 'rsi', 'edi': 'rdi',\n            'r8d': 'r8', 'r9d': 'r9', 'r10d': 'r10', 'r11d': 'r11',\n            'r12d': 'r12', 'r13d': 'r13', 'r14d': 'r14', 'r15d': 'r15',\n            // 16-bit (low half of 32-bit)\n            'ax': 'rax', 'cx': 'rcx', 'dx': 'rdx', 'bx': 'rbx',\n            'sp': 'rsp', 'bp': 'rbp', 'si': 'rsi', 'di': 'rdi',\n            'r8w': 'r8', 'r9w': 'r9', 'r10w': 'r10', 'r11w': 'r11',\n            'r12w': 'r12', 'r13w': 'r13', 'r14w': 'r14', 'r15w': 'r15',\n            // 8-bit (low byte of 16-bit) - AL, CL, DL, BL\n            'al': 'rax', 'cl': 'rcx', 'dl': 'rdx', 'bl': 'rbx',\n            // 8-bit (high byte of 16-bit) - AH, CH, DH, BH\n            'ah': 'rax', 'ch': 'rcx', 'dh': 'rdx', 'bh': 'rbx',\n            // 8-bit (low byte of RBP/RSP/RSI/RDI when REX prefix is used) - SPL, BPL, SIL, DIL\n            'spl': 'rsp', 'bpl': 'rbp', 'sil': 'rsi', 'dil': 'rdi',\n            // 8-bit (low byte of R8-R15) - R8B-R15B\n            'r8b': 'r8', 'r9b': 'r9', 'r10b': 'r10', 'r11b': 'r11',\n            'r12b': 'r12', 'r13b': 'r13', 'r14b': 'r14', 'r15b': 'r15',\n            // 64-bit flags register\n            'rflags': 'rflags', 'eflags': 'rflags',\n            // Segment Registers\n            'cs': 'cs', 'ds': 'ds', 'es': 'es', 'ss': 'ss', 'fs': 'fs', 'gs': 'gs',\n        };\n    }\n\n    // Helper to read register values with size handling\n    readRegister(regName, sizeBytes) {\n        if (regName === 'rflags' || regName === 'eflags') {\n            return this.assembleRFlags();\n        }\n        const fullReg = this.registers[regName];\n        if (!fullReg) {\n            throw new Error(`Attempted to read unknown register name: ${regName}`);\n        }\n        let val = this[fullReg]; // val is BigInt (e.g. this.rax)\n        if (sizeBytes === 1) {\n            // Handle AH, CH, DH, BH (high byte of 16-bit)\n            if (['ah', 'ch', 'dh', 'bh'].includes(regName)) {\n                return (val >> 8n) & 0xFFn;\n            }\n            // For AL, CL, DL, BL, SPL, BPL, SIL, DIL, R8B-R15B, it's the lowest byte\n            return (val & 0xFFn);\n        }\n        if (sizeBytes === 2) return (val & 0xFFFFn);\n        if (sizeBytes === 4) return (val & 0xFFFFFFFFn);\n        if (sizeBytes === 8) return val;\n        throw new Error(`Invalid register size: ${sizeBytes}`);\n    }\n\n    // Helper to write values to register values with size handling\n    writeRegister(regName, value, sizeBytes) {\n        const fullReg = this.registers[regName];\n        if (fullReg === undefined) {\n            throw new Error(`Attempted to write to unknown register name: ${regName}`);\n        }\n        let currentVal = this[fullReg];\n        let valToWrite = BigInt(value);\n\n        if (sizeBytes === 1) {\n            if (['ah', 'ch', 'dh', 'bh'].includes(regName)) {\n                // Clear the old AH/CH/DH/BH byte, then set the new one\n                this[fullReg] = (currentVal & ~(0xFFn << 8n)) | ((valToWrite & 0xFFn) << 8n);\n            } else {\n                // AL, CL, DL, BL, SPL, BPL, SIL, DIL, R8B-R15B\n                // Clear the lowest byte, then set the new one. Upper bits untouched.\n                this[fullReg] = (currentVal & ~0xFFn) | (valToWrite & 0xFFn);\n            }\n        } else if (sizeBytes === 2) {\n            // AX, CX, DX, BX, SP, BP, SI, DI, R8W-R15W\n            // Clear the lowest 16 bits, then set the new one. Upper bits untouched.\n            this[fullReg] = (currentVal & ~0xFFFFn) | (valToWrite & 0xFFFFn);\n        } else if (sizeBytes === 4) {\n            // EAX, ECX, EDX, EBX, ESP, EBP, ESI, EDI, R8D-R15D\n            // In 64-bit mode, writing to a 32-bit register (like EAX) zeros the upper 32 bits of the 64-bit register (RAX).\n            this[fullReg] = valToWrite & 0xFFFFFFFFn; // THIS IS THE CRITICAL CHANGE\n        } else if (sizeBytes === 8) {\n            // RAX, RCX, etc. Full 64-bit write.\n            this[fullReg] = valToWrite;\n        } else {\n            throw new Error(`Invalid register size for writing: ${sizeBytes} for register ${regName}`);\n        }\n    }\n\n    // Updates arithmetic flags based on result and operands\n    // Result, operand1, operand2 should be BigInts.\n    // 'operation' can be 'add' or 'sub'\n    updateArithmeticFlags(result, operand1, operand2, sizeBytes, operation) {\n        const bitWidth = BigInt(sizeBytes * 8);\n        const bitMask = (1n << bitWidth) - 1n; \n        const signBitPos = bitWidth - 1n; \n        const signBitMask = 1n << signBitPos;\n\n        // Apply the size mask to ensure correct behavior for operations that wrap around\n        const maskedResult = result & bitMask;\n        const maskedOperand1 = operand1 & bitMask;\n        const maskedOperand2 = operand2 & bitMask;\n\n        // Zero Flag (ZF): Set if result is 0\n        this.flags.zf = (maskedResult === 0n) ? 1 : 0;\n\n        // Sign Flag (SF): Set if result's MSB is 1\n        this.flags.sf = ((maskedResult & signBitMask) !== 0n) ? 1 : 0;\n\n        // Carry Flag (CF): For unsigned overflow\n        // For ADD: CF = 1 if result (unsigned) > max_unsigned_value_for_size\n        // For SUB: CF = 1 if operand1 (unsigned) < operand2 (unsigned) (borrow occurred)\n        if (operation === 'add') {\n            this.flags.cf = (result > bitMask) ? 1 : 0;\n        } else if (operation === 'sub') {\n            this.flags.cf = (maskedOperand1 < maskedOperand2) ? 1 : 0;\n        } else {\n            // For logical operations (AND, OR, XOR), CF is always 0\n            this.flags.cf = 0; \n        }\n\n        // Overflow Flag (OF): For signed overflow\n        // OF is set if the result's sign is different from the operands' sign (for ADD)\n        // or if the result's sign is different from the minuend's sign when the subtrahend's sign is inverted (for SUB).\n        // This is often checked by XORing sign bits:\n        // For ADD: OF = ( (Op1 ^ Res) & (Op2 ^ Res) ) >> signBitPos\n        // For SUB: OF = ( (Op1 ^ Res) & (~Op2 ^ Res) ) >> signBitPos  (where ~Op2 means bitwise NOT of Op2 within its size)\n\n        const s1 = (maskedOperand1 & signBitMask) !== 0n; // Sign of first operand\n        const s2 = (maskedOperand2 & signBitMask) !== 0n; // Sign of second operand\n        const sR = (maskedResult & signBitMask) !== 0n;   // Sign of result\n\n        this.flags.of = 0; // Assume no overflow initially\n\n        if (operation === 'add') {\n            if ((s1 === s2) && (s1 !== sR)) { // Adding two positives makes negative, or two negatives makes positive\n                this.flags.of = 1;\n            }\n        } else if (operation === 'sub') {\n            // OF is set if: (positive - negative = negative) OR (negative - positive = positive)\n            // This is equivalent to: (s1 XOR s2) AND (s1 XOR sR)\n            if ((s1 !== s2) && (s1 !== sR)) { // e.g., 7 - (-1) = 8. s1=0, s2=1, sR=0. (0!=1) && (0!=0) -> false (no OF)\n                                             // e.g., 127 - (-1) = 128. s1=0, s2=1, sR=1. (0!=1) && (0!=1) -> true (OF)\n                this.flags.of = 1;\n            }\n        } else {\n            // For logical operations (AND, OR, XOR), OF is always 0\n            this.flags.of = 0;\n        }\n    }\n\n    step() {\n        let rexPrefix = 0;\n        let defaultOperandSize; // Default bits are determined on current CPU mode (unless REX.W or 0x66 override)\n\n        this.operandSizeOverride = false;\n\n        let rex_w = 0;\n        let rex_r = 0;\n        let rex_x = 0;\n        let rex_b = 0;\n\n        let currentRIPBeforeFetch = this.rip; // Store RIP to calculate instruction start accurately\n\n        if (this.flags.if && this.interruptQueue.length > 0) {\n            this.halted = false;\n            const interruptNumber = this.interruptQueue.shift();\n            this.triggerInterrupt(interruptNumber);\n        }\n\n        if (this.halted) {\n            return true;\n        }\n\n        let opcode; // Declare opcode here, will be assigned inside prefix loop\n\n        try {\n\n        // --- Handle Prefixes (Loop to consume all prefixes) ---\n        // Read bytes one by one, processing as prefixes until main opcode or 0x0F is found.\n            let byte = this.readInstructionByte(); // Read the first byte of the potential instruction\n\n            while (true) {\n                if (byte === 0x66) { // Operand Size Override Prefix\n                    this.operandSizeOverride = true;\n                    byte = this.readInstructionByte(); // Consume 0x66, read next byte\n                } else if ((byte & 0xF0) === 0x40) { // REX prefix: 0x40 - 0x4F\n                    rexPrefix = byte;\n                    rex_w = (rexPrefix & 0x08) >>> 3;\n                    rex_r = (rexPrefix & 0x04) >>> 2;\n                    rex_x = (rexPrefix & 0x02) >>> 1;\n                    rex_b = (rexPrefix & 0x01);\n                    byte = this.readInstructionByte(); // Consume REX, read next byte\n                } \n                // Add other prefixes here (e.g., segment overrides 0x2E, 0x36, REP prefixes 0xF2, 0xF3)\n                else {\n                    // If it's not a known prefix, it must be the main opcode or 0x0F prefix\n                    opcode = byte; // Assign the actual opcode\n                    break; // Exit loop\n                }\n            }\n\n            // Determine the final default operand size based on mode and prefixes.\n            if (this.mode === 'long') {\n                // In long mode, REX.W takes precedence for 64-bit.\n                if (rex_w) {\n                    defaultOperandSize = 8;\n                }\n                // 0x66 prefix forces 16-bit.\n                else if (this.operandSizeOverride) {\n                    defaultOperandSize = 2;\n                }\n                // Default for most instructions is 32-bit.\n                else {\n                    defaultOperandSize = 4;\n                }\n            } else { // Real or Protected Mode\n                // Default is 16-bit. A 0x66 prefix toggles it to 32-bit.\n                // TODO: Add CS.D bit logic for protected mode here later.\n                defaultOperandSize = this.operandSizeOverride ? 4 : 2;\n            }\n\n            // 2-byte opcode prefix (0x0F) - This comes *after* other prefixes\n            let twoByteOpcode = false;\n            if (opcode === 0x0F) {\n                twoByteOpcode = true;\n                opcode = this.readInstructionByte(); // Read the second byte of the opcode\n            }\n\n            // --- Logging the Instruction ---\n            utils.log(`RIP: 0x${currentRIPBeforeFetch.toString(16).padStart(4, '0')}, OPCODE: 0x${(twoByteOpcode ? '0F' : '')}${opcode.toString(16).padStart(2, '0')}${rexPrefix ? ` (REX: 0x${rexPrefix.toString(16)})` : ''}${this.operandSizeOverride ? ' (0x66)' : ''}`);\n\n            // --- Instruction Decoding and Execution ---\n\n            // Priority 1: Handle two-byte opcodes (opcodes that follow 0x0F)\n            if (twoByteOpcode) {\n                // MOV Reg, CRn (0x0F 20)\n                if (opcode === 0x20) {\n                    const modrm = this.readModRMByte();\n                    const crIdx = modrm.reg;\n                    const destRegFullIndex = modrm.rm + (rex_b << 3);\n\n                    // The operand size is determined by the effective operand size.\n                    // In long mode, a REX.W prefix makes it 64-bit. Otherwise, it's 32-bit.\n                    // In real/protected mode, it defaults to 16 or 32.\n                    let sizeBytes = defaultOperandSize;\n                    if (this.mode === 'long') {\n                        sizeBytes = rex_w ? 8 : 4;\n                    }\n\n                    const destRegName = this.getRegisterString(destRegFullIndex, sizeBytes, rexPrefix !== 0);\n\n                    let sourceValue;\n                    switch (crIdx) {\n                        case 0: sourceValue = this.cr0; break;\n                        case 2: sourceValue = this.cr2; break;\n                        case 3: sourceValue = this.cr3; break;\n                        case 4: sourceValue = this.cr4; break;\n                        default:\n                            throw new Error(`Attempted to read from unknown/unsupported CR${crIdx}`);\n                    }\n\n                    this.writeRegister(destRegName, sourceValue, sizeBytes);\n                    \n                    utils.log(`Decoded: MOV ${destRegName.toUpperCase()}, CR${crIdx}`);\n                    return true;\n                }\n\n                // MOV CRn, Reg/Mem64 (0x0F 22)\n                if (opcode === 0x22) {\n                    const modrm = this.readModRMByte();\n                    const crIdx = modrm.reg; // CR register is encoded in the 'reg' field of ModR/M\n                    const sourceRegFullIndex = modrm.rm + (rex_b << 3); // Source GPR is encoded in 'r/m' field, REX.B applies\n                    \n                    // Pass hasRexPrefix (rexPrefix !== 0) to getRegisterString.\n                    const sourceRegName = this.getRegisterString(sourceRegFullIndex, 8, rexPrefix !== 0);\n\n                    const sourceValue = this.readRegister(sourceRegName, 8);\n\n                    switch (crIdx) {\n                        case 0: this.cr0 = sourceValue; utils.log(`Decoded: MOV CR0, ${sourceRegName.toUpperCase()} (0x${sourceValue.toString(16)}n)`); this.updateCPUMode(); break;\n                        case 2: this.cr2 = sourceValue; utils.log(`Decoded: MOV CR2, ${sourceRegName.toUpperCase()} (0x${sourceValue.toString(16)}n)`); break;\n                        case 3: this.cr3 = sourceValue; utils.log(`Decoded: MOV CR3, ${sourceRegName.toUpperCase()} (0x${sourceValue.toString(16)}n)`); break;\n                        case 4: this.cr4 = sourceValue; utils.log(`Decoded: MOV CR4, ${sourceRegName.toUpperCase()} (0x${sourceValue.toString(16)}n)`); this.updateCPUMode(); break;\n                        default: console.warn(`MOV CR${crIdx}, ${sourceRegName.toUpperCase()} not fully implemented/valid.`); \n                    }\n                    return true;\n                }\n                // WRMSR (0x0F 30)\n                if (opcode === 0x30) {\n                    const msrAddr = this.readRegister('rcx', 8); \n                    const valueHigh = this.readRegister('rdx', 8) << 32n; \n                    const valueLow = this.readRegister('rax', 8) & 0xFFFFFFFFn; \n                    const value = valueHigh | valueLow;\n\n                    if (msrAddr === 0xC0000080n) { // EFER MSR\n                        this.efer = value;\n                        if ((this.efer & CPU.EFER_LME) !== 0n) {\n                            utils.log(`Long Mode Enable (LME) bit set in EFER!`);\n                        }\n                        this.updateCPUMode();\n                    } else {\n                        console.warn(`WRMSR to unknown MSR 0x${msrAddr.toString(16)}`);\n                    }\n                    return true;\n                }\n                // JE/JZ (0x0F 84) - near jump with 32-bit displacement\n                if (opcode === 0x84) {\n                    const displacement = this.readSignedImmediate(4); // Read 32-bit signed displacement\n                    utils.log(`Decoded: JE/JZ rel32 0x${displacement.toString(16)} (RIP adjusted)`);\n                    if (this.flags.zf === 1) {\n                        this.rip += displacement; // Apply displacement if ZF is set\n                        utils.log(`  Condition Met (ZF=1). Jumping to 0x${this.rip.toString(16)}`);\n                    } else {\n                        utils.log(`  Condition Not Met (ZF=0). Not jumping.`);\n                    }\n                    return true;\n                }\n                // JNE/JNZ (0x0F 85) - near jump with 32-bit displacement\n                if (opcode === 0x85) {\n                    const displacement = this.readSignedImmediate(4); // Read 32-bit signed displacement\n                    utils.log(`Decoded: JNE/JNZ rel32 0x${displacement.toString(16)} (RIP adjusted)`);\n                    if (this.flags.zf === 0) {\n                        this.rip += displacement; // Apply displacement if ZF is clear\n                        utils.log(`  Condition Met (ZF=0). Jumping to 0x${this.rip.toString(16)}`);\n                    } else {\n                        utils.log(`  Condition Not Met (ZF=1). Not jumping.`);\n                    }\n                    return true;\n                }\n\n                // TODO: Implement other 2-byte Jcc instructions here (e.g., JCC, JNC, JS, JNS, JO, JNO, JP, JNP, JL, JGE, JLE, JG)\n\n                // LGDT and LIDT (0F 01 /2 and /3)\n                if (opcode === 0x01) {\n                    const modrm = this.readModRMByte();\n\n                    // LGDT m64 (opcode extension /2)\n                    if (modrm.reg === 2) {\n                        // THIS IS THE CRITICAL LINE\n                        // We MUST call resolveModRMOperand to get the memory address\n                        // AND to advance RIP past the ModR/M and any displacement bytes.\n                        const memOperand = this.resolveModRMOperand(modrm, 8, rex_x, rex_b, rexPrefix !== 0);\n\n                        // Now use the CORRECT address from the operand\n                        const limit = this.readVirtualUint16(memOperand.address);\n                        const base = this.readVirtualBigUint64(memOperand.address + 2n);\n\n                        this.gdtr.limit = limit;\n                        this.gdtr.base = base;\n\n                        utils.log(`Decoded: LGDT [0x${memOperand.address.toString(16)}] (Base: 0x${base.toString(16)}, Limit: 0x${limit.toString(16)})`);\n                        return true;\n                    }\n                    \n                    // LIDT m64 (opcode extension /3)\n                    if (modrm.reg === 3) {\n                        // THIS IS THE CRITICAL LINE\n                        const memOperand = this.resolveModRMOperand(modrm, 8, rex_x, rex_b, rexPrefix !== 0);\n\n                        // Now use the CORRECT address from the operand\n                        const limit = this.readVirtualUint16(memOperand.address);\n                        const base = this.readVirtualBigUint64(memOperand.address + 2n);\n\n                        this.idtr.limit = limit;\n                        this.idtr.base = base;\n\n                        utils.log(`Decoded: LIDT [0x${memOperand.address.toString(16)}] (Base: 0x${base.toString(16)}, Limit: 0x${limit.toString(16)})`);\n                        return true;\n                    }\n                }\n\n                // If a two-byte opcode is not handled here, it's genuinely unknown\n                utils.log(`Unknown 2-byte opcode: 0x0F ${opcode.toString(16)} at 0x${currentRIPBeforeFetch.toString(16)}`);\n                return false; // Or false if you want to halt on unknown 2-byte opcodes\n            }\n\n            // Priority 2: Handle single-byte opcodes (only if not a two-byte opcode)\n\n            // ADD r/m8, reg8\n            if (opcode === 0x00) {\n                const modrm = this.readModRMByte();\n            \n                const regName = this.getRegisterString(modrm.reg, 1, false);\n                const regVal = this.readRegister(regName, 1) & 0xFFn;\n            \n                let destAddr;\n            \n                if (modrm.mod === 0 && modrm.rm === 0) {\n                    const bx = this.readRegister(\"bx\", 2);\n                    const si = this.readRegister(\"si\", 2);\n                    destAddr = Number((bx + si) & 0xFFFFn);\n                } else {\n                    throw new Error(`ADD: Mod/RM mode not yet implemented (mod=${modrm.mod}, rm=${modrm.rm})`);\n                }\n            \n                const memVal = BigInt(this.memory.readUint8(destAddr)) & 0xFFn;\n                const result = (memVal + regVal) & 0xFFn;\n            \n                this.memory.writeUint8(destAddr, Number(result));\n                utils.log(`Decoded: ADD [BX+SI], ${regName} (0x${regVal.toString(16)}) → Result: 0x${result.toString(16)}`);\n                return true;\n            }\n\n            // NOP instruction\n            if (opcode === 0x90) {\n                utils.log(\"Decoded: NOP\");\n                return true;\n            }\n\n            // HLT instruction\n            if (opcode === 0xF4) {\n                this.halted = true;\n                utils.log(\"HLT instruction encountered. Emulation halted.\");\n                return true;\n            }\n\n            // Conditional Jumps (short form: Jcc rel8)\n            // These take a 1-byte signed relative displacement.\n            // JE/JZ (0x74)\n            if (opcode === 0x74) {\n                const displacement = this.readSignedImmediate(1); // Read 1-byte signed displacement\n                utils.log(`Decoded: JE/JZ rel8 0x${displacement.toString(16)} (RIP adjusted)`);\n                if (this.flags.zf === 1) {\n                    this.rip += displacement; // Apply displacement if ZF is set\n                    utils.log(`  Condition Met (ZF=1). Jumping to 0x${this.rip.toString(16)}`);\n                } else {\n                    utils.log(`  Condition Not Met (ZF=0). Not jumping.`);\n                }\n                return true;\n            }\n\n            // JNE/JNZ (0x75)\n            if (opcode === 0x75) {\n                const displacement = this.readSignedImmediate(1); // Read 1-byte signed displacement\n                utils.log(`Decoded: JNE/JNZ rel8 0x${displacement.toString(16)} (RIP adjusted)`);\n                if (this.flags.zf === 0) {\n                    this.rip += displacement; // Apply displacement if ZF is clear\n                    utils.log(`  Condition Met (ZF=0). Jumping to 0x${this.rip.toString(16)}`);\n                } else {\n                    utils.log(`  Condition Not Met (ZF=1). Not jumping.`);\n                }\n                return true;\n            }\n\n            // Universal MOV reg, imm (0xB0 - 0xBF)\n            if (opcode >= 0xB0 && opcode <= 0xBF) {\n                const destRegIdx = (opcode & 0x07) + (rex_b << 3);\n                let sizeBytes;\n\n                if (opcode >= 0xB0 && opcode <= 0xB7) { // 8-bit MOV (B0-B7)\n                    sizeBytes = 1;\n                } else { // 16/32/64-bit MOV (B8-BF)\n                    // THIS IS THE CORRECTED LOGIC\n                    if (this.mode === 'long') {\n                        sizeBytes = rex_w ? 8 : (this.operandSizeOverride ? 2 : 4);\n                    } else { // Real or Protected mode\n                        // Default is 16-bit. 0x66 prefix makes it 32-bit.\n                        sizeBytes = this.operandSizeOverride ? 4 : 2;\n                    }\n                }\n\n                const destRegName = this.getRegisterString(destRegIdx, sizeBytes, rexPrefix !== 0);\n                const immValue = this.readSignedImmediate(sizeBytes === 8 ? 8 : sizeBytes); // 64-bit imm is 64-bit\n                \n                this.writeRegister(destRegName, immValue, sizeBytes);\n                utils.log(`Decoded: MOV ${destRegName.toUpperCase()}, 0x${immValue.toString(16)}`);\n                return true;\n            }\n            \n            // ADD reg, r/m (0x01 / 0x03)\n            if (opcode === 0x01 || opcode === 0x03) {\n                const modrm = this.readModRMByte();\n                const dBit = (opcode >>> 1) & 0x01; \n                const wBit = opcode & 0x01;         \n\n                let sizeBytes = (wBit === 0) ? 1 : defaultOperandSize;\n\n                const regOpFullIndex = modrm.reg + (rex_r << 3);\n                const regOpName = this.getRegisterString(regOpFullIndex, sizeBytes, rexPrefix !== 0); // Pass hasRexPrefix\n                const rmOperand = this.resolveModRMOperand(modrm, sizeBytes, rex_x, rex_b, rexPrefix !== 0); // Pass hasRexPrefixForNaming\n\n                let sourceValue;\n                let destValue;\n                let destOperand; \n\n                if (rmOperand.type === 'reg') {\n                    if (dBit === 0) { \n                        sourceValue = this.readRegister(regOpName, sizeBytes);\n                        destValue = this.readRegister(rmOperand.name, sizeBytes);\n                        destOperand = rmOperand; \n                    } else { \n                        sourceValue = this.readRegister(rmOperand.name, sizeBytes);\n                        destValue = this.readRegister(regOpName, sizeBytes);\n                        destOperand = { type: 'reg', name: regOpName }; \n                    }\n                } else { \n                    if (dBit === 0) { \n                        sourceValue = this.readRegister(regOpName, sizeBytes);\n                        if (sizeBytes === 1) destValue = BigInt(this.readVirtualUint8(rmOperand.address));\n                        else if (sizeBytes === 2) destValue = BigInt(this.readVirtualUint16(rmOperand.address));\n                        else if (sizeBytes === 4) destValue = BigInt(this.readVirtualUint32(rmOperand.address));\n                        else if (sizeBytes === 8) destValue = this.readVirtualBigUint64(rmOperand.address);\n                        else throw new Error(\"Unsupported memory read size for ADD.\");\n                        destOperand = rmOperand; \n                    } else { \n                        if (sizeBytes === 1) sourceValue = BigInt(this.readVirtualUint8(rmOperand.address));\n                        else if (sizeBytes === 2) sourceValue = BigInt(this.readVirtualUint16(rmOperand.address));\n                        else if (sizeBytes === 4) sourceValue = BigInt(this.readVirtualUint32(rmOperand.address));\n                        else if (sizeBytes === 8) sourceValue = this.readVirtualBigUint64(rmOperand.address);\n                        else throw new Error(\"Unsupported memory read size for ADD.\");\n                        destValue = this.readRegister(regOpName, sizeBytes);\n                        destOperand = { type: 'reg', name: regOpName }; \n                    }\n                }\n                \n                const result = destValue + sourceValue;\n                this.updateArithmeticFlags(result, destValue, sourceValue, sizeBytes, 'add');\n\n                if (destOperand.type === 'reg') {\n                    this.writeRegister(destOperand.name, result, sizeBytes);\n                } else { \n                    if (sizeBytes === 1) this.writeVirtualUint8(destOperand.address, Number(result));\n                    else if (sizeBytes === 2) this.writeVirtualUint16(destOperand.address, Number(result));\n                    else if (sizeBytes === 4) this.writeVirtualUint32(destOperand.address, Number(result));\n                    else if (sizeBytes === 8) this.writeVirtualBigUint64(destOperand.address, result);\n                    else throw new Error(\"Unsupported memory write size for ADD.\");\n                }\n                utils.log(`Decoded: ADD ${destOperand.type === 'reg' ? destOperand.name.toUpperCase() : `[0x${destOperand.address.toString(16)}]`}, ${sourceValue.toString(16)}${sizeBytes === 8 ? 'n' : ''} -> Result: 0x${result.toString(16)}n`);\n                return true;\n            }\n\n            // ADD EAX, imm32 (0x05)\n            if (opcode === 0x05) {\n                const imm32 = this.readSignedImmediate(4);\n                const eaxValue = this.readRegister('eax', 4);\n                const result = eaxValue + imm32;\n                this.updateArithmeticFlags(result, eaxValue, imm32, 4, 'add');\n                this.writeRegister('eax', result, 4);\n                utils.log(`Decoded: ADD EAX, 0x${imm32.toString(16)} (Result: 0x${result.toString(16)})`);\n                return true;\n            }\n\n            // OR reg, r/m; OR r/m, reg (0x09 / 0x0B for 16/32/64-bit, 0x08 / 0x0A for 8-bit)\n            if (opcode >= 0x08 && opcode <= 0x0B) {\n                const modrm = this.readModRMByte();\n                const dBit = (opcode >>> 1) & 0x01; // Direction bit\n                const wBit = opcode & 0x01;         // Width bit\n\n                let sizeBytes = (wBit === 0) ? 1 : defaultOperandSize;\n\n                const regOpFullIndex = modrm.reg + (rex_r << 3);\n                const regOpName = this.getRegisterString(regOpFullIndex, sizeBytes, rexPrefix !== 0); // Pass hasRexPrefix\n                const rmOperand = this.resolveModRMOperand(modrm, sizeBytes, rex_x, rex_b, rexPrefix !== 0); // Pass hasRexPrefixForNaming\n\n                let sourceValue;\n                let destValue;\n                let destOperand;\n\n                if (rmOperand.type === 'reg') {\n                    if (dBit === 0) { // OR r/m, reg (reg is source, r/m is dest)\n                        sourceValue = this.readRegister(regOpName, sizeBytes);\n                        destValue = this.readRegister(rmOperand.name, sizeBytes);\n                        destOperand = rmOperand;\n                    } else { // OR reg, r/m (r/m is source, reg is dest)\n                        sourceValue = this.readRegister(rmOperand.name, sizeBytes);\n                        destValue = this.readRegister(regOpName, sizeBytes);\n                        destOperand = { type: 'reg', name: regOpName };\n                    }\n                } else { // rmOperand.type === 'mem'\n                    if (dBit === 0) { // OR r/m, reg (reg is source, r/m is dest)\n                        sourceValue = this.readRegister(regOpName, sizeBytes);\n                        if (sizeBytes === 1) destValue = BigInt(this.readVirtualUint8(rmOperand.address));\n                        else if (sizeBytes === 2) destValue = BigInt(this.readVirtualUint16(rmOperand.address));\n                        else if (sizeBytes === 4) destValue = BigInt(this.readVirtualUint32(rmOperand.address));\n                        else if (sizeBytes === 8) destValue = this.readVirtualBigUint64(rmOperand.address);\n                        else throw new Error(\"Unsupported memory read size for OR.\");\n                        destOperand = rmOperand;\n                    } else { // OR reg, r/m (r/m is source, reg is dest)\n                        if (sizeBytes === 1) sourceValue = BigInt(this.readVirtualUint8(rmOperand.address));\n                        else if (sizeBytes === 2) sourceValue = BigInt(this.readVirtualUint16(rmOperand.address));\n                        else if (sizeBytes === 4) sourceValue = BigInt(this.readVirtualUint32(rmOperand.address));\n                        else if (sizeBytes === 8) sourceValue = this.readVirtualBigUint64(rmOperand.address);\n                        else throw new Error(\"Unsupported memory read size for OR.\");\n                        destValue = this.readRegister(regOpName, sizeBytes);\n                        destOperand = { type: 'reg', name: regOpName };\n                    }\n                }\n                \n                const result = destValue | sourceValue; // Perform OR operation\n\n                this.flags.cf = 0; \n                this.flags.of = 0; \n                this.flags.zf = (result === 0n) ? 1 : 0; \n                const bitWidth = BigInt(sizeBytes * 8);\n                const signBitMask = 1n << (bitWidth - 1n);\n                this.flags.sf = ((result & signBitMask) !== 0n) ? 1 : 0; \n\n                if (destOperand.type === 'reg') {\n                    this.writeRegister(destOperand.name, result, sizeBytes);\n                } else { \n                    if (sizeBytes === 1) this.writeVirtualUint8(destOperand.address, Number(result));\n                    else if (sizeBytes === 2) this.writeVirtualUint16(destOperand.address, Number(result));\n                    else if (sizeBytes === 4) this.writeVirtualUint32(destOperand.address, Number(result));\n                    else if (sizeBytes === 8) this.writeVirtualBigUint64(destOperand.address, result);\n                    else throw new Error(\"Unsupported memory write size for OR.\");\n                }\n                const destOperandString = destOperand.type === 'reg' ? destOperand.name.toUpperCase() : `[0x${destOperand.address.toString(16)}]`;\n                const srcOperandString = (dBit === 0) ? regOpName.toUpperCase() : (rmOperand.type === 'reg' ? rmOperand.name.toUpperCase() : `[0x${rmOperand.address.toString(16)}]`);\n                utils.log(`Decoded: OR ${destOperandString}, ${srcOperandString} (0x${destValue.toString(16)}n | 0x${sourceValue.toString(16)}n) -> Result: 0x${result.toString(16)}n`);\n                return true;\n            }\n\n            // OR AL/AX/EAX/RAX, imm (0x0C / 0x0D)\n            if (opcode === 0x0C || opcode === 0x0D) {\n                const wBit = opcode & 0x01;\n                \n                // USE the defaultOperandSize calculated at the top of step().\n                // This is the source of truth for the operation's size.\n                let sizeBytes = (wBit === 0) ? 1 : defaultOperandSize;\n\n                const regName = this.getRegisterString(0, sizeBytes, rexPrefix !== 0); // Accumulator\n                const regValue = this.readRegister(regName, sizeBytes);\n\n                // The immediate value's size matches the operand size,\n                // except in 64-bit mode where it's a 32-bit immediate.\n                const immediateSize = (sizeBytes === 8) ? 4 : sizeBytes;\n                const immediateValue = this.readSignedImmediate(immediateSize);\n\n                const result = regValue | immediateValue;\n\n                // Flag Calculation\n                this.flags.of = 0;\n                this.flags.cf = 0;\n                const bitMask = (1n << BigInt(sizeBytes * 8)) - 1n;\n                this.flags.zf = (result & bitMask) === 0n ? 1 : 0;\n                const signBitMask = 1n << (BigInt(sizeBytes * 8) - 1n);\n                this.flags.sf = ((result & signBitMask) !== 0n) ? 1 : 0;\n                \n                this.writeRegister(regName, result, sizeBytes);\n\n                utils.log(`Decoded: OR ${regName.toUpperCase()}, 0x${immediateValue.toString(16)}`);\n                return true;\n            }\n\n            // AND reg, r/m; AND r/m, reg (0x21 / 0x23 for 16/32/64-bit, 0x20 / 0x22 for 8-bit)\n            // Note: This block handles AND r/m, reg and AND reg, r/m forms.\n            // Opcodes:\n            // 0x20: AND r/m8, reg8\n            // 0x21: AND r/m16/32/64, reg16/32/64\n            // 0x22: AND reg8, r/m8\n            // 0x23: AND reg16/32/64, r/m16/32/64\n            if (opcode >= 0x20 && opcode <= 0x23) {\n                const modrm = this.readModRMByte();\n                const dBit = (opcode >>> 1) & 0x01; // Direction bit: 0 = r/m <- reg; 1 = reg <- r/m\n                const wBit = opcode & 0x01;         // Width bit: 0 = 8-bit; 1 = 16/32/64-bit\n\n                let sizeBytes = (wBit === 0) ? 1 : defaultOperandSize;\n\n                // Use REX.R for the 'reg' field and REX.B for the 'rm' field in ModR/M\n                const regOpFullIndex = modrm.reg + (rex_r << 3);\n\n                const regOpName = this.getRegisterString(regOpFullIndex, sizeBytes, rexPrefix !== 0); // Pass hasRexPrefix\n                \n                // Resolve rmOperand, noting it might be a register or memory\n                const rmOperand = this.resolveModRMOperand(modrm, sizeBytes, rex_x, rex_b, rexPrefix !== 0); // Pass hasRexPrefixForNaming\n\n                let sourceValue;\n                let destValue;\n                let destOperand; // This will store where the result should be written\n\n                // Determine source and destination based on D-bit\n                if (dBit === 0) { // AND r/m, reg (reg is source, r/m is dest)\n                    sourceValue = this.readRegister(regOpName, sizeBytes); // Source is the register specified by ModR/M.reg\n                    if (rmOperand.type === 'reg') {\n                        destValue = this.readRegister(rmOperand.name, sizeBytes);\n                        destOperand = rmOperand;\n                    } else { // Memory destination\n                        if (sizeBytes === 1) destValue = BigInt(this.readVirtualUint8(rmOperand.address));\n                        else if (sizeBytes === 2) destValue = BigInt(this.readVirtualUint16(rmOperand.address));\n                        else if (sizeBytes === 4) destValue = BigInt(this.readVirtualUint32(rmOperand.address));\n                        else if (sizeBytes === 8) destValue = this.readVirtualBigUint64(rmOperand.address);\n                        else throw new Error(\"Unsupported memory read size for AND (dBit=0).\");\n                        destOperand = rmOperand;\n                    }\n                } else { // dBit === 1: AND reg, r/m (r/m is source, reg is dest)\n                    destValue = this.readRegister(regOpName, sizeBytes); // Destination is the register specified by ModR/M.reg\n                    destOperand = { type: 'reg', name: regOpName }; // Set destination for writing\n\n                    if (rmOperand.type === 'reg') {\n                        sourceValue = this.readRegister(rmOperand.name, sizeBytes);\n                    } else { // Memory source\n                        if (sizeBytes === 1) sourceValue = BigInt(this.readVirtualUint8(rmOperand.address));\n                        else if (sizeBytes === 2) sourceValue = BigInt(this.readVirtualUint16(rmOperand.address));\n                        else if (sizeBytes === 4) sourceValue = BigInt(this.readVirtualUint32(rmOperand.address));\n                        else if (sizeBytes === 8) sourceValue = this.readVirtualBigUint64(rmOperand.address);\n                        else throw new Error(\"Unsupported memory read size for AND (dBit=1).\");\n                    }\n                }\n                \n                const result = destValue & sourceValue; // Perform AND operation\n\n                // For logical operations (AND, OR, XOR), CF and OF are always 0.\n                this.flags.cf = 0;\n                this.flags.of = 0;\n                this.flags.zf = (result === 0n) ? 1 : 0;\n                // SF is set if the most significant bit of the result is 1 (after masking to operand size)\n                const bitWidth = BigInt(sizeBytes * 8);\n                const signBitMask = 1n << (bitWidth - 1n);\n                this.flags.sf = ((result & signBitMask) !== 0n) ? 1 : 0;\n\n                // Write the result back to the destination operand\n                if (destOperand.type === 'reg') {\n                    this.writeRegister(destOperand.name, result, sizeBytes);\n                } else { // destOperand.type === 'mem'\n                    if (sizeBytes === 1) this.writeVirtualUint8(destOperand.address, Number(result));\n                    else if (sizeBytes === 2) this.writeVirtualUint16(destOperand.address, Number(result));\n                    else if (sizeBytes === 4) this.writeVirtualUint32(destOperand.address, Number(result));\n                    else if (sizeBytes === 8) this.writeVirtualBigUint64(destOperand.address, result);\n                    else throw new Error(\"Unsupported memory write size for AND.\");\n                }\n                \n                // Improved logging for AND\n                const destOperandString = destOperand.type === 'reg' ? destOperand.name.toUpperCase() : `[0x${destOperand.address.toString(16)}]`;\n                const srcOperandString = (dBit === 0) ? regOpName.toUpperCase() : (rmOperand.type === 'reg' ? rmOperand.name.toUpperCase() : `[0x${rmOperand.address.toString(16)}]`);\n                utils.log(`Decoded: AND ${destOperandString}, ${srcOperandString} (0x${destValue.toString(16)}n & 0x${sourceValue.toString(16)}n) -> Result: 0x${result.toString(16)}n`);\n                return true;\n            }\n\n            // XOR reg, r/m (0x31 / 0x33)\n            if (opcode === 0x31 || opcode === 0x33) {\n                const modrm = this.readModRMByte();\n                const dBit = (opcode >>> 1) & 0x01; \n                const wBit = opcode & 0x01;         \n\n                let sizeBytes = (wBit === 0) ? 1 : defaultOperandSize;\n\n                const regOpFullIndex = modrm.reg + (rex_r << 3);\n                const regOpName = this.getRegisterString(regOpFullIndex, sizeBytes, rexPrefix !== 0); // Pass hasRexPrefix\n                const rmOperand = this.resolveModRMOperand(modrm, sizeBytes, rex_x, rex_b, rexPrefix !== 0); // Pass hasRexPrefixForNaming\n\n                let sourceValue;\n                let destValue;\n                let destOperand;\n\n                if (rmOperand.type === 'reg') {\n                    if (dBit === 0) { \n                        sourceValue = this.readRegister(regOpName, sizeBytes);\n                        destValue = this.readRegister(rmOperand.name, sizeBytes);\n                        destOperand = rmOperand;\n                    } else { \n                        sourceValue = this.readRegister(rmOperand.name, sizeBytes);\n                        destValue = this.readRegister(regOpName, sizeBytes);\n                        destOperand = { type: 'reg', name: regOpName };\n                    }\n                } else { \n                    if (dBit === 0) { \n                        sourceValue = this.readRegister(regOpName, sizeBytes);\n                        if (sizeBytes === 1) destValue = BigInt(this.readVirtualUint8(rmOperand.address));\n                        else if (sizeBytes === 2) destValue = BigInt(this.readVirtualUint16(rmOperand.address));\n                        else if (sizeBytes === 4) destValue = BigInt(this.readVirtualUint32(rmOperand.address));\n                        else if (sizeBytes === 8) destValue = this.readVirtualBigUint64(rmOperand.address);\n                        else throw new Error(\"Unsupported memory read size for XOR.\");\n                        destOperand = rmOperand;\n                    } else { \n                        if (sizeBytes === 1) sourceValue = BigInt(this.readVirtualUint8(rmOperand.address));\n                        else if (sizeBytes === 2) sourceValue = BigInt(this.readVirtualUint16(rmOperand.address));\n                        else if (sizeBytes === 4) sourceValue = BigInt(this.readVirtualUint32(rmOperand.address));\n                        else if (sizeBytes === 8) sourceValue = this.readVirtualBigUint64(rmOperand.address);\n                        else throw new Error(\"Unsupported memory read size for XOR.\");\n                        destValue = this.readRegister(regOpName, sizeBytes);\n                        destOperand = { type: 'reg', name: regOpName };\n                    }\n                }\n                \n                const result = destValue ^ sourceValue; // Perform XOR operation\n\n                this.flags.cf = 0; \n                this.flags.of = 0; \n                this.flags.zf = (result === 0n) ? 1 : 0; \n                this.flags.sf = ((result >> (BigInt(sizeBytes * 8) - 1n)) & 1n) === 1n ? 1 : 0; \n\n                if (destOperand.type === 'reg') {\n                    this.writeRegister(destOperand.name, result, sizeBytes);\n                } else { \n                    if (sizeBytes === 1) this.writeVirtualUint8(destOperand.address, Number(result));\n                    else if (sizeBytes === 2) this.writeVirtualUint16(destOperand.address, Number(result));\n                    else if (sizeBytes === 4) this.writeVirtualUint32(destOperand.address, Number(result));\n                    else if (sizeBytes === 8) this.writeVirtualBigUint64(destOperand.address, result);\n                    else throw new Error(\"Unsupported memory write size for XOR.\");\n                }\n                utils.log(`Decoded: XOR ${destOperand.type === 'reg' ? destOperand.name.toUpperCase() : `[0x${destOperand.address.toString(16)}]`}, ${sourceValue.toString(16)}${sizeBytes === 8 ? 'n' : ''} -> Result: 0x${result.toString(16)}n`);\n                return true;\n            }\n\n            // SUB reg, r/m (0x29 / 0x2B)\n            if (opcode === 0x29 || opcode === 0x2B) {\n                const modrm = this.readModRMByte();\n                const dBit = (opcode >>> 1) & 0x01; // Direction bit\n                const wBit = opcode & 0x01;         // Width bit\n\n                let sizeBytes = (wBit === 0) ? 1 : defaultOperandSize;\n\n                const regOpFullIndex = modrm.reg + (rex_r << 3);\n                const regOpName = this.getRegisterString(regOpFullIndex, sizeBytes, rexPrefix !== 0); // Pass hasRexPrefix\n                const rmOperand = this.resolveModRMOperand(modrm, sizeBytes, rex_x, rex_b, rexPrefix !== 0); // Pass hasRexPrefixForNaming\n\n                let sourceValue; // Subtrahend\n                let destValue;   // Minuend\n                let destOperand; \n\n                if (rmOperand.type === 'reg') {\n                    if (dBit === 0) { // SUB r/m, reg (reg is subtrahend, r/m is minuend/dest)\n                        sourceValue = this.readRegister(regOpName, sizeBytes);\n                        destValue = this.readRegister(rmOperand.name, sizeBytes);\n                        destOperand = rmOperand; \n                    } else { // SUB reg, r/m (r/m is subtrahend, reg is minuend/dest)\n                        sourceValue = this.readRegister(rmOperand.name, sizeBytes);\n                        destValue = this.readRegister(regOpName, sizeBytes);\n                        destOperand = { type: 'reg', name: regOpName }; \n                    }\n                } else { // rmOperand.type === 'mem'\n                    if (dBit === 0) { // SUB r/m, reg (reg is subtrahend, r/m is minuend/dest)\n                        sourceValue = this.readRegister(regOpName, sizeBytes);\n                        if (sizeBytes === 1) destValue = BigInt(this.readVirtualUint8(rmOperand.address));\n                        else if (sizeBytes === 2) destValue = BigInt(this.readVirtualUint16(rmOperand.address));\n                        else if (sizeBytes === 4) destValue = BigInt(this.readVirtualUint32(rmOperand.address));\n                        else if (sizeBytes === 8) destValue = this.readVirtualBigUint64(rmOperand.address);\n                        else throw new Error(\"Unsupported memory read size for SUB.\");\n                        destOperand = rmOperand; \n                    } else { // SUB reg, r/m (r/m is subtrahend, reg is minuend/dest)\n                        if (sizeBytes === 1) sourceValue = BigInt(this.readVirtualUint8(rmOperand.address));\n                        else if (sizeBytes === 2) sourceValue = BigInt(this.readVirtualUint16(rmOperand.address));\n                        else if (sizeBytes === 4) sourceValue = BigInt(this.readVirtualUint32(rmOperand.address));\n                        else if (sizeBytes === 8) sourceValue = this.readVirtualBigUint64(rmOperand.address);\n                        else throw new Error(\"Unsupported memory read size for SUB.\");\n                        destValue = this.readRegister(regOpName, sizeBytes);\n                        destOperand = { type: 'reg', name: regOpName }; \n                    }\n                }\n                \n                const result = destValue - sourceValue;\n                this.updateArithmeticFlags(result, destValue, sourceValue, sizeBytes, 'sub');\n\n                if (destOperand.type === 'reg') {\n                    this.writeRegister(destOperand.name, result, sizeBytes);\n                } else { // destOperand.type === 'mem'\n                    if (sizeBytes === 1) this.writeVirtualUint8(destOperand.address, Number(result));\n                    else if (sizeBytes === 2) this.writeVirtualUint16(destOperand.address, Number(result));\n                    else if (sizeBytes === 4) this.writeVirtualUint32(destOperand.address, Number(result));\n                    else if (sizeBytes === 8) this.writeVirtualBigUint64(destOperand.address, result);\n                    else throw new Error(\"Unsupported memory write size for SUB.\");\n                }\n                utils.log(`Decoded: SUB ${destOperand.type === 'reg' ? destOperand.name.toUpperCase() : `[0x${destOperand.address.toString(16)}]`}, ${sourceValue.toString(16)}${sizeBytes === 8 ? 'n' : ''} -> Result: 0x${result.toString(16)}n`);\n                return true;\n            }\n\n            // CMP reg, r/m; CMP r/m, reg (0x39 / 0x3B for 32/64-bit, 0x38 / 0x3A for 8-bit)\n            if (opcode >= 0x38 && opcode <= 0x3B) {\n                const modrm = this.readModRMByte();\n                const dBit = (opcode >>> 1) & 0x01; // Direction bit\n                const wBit = opcode & 0x01;         // Width bit\n\n                let sizeBytes = (wBit === 0) ? 1 : defaultOperandSize;\n\n                const regOpFullIndex = modrm.reg + (rex_r << 3);\n                const regOpName = this.getRegisterString(regOpFullIndex, sizeBytes, rexPrefix !== 0); // Pass hasRexPrefix\n                const rmOperand = this.resolveModRMOperand(modrm, sizeBytes, rex_x, rex_b, rexPrefix !== 0); // Pass hasRexPrefixForNaming\n\n                let sourceValue; // Subtrahend\n                let destValue;   // Minuend\n\n                if (rmOperand.type === 'reg') {\n                    if (dBit === 0) { // CMP r/m, reg (reg is subtrahend, r/m is minuend)\n                        sourceValue = this.readRegister(regOpName, sizeBytes);\n                        destValue = this.readRegister(rmOperand.name, sizeBytes);\n                    } else { // CMP reg, r/m (r/m is subtrahend, reg is minuend)\n                        sourceValue = this.readRegister(rmOperand.name, sizeBytes);\n                        destValue = this.readRegister(regOpName, sizeBytes);\n                    }\n                } else { // rmOperand.type === 'mem'\n                    if (dBit === 0) { // CMP r/m, reg (reg is subtrahend, r/m is minuend)\n                        sourceValue = this.readRegister(regOpName, sizeBytes);\n                        if (sizeBytes === 1) destValue = BigInt(this.readVirtualUint8(rmOperand.address));\n                        else if (sizeBytes === 2) destValue = BigInt(this.readVirtualUint16(rmOperand.address));\n                        else if (sizeBytes === 4) destValue = BigInt(this.readVirtualUint32(rmOperand.address));\n                        else if (sizeBytes === 8) destValue = this.readVirtualBigUint64(rmOperand.address);\n                        else throw new Error(\"Unsupported memory read size for CMP.\");\n                    } else { // CMP reg, r/m (r/m is subtrahend, reg is minuend)\n                        if (sizeBytes === 1) sourceValue = BigInt(this.readVirtualUint8(rmOperand.address));\n                        else if (sizeBytes === 2) sourceValue = BigInt(this.readVirtualUint16(rmOperand.address));\n                        else if (sizeBytes === 4) sourceValue = BigInt(this.readVirtualUint32(rmOperand.address));\n                        else if (sizeBytes === 8) sourceValue = this.readVirtualBigUint64(rmOperand.address);\n                        else throw new Error(\"Unsupported memory read size for CMP.\");\n                        destValue = this.readRegister(regOpName, sizeBytes);\n                    }\n                }\n                \n                // Perform the subtraction for flags, but do not write the result back\n                const result = destValue - sourceValue;\n                this.updateArithmeticFlags(result, destValue, sourceValue, sizeBytes, 'sub');\n\n                const destOperandString = (dBit === 0) ? (rmOperand.type === 'reg' ? rmOperand.name.toUpperCase() : `[0x${rmOperand.address.toString(16)}]`) : regOpName.toUpperCase();\n                const srcOperandString = (dBit === 0) ? regOpName.toUpperCase() : (rmOperand.type === 'reg' ? rmOperand.name.toUpperCase() : `[0x${rmOperand.address.toString(16)}]`);\n                utils.log(`Decoded: CMP ${destOperandString}, ${srcOperandString} (0x${destValue.toString(16)}n - 0x${sourceValue.toString(16)}n)`);\n                return true;\n            }\n\n            // CMP r/m32, imm32 (0x81 /7)\n            if (opcode === 0x81) {\n                const modrm = this.readModRMByte();\n                if (modrm.reg === 7) {\n                    const imm32 = this.readSignedImmediate(4);\n                    let sizeBytes = 4;\n                    const rmOperand = this.resolveModRMOperand(modrm, sizeBytes, rex_x, rex_b, rexPrefix !== 0);\n\n                    let destValue;\n                    if (rmOperand.type === 'reg') {\n                        destValue = this.readRegister(rmOperand.name, sizeBytes);\n                    } else {\n                        destValue = BigInt(this.readVirtualUint32(rmOperand.address));\n                    }\n                    const result = destValue - imm32;\n                    this.updateArithmeticFlags(result, destValue, imm32, sizeBytes, 'sub');\n                    utils.log(`Decoded: CMP ${rmOperand.type === 'reg' ? rmOperand.name.toUpperCase() : `[0x${rmOperand.address.toString(16)}]`}, 0x${imm32.toString(16)}`);\n                    return true;\n                }\n            }\n\n            // Group 1 Instructions (ADD, OR, ADC, SBB, AND, SUB, XOR, CMP) with immediate\n            // 0x81: r/m, imm32\n            // 0x83: r/m, imm8 (sign-extended)\n            if (opcode === 0x81 || opcode === 0x83) {\n                const modrm = this.readModRMByte();\n                let sizeBytes = defaultOperandSize;\n\n                const rmOperand = this.resolveModRMOperand(modrm, sizeBytes, rex_x, rex_b, rexPrefix !== 0);\n\n                // Opcode 0x83 uses a sign-extended 8-bit immediate.\n                // Opcode 0x81 uses a 16/32-bit immediate.\n                const immediateSizeBytes = (opcode === 0x83) ? 1 : (sizeBytes === 2 ? 2 : 4);\n                const immediateValue = this.readSignedImmediate(immediateSizeBytes);\n\n                // Read the destination value\n                let destValue;\n                if (rmOperand.type === 'reg') {\n                    destValue = this.readRegister(rmOperand.name, sizeBytes);\n                } else { // Memory\n                    if (sizeBytes === 1) destValue = BigInt(this.readVirtualUint8(rmOperand.address));\n                    else if (sizeBytes === 2) destValue = BigInt(this.readVirtualUint16(rmOperand.address));\n                    else if (sizeBytes === 4) destValue = BigInt(this.readVirtualUint32(rmOperand.address));\n                    else destValue = this.readVirtualBigUint64(rmOperand.address);\n                }\n\n                let result;\n                let operation = 'unknown';\n\n                // The 'reg' field selects the operation\n                switch (modrm.reg) {\n                    case 0: // ADD\n                        operation = 'add';\n                        result = destValue + immediateValue;\n                        break;\n                    case 1: // OR\n                        operation = 'or';\n                        result = destValue | immediateValue;\n                        break;\n                    case 2: // ADC\n                        operation = 'adc';\n                        result = destValue + immediateValue + this.flags.cf;\n                        break;\n                    case 3: // SBB\n                        operation = 'sbb';\n                        result = destValue - immediateValue - this.flags.cf;\n                        break;\n                    case 4: // AND\n                        operation = 'and';\n                        result = destValue & immediateValue;\n                        break;\n                    case 5: // SUB\n                        operation = 'sub';\n                        result = destValue - immediateValue;\n                        break;\n                    case 6: // XOR\n                        operation = 'xor';\n                        result = destValue ^ immediateValue;\n                        break;\n                    case 7: // CMP\n                        operation = 'sub'; // CMP performs a subtraction for flags\n                        result = destValue - immediateValue;\n                        break;\n                    default:\n                        throw new Error(`Unsupported Group 1 operation with /reg=${modrm.reg}`);\n                }\n\n                // Update flags based on the operation\n                if (operation === 'add' || operation === 'sub' || operation === 'adc' || operation === 'sbb') {\n                    // For ADC and SBB, the \"second operand\" is conceptually the immediate value PLUS the carry/borrow.\n                    const effectiveOperand2 = (operation === 'adc' || operation === 'sbb')\n                        ? immediateValue + BigInt(this.flags.cf)\n                        : immediateValue;\n                    \n                    // The operation for flags is always a simple add or sub.\n                    const flagOperation = (operation === 'add' || operation === 'adc') ? 'add' : 'sub';\n\n                    this.updateArithmeticFlags(result, destValue, effectiveOperand2, sizeBytes, flagOperation);\n                } else { // Logical ops (AND, OR, XOR)\n                    this.flags.cf = 0;\n                    this.flags.of = 0;\n                    const bitMask = (1n << BigInt(sizeBytes * 8)) - 1n;\n                    this.flags.zf = (result & bitMask) === 0n ? 1 : 0;\n                    const signBitMask = 1n << (BigInt(sizeBytes * 8) - 1n);\n                    this.flags.sf = ((result & signBitMask) !== 0n) ? 1 : 0;\n                }\n\n                // For all operations except CMP, write the result back\n                if (modrm.reg !== 7) { // if not CMP\n                    if (rmOperand.type === 'reg') {\n                        this.writeRegister(rmOperand.name, result, sizeBytes);\n                    } else { // Memory\n                        if (sizeBytes === 1) this.writeVirtualUint8(rmOperand.address, Number(result));\n                        else if (sizeBytes === 2) this.writeVirtualUint16(rmOperand.address, Number(result));\n                        else if (sizeBytes === 4) this.writeVirtualUint32(rmOperand.address, Number(result));\n                        else this.writeVirtualBigUint64(rmOperand.address, result);\n                    }\n                }\n                \n                const mnemonic = ['ADD', 'OR', 'ADC', 'SBB', 'AND', 'SUB', 'XOR', 'CMP'][modrm.reg];\n                const rmStr = rmOperand.type === 'reg' ? rmOperand.name.toUpperCase() : `[0x${rmOperand.address.toString(16)}]`;\n                utils.log(`Decoded: ${mnemonic} ${rmStr}, 0x${immediateValue.toString(16)}`);\n                return true;\n            }\n\n            // CMP AL/AX/EAX/RAX, imm (0x3C / 0x3D)\n            if (opcode === 0x3C || opcode === 0x3D) {\n                const wBit = opcode & 0x01;\n                let sizeBytes = (wBit === 0) ? 1 : defaultOperandSize;\n\n                const regName = this.getRegisterString(0, sizeBytes, rexPrefix !== 0); // Always AL/AX/EAX/RAX\n                const regValue = this.readRegister(regName, sizeBytes);\n                \n                // Note: Even for CMP RAX, the immediate is only 32 bits and is sign-extended.\n                const immediateSize = (sizeBytes === 1) ? 1 : 4;\n                const immediateValue = this.readSignedImmediate(immediateSize);\n\n                const result = regValue - immediateValue;\n                this.updateArithmeticFlags(result, regValue, immediateValue, sizeBytes, 'sub');\n                \n                // CMP does not store the result, it only sets flags.\n\n                utils.log(`Decoded: CMP ${regName.toUpperCase()}, 0x${immediateValue.toString(16)}`);\n                return true;\n            }\n\n            // MOV r/m, reg; MOV reg, r/m (0x88, 0x89, 0x8A, 0x8B)\n            if (opcode >= 0x88 && opcode <= 0x8B) {\n                const modrm = this.readModRMByte();\n                const dBit = (opcode >>> 1) & 0x01;\n                const wBit = opcode & 0x01;\n\n                let sizeBytes = (wBit === 0) ? 1 : defaultOperandSize;\n\n                const regOpFullIndex = modrm.reg + (rex_r << 3);\n                const regOpName = this.getRegisterString(regOpFullIndex, sizeBytes, rexPrefix !== 0);\n                const rmOperand = this.resolveModRMOperand(modrm, sizeBytes, rex_r, rex_b, rex_x, rexPrefix !== 0);\n                \n                const fullRegNameForVerify = this.registers[regOpName]; // Get the full 64-bit register name (e.g., 'rax' from 'ax')\n\n                console.info(`--- MOV [r/m],reg START (Opcode: 0x${opcode.toString(16)}) ---`);\n                console.info(`  dBit=${dBit}, sizeBytes=${sizeBytes}, regOp=${regOpName}, rmOperand.addr=0x${rmOperand.address?.toString(16)}`);\n\n                if (dBit === 0) { // Direction: r/m <- reg\n                    const sourceValue = this.readRegister(regOpName, sizeBytes);\n                    console.info(`  DIRECTION: r/m <- reg. Writing 0x${sourceValue.toString(16)} from ${regOpName}...`);\n                    \n                    if (rmOperand.type === 'reg') {\n                        this.writeRegister(rmOperand.name, sourceValue, sizeBytes);\n                    } else { // Memory Destination\n                        console.info(`  ...to MEMORY at 0x${rmOperand.address.toString(16)}`);\n                        if (sizeBytes === 1) this.writeVirtualUint8(rmOperand.address, sourceValue);\n                        else if (sizeBytes === 2) this.writeVirtualUint16(rmOperand.address, sourceValue);\n                        else if (sizeBytes === 4) this.writeVirtualUint32(rmOperand.address, sourceValue);\n                        else this.writeVirtualBigUint64(rmOperand.address, sourceValue);\n                    }\n                } else { // dBit === 1, Direction: reg <- r/m\n                    const destRegName = regOpName;\n                    let sourceValue;\n                    \n                    console.info(`  DIRECTION: reg <- r/m. Reading from r/m operand...`);\n\n                    if (rmOperand.type === 'reg') {\n                        sourceValue = this.readRegister(rmOperand.name, sizeBytes);\n                    } else { // Memory Source\n                        sourceValue = sizeBytes === 1 ? BigInt(this.readVirtualUint8(rmOperand.address))\n                                    : sizeBytes === 2 ? BigInt(this.readVirtualUint16(rmOperand.address))\n                                    : sizeBytes === 4 ? BigInt(this.readVirtualUint32(rmOperand.address))\n                                    : this.readVirtualBigUint64(rmOperand.address);\n                    }\n                    \n                    console.info(`  Read value 0x${sourceValue.toString(16)} from r/m. Writing to ${destRegName}.`);\n                    this.writeRegister(destRegName, sourceValue, sizeBytes);\n\n                    // === THIS IS THE CRITICAL NEW LOG ===\n                    console.info(`  VERIFY: After writing to ${destRegName}, the full register ${fullRegNameForVerify} is now 0x${this[fullRegNameForVerify].toString(16)}`);\n                    // ===================================\n                }\n                console.info(`--- MOV [r/m],reg END ---`);\n                return true;\n            }\n\n            // MOV r/m{16,32,64}, imm{16,32,64} (0xC7 /0)\n            if (opcode === 0xC7) {\n                const modrm = this.readModRMByte();\n                \n                // For 0xC7, the reg field in ModR/M should be 0\n                if (modrm.reg !== 0) {\n                    throw new Error(`Invalid ModR/M reg field for MOV r/m, imm: ${modrm.reg}`);\n                }\n                \n                // Determine operand size based on prefix and mode\n                let sizeBytes, targetSizeBytes;\n                if (rexPrefix !== 0 && (rexPrefix & 0x08)) {  // REX.W prefix\n                    sizeBytes = 4;  // 32-bit immediate sign-extended to 64-bit\n                    targetSizeBytes = 8;  // Target is 64-bit\n                } else if (this.operandSizeOverride) {\n                    sizeBytes = 2; // 16-bit with 66h prefix\n                    targetSizeBytes = 2;\n                } else {\n                    sizeBytes = 4; // 32-bit\n                    targetSizeBytes = 4;\n                }\n                \n                // Read immediate value\n                let immValue = this.readSignedImmediate(sizeBytes);\n                \n                // Sign extend to 64 bits if needed\n                if (sizeBytes === 4 && targetSizeBytes === 8) {\n                    immValue = BigInt.asIntN(32, immValue);\n                }\n                \n                // Resolve the destination operand with target size\n                const rmOperand = this.resolveModRMOperand(modrm, targetSizeBytes, rex_r, rex_b, rexPrefix !== 0);\n                \n                // Write the immediate to the destination\n                if (rmOperand.type === 'reg') {\n                    this.writeRegister(rmOperand.name, immValue, targetSizeBytes);\n                } else {\n                    // For memory destination, use the actual size of the immediate\n                    if (sizeBytes === 1) {\n                        this.writeVirtualUint8(rmOperand.address, Number(immValue));\n                    } else if (sizeBytes === 2) {\n                        this.writeVirtualUint16(rmOperand.address, Number(immValue));\n                    } else if (sizeBytes === 4) {\n                        this.writeVirtualUint32(rmOperand.address, Number(immValue));\n                    } else {\n                        throw new Error(`Unsupported size for MOV r/m, imm: ${sizeBytes} bytes`);\n                    }\n                }\n                \n                utils.log(`Decoded: MOV ${rmOperand.type === 'reg' ? rmOperand.name.toUpperCase() : `[0x${rmOperand.address.toString(16)}]`}, 0x${immValue.toString(16)}`);\n                return true;\n            }\n\n            // MOV r/m8, imm8 (0xC6 /0)\n            if (opcode === 0xC6) {\n                const modrm = this.readModRMByte();\n            \n                if (modrm.reg !== 0) {\n                    throw new Error(`Invalid ModR/M reg field for MOV r/m8, imm8: ${modrm.reg}`);\n                }\n            \n                const rmOperand = this.resolveModRMOperand(modrm, 1, rex_r, rex_b, rexPrefix !== 0);\n            \n                const immValue = this.readSignedImmediate(1); // Reads and advances RIP by 1\n            \n                if (rmOperand.type === 'reg') {\n                    this.writeRegister(rmOperand.name, immValue, 1);\n                } else {\n                    this.writeVirtualUint8(rmOperand.address, Number(immValue));\n                }\n            \n                utils.log(`Decoded: MOV byte ${rmOperand.type === 'reg' ? rmOperand.name.toUpperCase() : `[0x${rmOperand.address.toString(16)}]`}, 0x${immValue.toString(16)}`);\n                return true;\n            }\n\n            // MOV SR, r/m16 (0x8E /r)\n            if (opcode === 0x8E) {\n                const modrm = this.readModRMByte();\n            \n                const segmentRegs = ['es', 'cs', 'ss', 'ds', 'fs', 'gs'];\n                const sregName = segmentRegs[modrm.reg];\n            \n                if (!sregName) {\n                    throw new Error(`Invalid segment register index: ${modrm.reg}`);\n                }\n            \n                const rmOperand = this.resolveModRMOperand(modrm, 2, rex_r, rex_b, rexPrefix !== 0);\n            \n                let value;\n                if (rmOperand.type === 'reg') {\n                    value = Number(this.readRegister(rmOperand.name, 2)); // value is 16-bit number\n                } else {\n                    value = this.readVirtualUint16(rmOperand.address);\n                }\n            \n                // Write value into the segment register (16-bit)\n                this.writeRegister(sregName, BigInt(value), 2);\n            \n                utils.log(`Decoded: MOV ${sregName.toUpperCase()}, ${rmOperand.type === 'reg' ? rmOperand.name.toUpperCase() : `[0x${rmOperand.address.toString(16)}]`} (0x${value.toString(16)})`);\n                return true;\n            }\n\n            // PUSH reg (0x50 + reg_index)\n            if (opcode >= 0x50 && opcode <= 0x57) {\n                const regIdx = opcode - 0x50;\n                const sizeBytes = 8;\n                const regName = this.getRegisterString(regIdx, sizeBytes, rexPrefix !== 0);\n                const value = this.readRegister(regName, sizeBytes);\n                utils.log(`PUSH ${regName.toUpperCase()} - RSP Before: 0x${this.rsp.toString(16)}`);\n                this.rsp -= BigInt(sizeBytes);\n                this.writeVirtualBigUint64(this.rsp, value);\n                utils.log(`Decoded: PUSH ${regName.toUpperCase()} (0x${value.toString(16)}n)`);\n                utils.log(`PUSH ${regName.toUpperCase()} - RSP After: 0x${this.rsp.toString(16)}`);\n                return true;\n            }\n\n            // PUSH r/m (0xFF /6)\n            if (opcode === 0xFF) {\n                const modrm = this.readModRMByte();\n                if (modrm.reg === 6) { // PUSH r/m\n                    let sizeBytes = defaultOperandSize;\n                    const rmOperand = this.resolveModRMOperand(modrm, sizeBytes, rex_x, rex_b, rexPrefix !== 0);\n                    \n                    let value;\n                    if (rmOperand.type === 'reg') {\n                        value = this.readRegister(rmOperand.name, sizeBytes);\n                    } else {\n                        if (sizeBytes === 1) value = BigInt(this.readVirtualUint8(rmOperand.address));\n                        else if (sizeBytes === 2) value = BigInt(this.readVirtualUint16(rmOperand.address));\n                        else if (sizeBytes === 4) value = BigInt(this.readVirtualUint32(rmOperand.address));\n                        else if (sizeBytes === 8) value = this.readVirtualBigUint64(rmOperand.address);\n                        else throw new Error(\"Unsupported memory read size for PUSH r/m.\");\n                    }\n                    utils.log(`PUSH ${rmOperand.type === 'reg' ? rmOperand.name.toUpperCase() : `[0x${rmOperand.address.toString(16)}]`} - RSP Before: 0x${this.rsp.toString(16)}`);\n                    this.rsp -= BigInt(sizeBytes);\n                    this.writeVirtualBigUint64(this.rsp, value);\n                    \n                    utils.log(`Decoded: PUSH ${rmOperand.type === 'reg' ? rmOperand.name.toUpperCase() : `[0x${rmOperand.address.toString(16)}]`} (0x${value.toString(16)}n)`);\n                    utils.log(`PUSH ${rmOperand.type === 'reg' ? rmOperand.name.toUpperCase() : `[0x${rmOperand.address.toString(16)}]`} - RSP After: 0x${this.rsp.toString(16)}`);\n                    return true;\n                }\n            }\n\n            // POP reg (0x58 + reg_index)\n            if (opcode >= 0x58 && opcode <= 0x5F) {\n                const regIdx = opcode - 0x58;\n                const sizeBytes = 8;\n                const regName = this.getRegisterString(regIdx, sizeBytes, rexPrefix !== 0);\n                utils.log(`POP ${regName.toUpperCase()} - RSP Before: 0x${this.rsp.toString(16)}`);\n                const value = this.readVirtualBigUint64(this.rsp);\n                this.writeRegister(regName, value, sizeBytes);\n                this.rsp += BigInt(sizeBytes);\n                \n                utils.log(`Decoded: POP ${regName.toUpperCase()} (0x${value.toString(16)}n)`);\n                utils.log(`POP ${regName.toUpperCase()} - RSP After: 0x${this.rsp.toString(16)}`);\n                return true;\n            }\n\n            // POP r/m (0x8F /0)\n            if (opcode === 0x8F) {\n                const modrm = this.readModRMByte();\n                if (modrm.reg === 0) { // POP r/m\n                    let sizeBytes = defaultOperandSize;\n                    const rmOperand = this.resolveModRMOperand(modrm, sizeBytes, rex_x, rex_b, rexPrefix !== 0);\n                    \n                    utils.log(`POP ${rmOperand.type === 'reg' ? rmOperand.name.toUpperCase() : `[0x${rmOperand.address.toString(16)}]`} - RSP Before: 0x${this.rsp.toString(16)}`);\n                    this.rsp += BigInt(sizeBytes);\n                    this.writeRegister(rmOperand.name, value, sizeBytes);\n\n                    let value;\n                    if (rmOperand.type === 'reg') {\n                        value = this.readRegister(rmOperand.name, sizeBytes);\n                    } else {\n                        if (sizeBytes === 1) value = BigInt(this.readVirtualUint8(rmOperand.address));\n                        else if (sizeBytes === 2) value = BigInt(this.readVirtualUint16(rmOperand.address));\n                        else if (sizeBytes === 4) value = BigInt(this.readVirtualUint32(rmOperand.address));\n                        else if (sizeBytes === 8) value = this.readVirtualBigUint64(rmOperand.address);\n                        else throw new Error(\"Unsupported memory read size for POP r/m.\");\n                    }\n\n                    utils.log(`Decoded: POP ${rmOperand.type === 'reg' ? rmOperand.name.toUpperCase() : `[0x${rmOperand.address.toString(16)}]`} (0x${value.toString(16)}n)`);\n                    utils.log(`POP ${rmOperand.type === 'reg' ? rmOperand.name.toUpperCase() : `[0x${rmOperand.address.toString(16)}]`} - RSP After: 0x${this.rsp.toString(16)}`);\n                    return true;\n                }\n            }\n\n            // CALL rel32 (0xE8) - Near, relative, 32-bit displacement\n            if (opcode === 0xE8) {\n                const displacement = this.readSignedImmediate(4);\n                const retAddr = this.rip;\n                utils.log(`CALL rel32 - RSP Before: 0x${this.rsp.toString(16)}`);\n                this.rsp -= 8n;\n                this.writeVirtualBigUint64(this.rsp, retAddr);\n                this.rip += BigInt(displacement);\n\n                utils.log(`Decoded: CALL rel32 0x${displacement.toString(16)} (RIP adjusted to 0x${this.rip.toString(16)})`);\n                utils.log(`CALL rel32 - RSP After: 0x${this.rsp.toString(16)}`);\n                return true;\n            }\n\n            // CALL r/m (0xFF /2) - Near, absolute, indirect\n            if (opcode === 0xFF) {\n                const modrm = this.readModRMByte();\n                if (modrm.reg === 2) { // opcode extension /2\n                    let sizeBytes = defaultOperandSize;\n                    const rmOperand = this.resolveModRMOperand(modrm, sizeBytes, rex_x, rex_b, rexPrefix !== 0);\n                    \n                    let tgtAddr;\n                    if (rmOperand.type === 'reg') {\n                        tgtAddr = this.readRegister(rmOperand.name, sizeBytes);\n                    } else {\n                        if (sizeBytes === 1) tgtAddr = BigInt(this.readVirtualUint8(rmOperand.address));\n                        else if (sizeBytes === 2) tgtAddr = BigInt(this.readVirtualUint16(rmOperand.address));\n                        else if (sizeBytes === 4) tgtAddr = BigInt(this.readVirtualUint32(rmOperand.address));\n                        else if (sizeBytes === 8) tgtAddr = this.readVirtualBigUint64(rmOperand.address);\n                        else throw new Error(\"Unsupported memory read size for CALL r/m.\");\n                    }\n                    \n                    const retAddr = this.rip;\n                    utils.log(`CALL r/m - RSP Before: 0x${this.rsp.toString(16)}`);\n                    this.rsp -= 8n;\n                    this.writeVirtualBigUint64(this.rsp, retAddr);\n                    this.rip = tgtAddr;\n\n                    utils.log(`Decoded: CALL ${rmOperand.type === 'reg' ? rmOperand.name.toUpperCase() : `[0x${rmOperand.address.toString(16)}]`} (Indirect, jumping to 0x${this.rip.toString(16)})`);\n                    utils.log(`CALL r/m - RSP After: 0x${this.rsp.toString(16)}`);\n                    return true;\n                }\n            }\n\n            // RET (0xC3) - Near return\n            if (opcode === 0xC3) {\n                utils.log(`RET - RSP Before: 0x${this.rsp.toString(16)}`);\n                const retAddr = this.readVirtualBigUint64(this.rsp);\n                this.rsp += 8n;\n                this.rip = retAddr;\n\n                utils.log(`Decoded: RET (Near, jumping to 0x${this.rip.toString(16)})`);\n                utils.log(`RET - RSP After: 0x${this.rsp.toString(16)}`);\n                return true;\n            }\n\n            // RET imm16 (0xC2) - Near, return with immediate\n            if (opcode === 0xC2) {\n                const imm16 = this.readSignedImmediate(2);\n                utils.log(`RET imm16 - RSP Before: 0x${this.rsp.toString(16)}`);\n                const retAddr = this.readVirtualBigUint64(this.rsp);\n                this.rsp += 8n;\n                this.rip = retAddr;\n                this.rsp += BigInt(imm16);\n\n                utils.log(`Decoded: RET imm16 (jumping to 0x${this.rip.toString(16)}, stack adjust by 0x${imm16.toString(16)})`);\n                utils.log(`RET imm16 - RSP After: 0x${this.rsp.toString(16)}`);\n                return true;\n            }\n\n            // LEA r/m, reg (0x8D)\n            if (opcode === 0x8D) {\n                const modrm = this.readModRMByte();\n                // LEA only works with memory sources, so mod must not be 3\n                if (modrm.mod === 3) {\n                    throw new Error(\"Invalid use of LEA with register source.\");\n                }\n\n                let sizeBytes = defaultOperandSize;\n                // Note: In 64-bit mode, operand size can be 16, 32, or 64.\n                // REX.W=1 -> 64-bit. No REX.W -> 32-bit. 0x66 prefix -> 16-bit.\n\n                const destRegFullIndex = modrm.reg + (rex_r << 3);\n                const destRegName = this.getRegisterString(destRegFullIndex, sizeBytes, rexPrefix !== 0);\n\n                // Here's the magic: we use resolveModRMOperand to get the address\n                const memOperand = this.resolveModRMOperand(modrm, sizeBytes, rex_x, rex_b, rexPrefix !== 0);\n                const effectiveAddress = memOperand.address;\n\n                // ...but we write the address itself to the destination register.\n                this.writeRegister(destRegName, effectiveAddress, sizeBytes);\n\n                utils.log(`Decoded: LEA ${destRegName.toUpperCase()}, [address] (Calculated address: 0x${effectiveAddress.toString(16)})`);\n                return true;\n            }\n\n            // TEST r/m, reg (0x84, 0x85)\n            if (opcode === 0x84 || opcode === 0x85) {\n                const modrm = this.readModRMByte();\n                const wBit = opcode & 0x01;\n                let sizeBytes = (wBit === 0) ? 1 : defaultOperandSize;\n\n                const regOpFullIndex = modrm.reg + (rex_r << 3);\n                const regOpName = this.getRegisterString(regOpFullIndex, sizeBytes, rexPrefix !== 0);\n                const rmOperand = this.resolveModRMOperand(modrm, sizeBytes, rex_x, rex_b, rexPrefix !== 0);\n\n                let val1, val2;\n                val1 = this.readRegister(regOpName, sizeBytes); // Operand from reg field\n\n                if (rmOperand.type === 'reg') {\n                    val2 = this.readRegister(rmOperand.name, sizeBytes);\n                } else { // Memory operand\n                    if (sizeBytes === 1) val2 = BigInt(this.readVirtualUint8(rmOperand.address));\n                    else if (sizeBytes === 2) val2 = BigInt(this.readVirtualUint16(rmOperand.address));\n                    else if (sizeBytes === 4) val2 = BigInt(this.readVirtualUint32(rmOperand.address));\n                    else val2 = this.readVirtualBigUint64(rmOperand.address);\n                }\n\n                const result = val1 & val2;\n\n                // TEST sets flags based on the result but doesn't store it\n                this.flags.cf = 0;\n                this.flags.of = 0;\n                this.flags.zf = (result === 0n) ? 1 : 0;\n                const signBitMask = 1n << (BigInt(sizeBytes * 8) - 1n);\n                this.flags.sf = ((result & signBitMask) !== 0n) ? 1 : 0;\n                // Parity Flag (PF) is also affected, but you can add that later.\n\n                const rmOperandStr = rmOperand.type === 'reg' ? rmOperand.name.toUpperCase() : `[0x${rmOperand.address.toString(16)}]`;\n                utils.log(`Decoded: TEST ${rmOperandStr}, ${regOpName.toUpperCase()}`);\n                return true;\n            }\n\n            // TEST AL, imm8 (0xA8)\n            if (opcode === 0xA8) {\n                const imm8 = this.readSignedImmediate(1);\n                const alValue = this.readRegister('al', 1);\n                const result = alValue & imm8;\n\n                // TEST instruction updates flags but does not store the result.\n                // It performs a bitwise AND and sets flags based on the outcome.\n                this.flags.cf = 0; // Cleared by TEST\n                this.flags.of = 0; // Cleared by TEST\n\n                this.flags.zf = (result === 0n) ? 1 : 0;\n                this.flags.sf = ((result & 0x80n) !== 0n) ? 1 : 0;\n                // Note: Parity Flag (PF) is also affected but not implemented here.\n\n                utils.log(`Decoded: TEST AL, 0x${imm8.toString(16)} (Result for flags: 0x${result.toString(16)})`);\n                return true;\n            }\n\n            // TEST AX/EAX/RAX, imm16/imm32 (0xA9)\n            if (opcode === 0xA9) {\n                let sizeBytes = defaultOperandSize;\n\n                // Determine the size of the immediate value. \n                // For 64-bit operations, the immediate is a 32-bit value.\n                const immediateSizeBytes = (sizeBytes === 8) ? 4 : sizeBytes;\n                const immediateValue = this.readSignedImmediate(immediateSizeBytes);\n                \n                const regName = this.getRegisterString(0, sizeBytes, rexPrefix !== 0); // Accumulator (AX/EAX/RAX)\n                const regValue = this.readRegister(regName, sizeBytes);\n\n                const result = regValue & immediateValue;\n\n                // TEST updates flags and discards the result.\n                this.flags.cf = 0;\n                this.flags.of = 0;\n\n                this.flags.zf = (result === 0n) ? 1 : 0;\n                \n                // Set Sign Flag if the most significant bit of the result is 1.\n                const signBitMask = 1n << (BigInt(sizeBytes * 8) - 1n);\n                this.flags.sf = ((result & signBitMask) !== 0n) ? 1 : 0;\n                // Note: Parity Flag (PF) is also affected but not implemented here.\n\n                utils.log(`Decoded: TEST ${regName.toUpperCase()}, 0x${immediateValue.toString(16)} (Result for flags: 0x${result.toString(16)})`);\n                return true;\n            }\n\n            // Group 2 Immediate Instructions (ROL, ROR, RCL, RCR, SHL, SHR, SAR)\n            if (opcode === 0xC0 || opcode === 0xC1) {\n                const modrm = this.readModRMByte();\n                const wBit = opcode & 0x01;\n                let sizeBytes = (wBit === 0) ? 1 : defaultOperandSize;\n                \n                const rmOperand = this.resolveModRMOperand(modrm, sizeBytes, rex_x, rex_b, rexPrefix !== 0);\n                const shiftCount = this.readSignedImmediate(1); // imm8\n\n                // Read the value to be shifted\n                let value;\n                if (rmOperand.type === 'reg') {\n                    value = this.readRegister(rmOperand.name, sizeBytes);\n                } else {\n                    // Read from memory\n                    if (sizeBytes === 1) value = BigInt(this.readVirtualUint8(rmOperand.address));\n                    else if (sizeBytes === 2) value = BigInt(this.readVirtualUint16(rmOperand.address));\n                    else if (sizeBytes === 4) value = BigInt(this.readVirtualUint32(rmOperand.address));\n                    else value = this.readVirtualBigUint64(rmOperand.address);\n                }\n\n                let result;\n                let mnemonic = \"UNKNOWN_SHIFT\";\n\n                // The 'reg' field of ModR/M acts as an opcode extension here\n                switch (modrm.reg) {\n                    case 4: // SHL\n                        mnemonic = \"SHL\";\n                        result = value << shiftCount;\n                        // TODO: Set CF and OF correctly for SHL\n                        break;\n                    case 5: // SHR\n                        mnemonic = \"SHR\";\n                        result = value >> shiftCount;\n                        // TODO: Set CF and OF correctly for SHR\n                        break;\n                    // Add other shifts like SAR (case 7) here\n                    default:\n                        throw new Error(`Unhandled Group 2 instruction with /reg=${modrm.reg}`);\n                }\n\n                // Update flags (simplified for now)\n                this.flags.zf = (result === 0n) ? 1 : 0;\n                // SF update needs to consider the size\n                const bitWidth = BigInt(sizeBytes * 8);\n                const signBitMask = 1n << (bitWidth - 1n);\n                this.flags.sf = ((result & signBitMask) !== 0n) ? 1 : 0;\n\n                // Write the result back\n                if (rmOperand.type === 'reg') {\n                    this.writeRegister(rmOperand.name, result, sizeBytes);\n                } else {\n                    // Write to memory\n                    if (sizeBytes === 1) this.writeVirtualUint8(rmOperand.address, Number(result));\n                    else if (sizeBytes === 2) this.writeVirtualUint16(rmOperand.address, Number(result));\n                    else if (sizeBytes === 4) this.writeVirtualUint32(rmOperand.address, Number(result));\n                    else this.writeVirtualBigUint64(rmOperand.address, result);\n                }\n\n                const rmOperandStr = rmOperand.type === 'reg' ? rmOperand.name.toUpperCase() : `[0x${rmOperand.address.toString(16)}]`;\n                utils.log(`Decoded: ${mnemonic} ${rmOperandStr}, ${shiftCount}`);\n                return true;\n            }\n\n            // JL rel8 (0x7C)\n            if (opcode === 0x7C) {\n                const displacement = this.readSignedImmediate(1);\n                utils.log(`Decoded: JL rel8 0x${displacement.toString(16)}`);\n                if (this.flags.sf !== this.flags.of) { // Condition for JL\n                    this.rip += displacement;\n                    utils.log(`  Condition Met (SF!=OF). Jumping to 0x${this.rip.toString(16)}`);\n                } else {\n                    utils.log(`  Condition Not Met. Not jumping.`);\n                }\n                return true;\n            }\n\n            // JB rel8 (0x72)\n            if (opcode === 0x72) {\n                const displacement = this.readSignedImmediate(1);\n                utils.log(`Decoded: JB rel8 0x${displacement.toString(16)}`);\n                if (this.flags.cf !== 0) { // Condition for JB\n                    this.rip += displacement;\n                    utils.log(`  Condition Met (CF!=0). Jumping to 0x${this.rip.toString(16)}`);\n                } else {\n                    utils.log(`  Condition Not Met. Not jumping.`);\n                }\n                return true;\n            }\n\n            // JMP rel8 (0xEB)\n            if (opcode === 0xEB) {\n                // Read the 8-bit signed relative displacement\n                const displacement = this.readSignedImmediate(1);\n                \n                // Add the displacement to the current RIP to perform the jump\n                this.rip += displacement;\n                \n                utils.log(`Decoded: JMP rel8 0x${displacement.toString(16)} (Jumping to 0x${this.rip.toString(16)})`);\n                return true;\n            }\n\n            // IRETQ (0xCF)\n            if (opcode === 0xCF) {\n                // Pop the interrupt number we pushed\n                const interruptNumber = Number(this.readVirtualBigUint64(this.rsp));\n                this.rsp += 8n;\n\n                // Page Faults (#8, #10-14, #17) push an error code.\n                const hasErrorCode = [8, 10, 11, 12, 13, 14, 17].includes(interruptNumber);\n                if (hasErrorCode) {\n                    this.rsp += 8n; // Discard the error code\n                }\n\n                // Now pop the standard frame\n                this.rip = this.readVirtualBigUint64(this.rsp);\n                this.rsp += 8n;\n                \n                const new_cs = this.readVirtualBigUint64(this.rsp);\n                this.rsp += 8n;\n                \n                const new_rflags = this.readVirtualBigUint64(this.rsp);\n                this.disassembleRFlags(new_rflags);\n                this.rsp += 8n;\n                \n                utils.log(`Decoded: IRETQ from INT #${interruptNumber} (Returning to 0x${this.rip.toString(16)})`);\n                return true;\n            }\n\n            // OUT DX, AL (0xEE)\n            if (opcode === 0xEE) {\n                // The port number is read from the 16-bit DX register\n                const port = this.readRegister('dx', 2);\n                const value = this.readRegister('al', 1);\n                \n                this.io.portOut(Number(port), Number(value), 1); // size is 1 byte\n                \n                utils.log(`Decoded: OUT DX, AL (Wrote 0x${value.toString(16)} to port 0x${port.toString(16)})`);\n                return true;\n            }\n\n            // OUT imm8, AL (0xE6)\n            if (opcode === 0xE6) {\n                const port = this.readInstructionByte(); // Read the port number from the instruction\n                const value = this.readRegister('al', 1); // Get the value from the AL register\n                \n                this.io.portOut(port, Number(value), 1); // Send the data to the I/O bus\n\n                utils.log(`Decoded: OUT imm8, AL (Wrote 0x${value.toString(16)} to port 0x${port.toString(16)})`);\n                return true;\n            }\n\n            // LODSB (0xAC)\n            if (opcode === 0xAC) {\n                // 1. Read the byte from memory at [RSI]\n                const value = this.readVirtualUint8(this.rsi);\n                \n                // 2. Put that byte into AL\n                this.writeRegister('al', value, 1);\n                \n                // 3. Increment RSI by 1\n                // (Note: A full implementation would check the Direction Flag (DF),\n                // but the default is to increment, which is all we need here).\n                this.rsi += 1n;\n    \n                utils.log(`Decoded: LODSB (Loaded 0x${value.toString(16)} into AL, RSI is now 0x${this.rsi.toString(16)})`);\n                return true;\n            }\n\n            // IN AL, imm8 (0xE4)\n            if (opcode === 0xE4) {\n                const port = this.readInstructionByte(); // Read 8-bit port from instruction\n                const value = this.io.portIn(port, 1);   // Read 1 byte from the I/O bus\n                this.writeRegister('al', value, 1);      // Write the value to AL\n\n                utils.log(`Decoded: IN AL, imm8 (Read 0x${value.toString(16)} from port 0x${port.toString(16)} into AL)`);\n                return true;\n            }\n\n            // IN AL, DX (0xEC)\n            if (opcode === 0xEC) {\n                const port = this.readRegister('dx', 2);   // Read 16-bit port from DX\n                const value = this.io.portIn(Number(port), 1); // Read 1 byte from the I/O bus\n                this.writeRegister('al', value, 1);        // Write the value to AL\n\n                utils.log(`Decoded: IN AL, DX (Read 0x${value.toString(16)} from port 0x${port.toString(16)} into AL)`);\n                return true;\n            }\n\n            // INC r/m (0xFE /0 for byte, 0xFF /0 for word/dword/qword)\n            if (opcode === 0xFE || opcode === 0xFF) {\n                const modrm = this.readModRMByte();\n                \n                // This instruction is selected when the /reg field of the ModR/M byte is 0.\n                if (modrm.reg === 0) {\n                    const wBit = opcode & 0x01;\n                    // Opcode 0xFE is always 1 byte.\n                    // Opcode 0xFF uses defaultOperandSize (word, dword, or qword).\n                    let sizeBytes = (wBit === 0) ? 1 : defaultOperandSize;\n\n                    const rmOperand = this.resolveModRMOperand(modrm, sizeBytes, rex_r, rex_b, rex_x, rexPrefix !== 0);\n                    \n                    let value;\n                    // Read the current value from the register or memory\n                    if (rmOperand.type === 'reg') {\n                        value = this.readRegister(rmOperand.name, sizeBytes);\n                    } else {\n                        if (sizeBytes === 1) value = BigInt(this.readVirtualUint8(rmOperand.address));\n                        else if (sizeBytes === 2) value = BigInt(this.readVirtualUint16(rmOperand.address));\n                        else if (sizeBytes === 4) value = BigInt(this.readVirtualUint32(rmOperand.address));\n                        else value = this.readVirtualBigUint64(rmOperand.address);\n                    }\n\n                    const result = value + 1n;\n\n                    // --- Correct Flag Calculation for INC ---\n                    // IMPORTANT: INC does NOT affect the Carry Flag (CF).\n                    // It affects OF, SF, ZF, AF, PF.\n                    const originalCF = this.flags.cf; // Preserve the original Carry Flag\n\n                    // We can use our existing function, but for a fake 'add' of 1\n                    this.updateArithmeticFlags(result, value, 1n, sizeBytes, 'add');\n\n                    this.flags.cf = originalCF; // Restore the Carry Flag\n                    // --- End Flag Calculation ---\n                    \n                    // Write the result back\n                    if (rmOperand.type === 'reg') {\n                        this.writeRegister(rmOperand.name, result, sizeBytes);\n                    } else {\n                        if (sizeBytes === 1) this.writeVirtualUint8(rmOperand.address, Number(result));\n                        else if (sizeBytes === 2) this.writeVirtualUint16(rmOperand.address, Number(result));\n                        else if (sizeBytes === 4) this.writeVirtualUint32(rmOperand.address, Number(result));\n                        else this.writeVirtualBigUint64(rmOperand.address, result);\n                    }\n                    \n                    const operandStr = rmOperand.type === 'reg' ? rmOperand.name.toUpperCase() : `[0x${rmOperand.address.toString(16)}]`;\n                    utils.log(`Decoded: INC ${operandStr}`);\n                    return true;\n                }\n            }\n\n            // STI (Set Interrupt Flag)\n            if (opcode === 0xFB) {\n                this.flags.if = 1;\n                utils.log(\"Decoded: STI\");\n                return true;\n            }\n\n            // CLI (Clear Interrupt Flag)\n            if (opcode === 0xFA) {\n                this.flags.if = 0;\n                utils.log(\"Decoded: CLI\");\n                return true;\n            }\n\n            // JMP ptr16:16 (Far Jump) - Opcode 0xEA\n            if (opcode === 0xEA) {\n                // This instruction is special. In the 16-bit boot stub, the assembler\n                // always generates a 16-bit offset and a 16-bit selector.\n                // We will hardcode the handler to read these sizes to match the\n                // machine code, ignoring defaultOperandSize for this specific opcode.\n                \n                // We must use physical reads because paging is not yet effective\n                // for the instruction stream itself.\n                const offset = this.memory.readUint16(Number(this.rip));\n                this.rip += 2n;\n\n                const new_cs = this.memory.readUint16(Number(this.rip));\n                this.rip += 2n;\n\n                // Set the new segment and instruction pointer\n                this.cs = BigInt(new_cs);\n                this.rip = BigInt(offset);\n                \n                // Re-evaluating the CPU mode here is good practice after loading CS.\n                this.updateCPUMode();\n                \n                utils.log(`Decoded: JMP far 0x${new_cs.toString(16)}:0x${offset.toString(16)}`);\n                return true;\n            }\n\n            // If an instruction falls through all specific handlers, it's truly unknown\n            utils.log(`Unknown opcode: 0x${(twoByteOpcode ? '0F ' : '')}${opcode.toString(16)} at 0x${currentRIPBeforeFetch.toString(16)}`); // Use currentRIPBeforeFetch for unknown opcodes\n            return false;\n        } catch (e) {\n            if (e instanceof PageFaultException) {\n                console.warn(`--- Caught Page Fault at RIP 0x${currentRIPBeforeFetch.toString(16)}. Invoking handler. ---`);\n                this.rip = currentRIPBeforeFetch; // IMPORTANT: Restore RIP to the address of the *faulting* instruction\n                this.triggerInterrupt(14, e.errorCode);\n            } else {\n                console.error(`Fatal error during execution at RIP 0x${currentRIPBeforeFetch.toString(16)}:`, e);\n                throw e;\n            }\n        }\n        return true;\n    }\n\n    readInstructionByte() {\n        let byte;\n        // Instruction fetches (RIP-relative access) depend on current mode and paging state\n        // If Protected Mode (CR0.PE) is enabled, all accesses are virtual from instruction stream's perspective.\n        // The translateVirtualToPhysical will handle the specific paging checks (PG, PAE, LME).\n        if ((this.cr0 & CPU.CR0_PE) !== 0n) { \n            byte = this.readVirtualUint8(this.rip);\n        } else { // Real Mode\n            byte = this.memory.readUint8(Number(this.rip));\n        }\n        this.rip++;\n        return byte;\n    }\n\n    readInstructionUint16() {\n        const lo = this.readInstructionByte();\n        const hi = this.readInstructionByte();\n        return (hi << 8) | lo;\n    }\n\n    readInstructionUint32() {\n        const b1 = this.readInstructionByte();\n        const b2 = this.readInstructionByte();\n        const b3 = this.readInstructionByte();\n        const b4 = this.readInstructionByte();\n        return (b4 << 24) | (b3 << 16) | (b2 << 8) | b1;\n    }\n\n    readModRMByte() {\n        // ModR/M byte is also part of the instruction stream, so it should use readInstructionByte logic\n        // This ensures it correctly reads from virtual or physical memory.\n        const modrm = this.readInstructionByte(); \n        const mod = (modrm >>> 6) & 0x03;\n        const reg = (modrm >>> 3) & 0x07;\n        const rm = modrm & 0x07;\n        return { mod, reg, rm, raw: modrm };\n    }\n\n    getRegisterString(regIndex, sizeBytes, hasRexPrefix = false) {\n        const regNames64 = ['rax', 'rcx', 'rdx', 'rbx', 'rsp', 'rbp', 'rsi', 'rdi', 'r8', 'r9', 'r10', 'r11', 'r12', 'r13', 'r14', 'r15'];\n        const regNames32 = ['eax', 'ecx', 'edx', 'ebx', 'esp', 'ebp', 'esi', 'edi', 'r8d', 'r9d', 'r10d', 'r11d', 'r12d', 'r13d', 'r14d', 'r15d'];\n        const regNames16 = ['ax', 'cx', 'dx', 'bx', 'sp', 'bp', 'si', 'di', 'r8w', 'r9w', 'r10w', 'r11w', 'r12w', 'r13w', 'r14w', 'r15w'];\n        \n        // Arrays for 8-bit register naming based on REX prefix presence\n        const regNames8Low = ['al', 'cl', 'dl', 'bl']; // Indices 0-3 (always same)\n        const regNames8HighNoRex = ['ah', 'ch', 'dh', 'bh']; // Indices 4-7 (if NO REX prefix)\n        const regNames8NewRex = ['spl', 'bpl', 'sil', 'dil']; // Indices 4-7 (if REX prefix IS present)\n        const regNames8Extended = ['r8b', 'r9b', 'r10b', 'r11b', 'r12b', 'r13b', 'r14b', 'r15b']; // Indices 8-15 (always used with REX)\n\n        if (regIndex < 0 || regIndex > 15) {\n            throw new Error(`Invalid register index: ${regIndex}`);\n        }\n\n        switch (sizeBytes) {\n            case 1:\n                if (regIndex >= 8) { // Registers R8B-R15B (always require REX to be accessed by these names)\n                    return regNames8Extended[regIndex - 8];\n                } else if (regIndex >= 4) { // Registers AX/CX/DX/BX's high byte or SPL/BPL/SIL/DIL\n                    if (hasRexPrefix) {\n                        return regNames8NewRex[regIndex - 4];\n                    } else {\n                        return regNames8HighNoRex[regIndex - 4];\n                    }\n                } else { // Registers AL/CL/DL/BL\n                    return regNames8Low[regIndex];\n                }\n            case 2: return regNames16[regIndex];\n            case 4: return regNames32[regIndex];\n            case 8: return regNames64[regIndex];\n            default: throw new Error(`Invalid register size for naming: ${sizeBytes}`);\n        }\n    }\n\n    readSignedImmediate(sizeBytes) {\n        let rawValue;\n        if (sizeBytes === 1) {\n            rawValue = this.readInstructionByte();\n            if (rawValue & 0x80) return BigInt(rawValue - 0x100);\n            return BigInt(rawValue);\n        }\n        if (sizeBytes === 2) {\n            rawValue = this.readInstructionUint16();\n            if (rawValue & 0x8000) return BigInt(rawValue - 0x10000);\n            return BigInt(rawValue);\n        }\n        if (sizeBytes === 4) {\n            rawValue = this.readInstructionUint32();\n            if (rawValue & 0x80000000) return BigInt(rawValue - 0x100000000);\n            return BigInt(rawValue);\n        }\n        // For 64-bit, we need a 64-bit reader\n        const lo = this.readInstructionUint32();\n        const hi = this.readInstructionUint32();\n        return (BigInt(hi) << 32n) | BigInt(lo);\n    }\n\n    readSIBByte(mod) {\n        const sib = this.readInstructionByte();\n        const scaleBits = (sib >>> 6) & 0x03;\n        const indexBits = (sib >>> 3) & 0x07;\n        const baseBits = sib & 0x07;\n\n        // Scale is either 1, 2, 4, or 8\n        const scale = 1 << scaleBits;\n\n        const idxRegName = this.getRegisterString(indexBits, 8, false);\n        const baseRegName = this.getRegisterString(baseBits, 8, false);\n\n        let baseValue = 0n;\n\n        // Special case: if base is RBP/EBP and mod is 00, there is no base register\n        if (!(baseBits === 5 && mod === 0)) {\n            baseValue = this.readRegister(baseRegName, 8);\n        }\n\n        let indexValue = 0n;\n       // Special case: if index is RSP, there is no index register\n        if (indexBits !== 4) {\n            indexValue = this.readRegister(idxRegName, 8);\n        }\n\n        const addr = baseValue + (indexValue * BigInt(scale));\n        utils.log(`  SIB Decoded: Base=${baseRegName}, Index=${idxRegName}, Scale=${scale} => Address component = 0x${addr.toString(16)}`);\n        return addr;\n    }\n\n    resolveModRMOperand(modrm, sizeBytes, rex_x, rex_b, hasRexPrefixForNaming) {\n        if (modrm.mod === 0x03) {\n            const rmIndex = modrm.rm + (rex_b << 3);\n            return { type: 'reg', name: this.getRegisterString(rmIndex, sizeBytes, hasRexPrefixForNaming) };\n        }\n\n        let effectiveAddress = 0n;\n        let displacement = 0n;\n        const sibPresent = (modrm.rm === 0x04);\n\n        // --- Step 1: Calculate Base + Index*Scale ---\n        if (sibPresent) {\n            const sib = this.readInstructionByte();\n            const scale = 1 << ((sib >>> 6) & 0x03);\n            const indexBits = ((sib >>> 3) & 0x07) + (rex_x << 3);\n            const baseBits = (sib & 0x07) + (rex_b << 3);\n\n            // Add Index * Scale (if index is not RSP)\n            if (indexBits !== 4) {\n                const indexRegName = this.getRegisterString(indexBits, 8, true);\n                effectiveAddress += this.readRegister(indexRegName, 8) * BigInt(scale);\n            }\n\n            // Add Base register. The special disp32-only case is handled below.\n            if (modrm.mod !== 0x00 || baseBits !== 5) {\n                const baseRegName = this.getRegisterString(baseBits, 8, true);\n                effectiveAddress += this.readRegister(baseRegName, 8);\n            }\n\n        } else if (modrm.rm === 0x05) {\n            // RIP-relative addressing is a disp32 added to the *next* RIP\n            effectiveAddress = this.rip; // Base for calculation is the RIP after this instruction\n        } else {\n            // Simple [reg] base\n            const baseRegIndex = modrm.rm + (rex_b << 3);\n            const baseRegName = this.getRegisterString(baseRegIndex, 8, true);\n            effectiveAddress = this.readRegister(baseRegName, 8);\n        }\n\n        // --- Step 2: Add Displacement based on ModR/M.mod ---\n        if (modrm.mod === 0x01) {\n            displacement = this.readSignedImmediate(1); // disp8\n            effectiveAddress += displacement;\n        } else if (modrm.mod === 0x02) {\n            displacement = this.readSignedImmediate(4); // disp32\n            effectiveAddress += displacement;\n        } else if (modrm.mod === 0x00) {\n            // THIS IS THE CRITICAL FIX\n            // Check for disp32 cases that exist even when mod is 00.\n            // Case 1: [RIP + disp32] (ModR/M.r/m = 5)\n            // Case 2: [SIB + disp32] (SIB.base = 5)\n            const sibBaseIsRBP = sibPresent && ((this.memory.readUint8(Number(this.rip - 1n)) & 0x07) === 5);\n            if ((!sibPresent && modrm.rm === 5) || sibBaseIsRBP) {\n                displacement = this.readSignedImmediate(4);\n                effectiveAddress += displacement;\n            }\n        }\n\n        return { type: 'mem', address: effectiveAddress, sizeBytes: sizeBytes };\n    }\n\n    updateCPUMode() {\n        const peBit = (this.cr0 & CPU.CR0_PE) !== 0n;       \n        const pgBit = (this.cr0 & CPU.CR0_PG) !== 0n; \n        const paeBit = (this.cr4 & CPU.CR4_PAE) !== 0n; \n        const lmeBit = (this.efer & CPU.EFER_LME) !== 0n; \n\n        // --- NEW DEBUGGING LOGS ---\n        utils.log(`\\n--- DEBUG: updateCPUMode called ---`);\n        utils.log(`  Current CR0:  0x${this.cr0.toString(16).padStart(16, '0')} (PE: ${peBit}, PG: ${pgBit})`);\n        utils.log(`  Current CR4:  0x${this.cr4.toString(16).padStart(16, '0')} (PAE: ${paeBit})`);\n        utils.log(`  Current EFER: 0x${this.efer.toString(16).padStart(16, '0')} (LME: ${lmeBit})`);\n        utils.log(`  Combined Condition (LME && PAE && PG): ${lmeBit && paeBit && pgBit}`);\n        // --- END DEBUGGING LOGS ---\n    \n        if (!peBit) {\n            this.mode = 'real';\n        } else { \n            if (lmeBit && paeBit && pgBit) { \n                this.mode = 'long';\n                utils.log(\"CPU Mode: Long Mode (64-bit) enabled.\");\n            } else if (pgBit && paeBit) { \n                this.mode = 'protected_pae'; \n                utils.log(\"CPU Mode: Protected Mode (32-bit) with PAE enabled.\");\n            } else if (pgBit) {\n                this.mode = 'protected_32bit_paging'; \n                utils.log(\"CPU Mode: Protected Mode (32-bit) with Paging enabled.\");\n            } else {\n                this.mode = 'protected'; \n                utils.log(\"CPU Mode: Protected Mode (32-bit) enabled (no paging).\");\n            }\n        }\n        utils.log(`DEBUG: updateCPUMode - Mode finalized as: ${this.mode}\\n`);\n    }\n\n    readVirtualUint8(virtualAddr) {\n        const physicalAddr = this.translateVirtualToPhysical(virtualAddr, 1, 'read');\n        // Add bounds check for physical memory to catch issues *before* DataView throws\n        if (physicalAddr < 0n || physicalAddr >= BigInt(this.memory.buffer.byteLength)) {\n            console.error(`Attempt to read physical address 0x${physicalAddr.toString(16)} outside memory bounds (0x0 to 0x${BigInt(this.memory.buffer.byteLength).toString(16)}).`);\n            throw new Error(`MEMORY_ACCESS_VIOLATION: Read from physical address 0x${physicalAddr.toString(16)}`);\n        }\n        return this.memory.readUint8(Number(physicalAddr));\n    }\n\n    writeVirtualUint8(virtualAddr, value) {\n        const physicalAddr = this.translateVirtualToPhysical(virtualAddr, 1, 'write');\n        if (physicalAddr < 0n || physicalAddr >= BigInt(this.memory.buffer.byteLength)) {\n            console.error(`Attempt to write physical address 0x${physicalAddr.toString(16)} outside memory bounds (0x0 to 0x${BigInt(this.memory.buffer.byteLength).toString(16)}).`);\n            throw new Error(`MEMORY_ACCESS_VIOLATION: Write to physical address 0x${physicalAddr.toString(16)}`);\n        }\n        this.memory.writeUint8(Number(physicalAddr), value);\n    }\n\n    readVirtualUint16(virtualAddr) {\n        const physicalAddr = this.translateVirtualToPhysical(virtualAddr, 2, 'read');\n        if (physicalAddr < 0n || physicalAddr + 1n >= BigInt(this.memory.buffer.byteLength)) { // +1n for 2-byte read\n            console.error(`Attempt to read physical address 0x${physicalAddr.toString(16)} outside memory bounds.`);\n            throw new Error(`MEMORY_ACCESS_VIOLATION: Read from physical address 0x${physicalAddr.toString(16)}`);\n        }\n        return this.memory.readUint16(Number(physicalAddr));\n    }\n\n    writeVirtualUint16(virtualAddr, value) {\n        const physicalAddr = this.translateVirtualToPhysical(virtualAddr, 2, 'write');\n        if (physicalAddr < 0n || physicalAddr + 1n >= BigInt(this.memory.buffer.byteLength)) { // +1n for 2-byte write\n            console.error(`Attempt to write physical address 0x${physicalAddr.toString(16)} outside memory bounds.`);\n            throw new Error(`MEMORY_ACCESS_VIOLATION: Write to physical address 0x${physicalAddr.toString(16)}`);\n        }\n        this.memory.writeUint16(Number(physicalAddr), value);\n    }\n\n    readVirtualUint32(virtualAddr) {\n        const physicalAddr = this.translateVirtualToPhysical(virtualAddr, 4, 'read');\n        if (physicalAddr < 0n || physicalAddr + 3n >= BigInt(this.memory.buffer.byteLength)) { // +3n for 4-byte read\n            console.error(`Attempt to read physical address 0x${physicalAddr.toString(16)} outside memory bounds.`);\n            throw new Error(`MEMORY_ACCESS_VIOLATION: Read from physical address 0x${physicalAddr.toString(16)}`);\n        }\n        return this.memory.readUint32(Number(physicalAddr));\n    }\n\n    writeVirtualUint32(virtualAddr, value) {\n        const physicalAddr = this.translateVirtualToPhysical(virtualAddr, 4, 'write');\n        if (physicalAddr < 0n || physicalAddr + 3n >= BigInt(this.memory.buffer.byteLength)) { // +3n for 4-byte write\n            console.error(`Attempt to write physical address 0x${physicalAddr.toString(16)} outside memory bounds.`);\n            throw new Error(`MEMORY_ACCESS_VIOLATION: Write to physical address 0x${physicalAddr.toString(16)}`);\n        }\n        this.memory.writeUint32(Number(physicalAddr), value);\n    }\n\n    readVirtualBigUint64(virtualAddr) {\n        const physicalAddr = this.translateVirtualToPhysical(virtualAddr, 8, 'read');\n        if (physicalAddr < 0n || physicalAddr + 7n >= BigInt(this.memory.buffer.byteLength)) { // +7n for 8-byte read\n            console.error(`Attempt to read physical address 0x${physicalAddr.toString(16)} outside memory bounds.`);\n            throw new Error(`MEMORY_ACCESS_VIOLATION: Read from physical address 0x${physicalAddr.toString(16)}`);\n        }\n        return this.memory.readBigUint64(Number(physicalAddr)); \n    }\n\n    writeVirtualBigUint64(virtualAddr, value) {\n        const physicalAddr = this.translateVirtualToPhysical(virtualAddr, 8, 'write');\n        if (physicalAddr < 0n || physicalAddr + 7n >= BigInt(this.memory.buffer.byteLength)) { // +7n for 8-byte write\n            console.error(`Attempt to write physical address 0x${physicalAddr.toString(16)} outside memory bounds.`);\n            throw new Error(`MEMORY_ACCESS_VIOLATION: Write to physical address 0x${physicalAddr.toString(16)}`);\n        }\n        this.memory.writeBigUint64(Number(physicalAddr), value); \n    }\n\n    translateVirtualToPhysical(virtualAddr, sizeBytes, accessType) {\n        if (this.mode === 'real') {\n            return virtualAddr;\n        }\n\n        const pgBit = (this.cr0 & CPU.CR0_PG) !== 0n;\n        const paeBit = (this.cr4 & CPU.CR4_PAE) !== 0n;\n        const lmeBit = (this.efer & CPU.EFER_LME) !== 0n;\n\n        // This guard determines when the full 4-level paging logic is active.\n        if (this.mode !== 'long' || !pgBit || !paeBit || !lmeBit) {\n            console.warn(`Paging not fully enabled for Long Mode. Current mode: ${this.mode}. CR0.PG=${pgBit}, CR4.PAE=${paeBit}, EFER.LME=${lmeBit}. Returning virtual as physical.`);\n            return virtualAddr; // Pass through if paging is not fully active\n        }\n\n        // --- Paging Enabled for Long Mode (the real work begins here) ---\n        utils.log(`Paging: Translating virtual address 0x${virtualAddr.toString(16)} in ${this.mode} mode.`);\n\n        const pml4BasePhys = this.cr3 & ~0xFFFn;\n        utils.log(`  PML4 Base Phys: 0x${pml4BasePhys.toString(16).padStart(16, '0')}`); \n\n        const pml4Index = (virtualAddr >> 39n) & 0x1FFn; \n        let pml4eAddr = pml4BasePhys + (pml4Index * 8n); \n        utils.log(`  PML4E Addr: 0x${pml4eAddr.toString(16).padStart(16, '0')} (Index: ${pml4Index})`);\n        let pml4e = this.memory.readBigUint64(Number(pml4eAddr));\n        utils.log(`  PML4E Value: 0x${pml4e.toString(16).padStart(16, '0')}`);\n\n        if ((pml4e & CPU.PTE_PRESENT) === 0n) {\n            console.error(`Page Fault (#PF): PML4E not present for VA 0x${virtualAddr.toString(16)}`);\n            throw new PageFaultException(`PML4E not present`, 0n);\n        }        \n\n        let pdptBasePhys = pml4e & ~0xFFFn;\n        utils.log(`  PDPT Base Phys: 0x${pdptBasePhys.toString(16).padStart(16, '0')}`); \n        const pdptIndex = (virtualAddr >> 30n) & 0x1FFn; \n        let pdpteAddr = pdptBasePhys + (pdptIndex * 8n); \n        utils.log(`  PDPTE Addr: 0x${pdpteAddr.toString(16).padStart(16, '0')} (Index: ${pdptIndex})`);\n        let pdpte = this.memory.readBigUint64(Number(pdpteAddr));\n        utils.log(`  PDPTE Value: 0x${pdpte.toString(16).padStart(16, '0')}`);\n\n        if ((pdpte & CPU.PTE_PRESENT) === 0n) {\n            console.error(`Page Fault (#PF): PDPTE not present for VA 0x${virtualAddr.toString(16)}`);\n            throw new PageFaultException(`PDPTE not present`, 0n);\n        }\n\n        if ((pdpte & CPU.PTE_PAGE_SIZE) !== 0n) { // 1GB page\n            const pageBaseAddr = pdpte & 0xFFFFFFFC0000000n; \n            const offset = virtualAddr & 0x3FFFFFFFfn; \n            const physical = pageBaseAddr | offset;\n            utils.log(`  Translated 1GB page: VA 0x${virtualAddr.toString(16)} -> PA 0x${physical.toString(16)}`);\n            return physical;\n        }\n\n        let pdBasePhys = pdpte & ~0xFFFn;\n        utils.log(`  PD Base Phys: 0x${pdBasePhys.toString(16).padStart(16, '0')}`); \n        const pdIndex = (virtualAddr >> 21n) & 0x1FFn; \n        let pdeAddr = pdBasePhys + (pdIndex * 8n); \n        utils.log(`  PDE Addr: 0x${pdeAddr.toString(16).padStart(16, '0')} (Index: ${pdIndex})`);\n        let pde = this.memory.readBigUint64(Number(pdeAddr));\n        utils.log(`  PDE Value: 0x${pde.toString(16).padStart(16, '0')}`);\n\n        if ((pde & CPU.PTE_PRESENT) === 0n) {\n            console.error(`Page Fault (#PF): PDE not present for VA 0x${virtualAddr.toString(16)}`);\n            throw new PageFaultException(`PDE not present`, 0n);\n        }\n\n        if ((pde & CPU.PTE_PAGE_SIZE) !== 0n) { // 2MB page\n            const pageBaseAddr = pde & 0xFFFFFFFE00000n; \n            const offset = virtualAddr & 0x1FFFFFn; \n            const physical = pageBaseAddr | offset;\n            utils.log(`  Translated 2MB page: VA 0x${virtualAddr.toString(16)} -> PA 0x${physical.toString(16)}`);\n            return physical;\n        }\n\n        let ptBasePhys = pde & ~0xFFFn;\n        utils.log(`  PT Base Phys: 0x${ptBasePhys.toString(16).padStart(16, '0')}`); \n        const ptIndex = (virtualAddr >> 12n) & 0x1FFn; \n        let pteAddr = ptBasePhys + (ptIndex * 8n); \n        utils.log(`  PTE Addr: 0x${pteAddr.toString(16).padStart(16, '0')} (Index: ${ptIndex})`);\n        let pte = this.memory.readBigUint64(Number(pteAddr));\n        utils.log(`  PTE Value: 0x${pte.toString(16).padStart(16, '0')}`);\n\n        if ((pte & CPU.PTE_PRESENT) === 0n) {\n            console.error(`Page Fault (#PF): PTE not present for VA 0x${virtualAddr.toString(16)}`);\n            throw new PageFaultException(`PTE not present`, 0n);\n        }\n\n        if (accessType === 'write' && (pte & CPU.PTE_READ_WRITE) === 0n) {\n            // The page is present but read-only. This is a page fault.\n            // The error code for a protection violation has bit 0 set.\n            throw new PageFaultException(`Protection Violation on write to VA 0x${virtualAddr.toString(16)}`, 1n);\n        }\n\n        const pageBaseAddr = pte & ~0xFFFn; \n        const offset = virtualAddr & 0xFFFn; \n        const physical = pageBaseAddr | offset;\n        utils.log(`  Final Page Base Addr: 0x${pageBaseAddr.toString(16).padStart(16, '0')}`);\n        utils.log(`  Page Offset: 0x${offset.toString(16).padStart(3, '0')}`);\n        utils.log(`  Calculated Physical: 0x${physical.toString(16).padStart(16, '0')}`);\n\n        return physical;\n    }\n\n    triggerInterrupt(interruptNumber, errorCode = null) {\n        utils.log(`--- INTERRUPT TRIGGERED: #${interruptNumber} ---`);\n\n        const descriptorAddr = this.idtr.base + BigInt(interruptNumber * 16);\n\n        console.log(`  IDTR.base = 0x${this.idtr.base.toString(16)}`);\n        console.log(`  Interrupt #${interruptNumber} @ 0x${descriptorAddr.toString(16)}`);\n        console.log(`  Raw bytes: ${[...new Uint8Array(this.memory.buffer.slice(Number(descriptorAddr), Number(descriptorAddr + 16n)))]\n            .map(b => b.toString(16).padStart(2, '0')).join(' ')}`);\n\n        const lowSlice = this.readVirtualBigUint64(descriptorAddr);\n        const highSlice = this.readVirtualBigUint64(descriptorAddr + 8n);\n        utils.log(`DEBUG: Descriptor at 0x${descriptorAddr.toString(16)} is: LOW=0x${lowSlice.toString(16)} HIGH=0x${highSlice.toString(16)}`);\n\n        // === FINAL, CORRECTED PARSING LOGIC v3 ===\n        // This logic correctly decodes the structure created by the assembly code.\n        const offset_15_0  = lowSlice & 0xFFFFn;\n        const offset_31_16 = (lowSlice >> 48n) & 0xFFFFn;\n        const offset_63_32 = highSlice & 0xFFFFFFFFn;\n\n        const handlerAddr = (offset_63_32 << 32n) | (offset_31_16 << 16n) | offset_15_0;\n        // ===========================================\n\n        const segmentSelector = (lowSlice >> 16n) & 0xFFFFn;\n        const type_attrs = (lowSlice >> 40n) & 0xFFn;\n        const present = (type_attrs & 0x80n) !== 0n;\n\n        if (!present) {\n            throw new Error(`Interrupt Handler #${interruptNumber} not present! Double Fault.`);\n        }\n\n        // Push state onto the stack\n        this.rsp -= 8n;\n        this.writeVirtualBigUint64(this.rsp, this.assembleRFlags());\n        this.rsp -= 8n;\n        this.writeVirtualBigUint64(this.rsp, segmentSelector);\n        this.rsp -= 8n;\n        this.writeVirtualBigUint64(this.rsp, this.rip);\n        if (errorCode !== null) {\n            this.rsp -= 8n;\n            this.writeVirtualBigUint64(this.rsp, errorCode);\n        }\n        this.rsp -= 8n;\n        this.writeVirtualBigUint64(this.rsp, BigInt(interruptNumber));\n\n        console.log(`DEBUG: Parsed handlerAddr = 0x${handlerAddr.toString(16)}`);\n        console.log(`  offset_15_0  = 0x${offset_15_0.toString(16)}`);\n        console.log(`  offset_31_16 = 0x${offset_31_16.toString(16)}`);\n        console.log(`  offset_63_32 = 0x${offset_63_32.toString(16)}`);\n\n        // Jump to the handler\n        this.rip = handlerAddr;\n        \n        utils.log(`  Jumping to handler at 0x${handlerAddr.toString(16)}`);\n    }\n\n    assembleRFlags() {\n        let flags = 0n;\n        if (this.flags.cf) flags |= (1n << CPU.FLAG_CF_BIT);\n        if (this.flags.zf) flags |= (1n << CPU.FLAG_ZF_BIT);\n        if (this.flags.sf) flags |= (1n << CPU.FLAG_SF_BIT);\n        if (this.flags.of) flags |= (1n << CPU.FLAG_OF_BIT);\n        if (this.flags.if) flags |= (1n << CPU.FLAG_IF_BIT);\n        // Always set bit 1 to 1, as per specification\n        flags |= (1n << 1n);\n        return flags;\n    }\n\n    disassembleRFlags(rflagsValue) {\n        this.flags.cf = ((rflagsValue >> CPU.FLAG_CF_BIT) & 1n) === 1n ? 1 : 0;\n        this.flags.zf = ((rflagsValue >> CPU.FLAG_ZF_BIT) & 1n) === 1n ? 1 : 0;\n        this.flags.sf = ((rflagsValue >> CPU.FLAG_SF_BIT) & 1n) === 1n ? 1 : 0;\n        this.flags.of = ((rflagsValue >> CPU.FLAG_OF_BIT) & 1n) === 1n ? 1 : 0;\n        this.flags.if = ((rflagsValue >> CPU.FLAG_IF_BIT) & 1n) === 1n ? 1 : 0;\n    }\n\n    raiseInterrupt(interruptNumber) {\n        // In a real system, this would go through an Interrupt Controller (PIC).\n        // For now, we'll just queue it. We need a queue in case an interrupt\n        // happens while the CPU has interrupts disabled.\n        this.interruptQueue.push(interruptNumber);\n    }\n}"],"names":["utils.log"],"mappings":"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"}