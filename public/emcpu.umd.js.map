{"version":3,"file":"emcpu.umd.js","sources":["../cpu/utils.js","../cpu/memory.js","../cpu/io.js","../cpu/cpu.js"],"sourcesContent":["const _console = console;\n\nlet mode = \"prod\";\n\nexport function getMode() {\n    return mode;\n}\n\nexport function setMode(m) {\n    if (m !== \"dev\" && m !== \"prod\") throw new Error(\"Invalid mode\");\n    mode = m;\n}\n\nexport function log(...args) {\n    if (mode === \"dev\") _console.log(...args);\n}\n","export class Memory {\n    constructor(size) {\n        this.buffer = new ArrayBuffer(size);\n        this.view = new DataView(this.buffer);\n        new Uint8Array(this.buffer).fill(0); \n    }\n\n    // Read methods\n    readUint8(addr) { return this.view.getUint8(addr); }\n    readUint16(addr) { return this.view.getUint16(addr, true); } // true for little-endian\n    readUint32(addr) { return this.view.getUint32(addr, true); }\n    readBigUint64(addr) { return this.view.getBigUint64(addr, true); }\n\n    // Write methods\n    writeUint8(addr, value) { this.view.setUint8(addr, Number(value)); }\n    writeUint16(addr, value) { this.view.setUint16(addr, Number(value), true); } // true for little-endian\n    writeUint32(addr, value) { this.view.setUint32(addr, Number(value), true); }\n    writeBigUint64(addr, value) { this.view.setBigUint64(addr, value, true); }\n\n    // Helper to load binary data into memory (eg. boot sector)\n    load(addr, data) {\n        const sourceUint8Array = new Uint8Array(data);\n        const mainBufferView = new Uint8Array(this.buffer);\n\n        if (Number(addr) < 0 || (Number(addr) + sourceUint8Array.byteLength) > mainBufferView.byteLength) {\n            throw new Error(`Memory.load: Attempted to load 0x${sourceUint8Array.byteLength.toString(16)} bytes at 0x${addr.toString(16)} which is outside the allocated memory bounds (0x0 to 0x${mainBufferView.byteLength.toString(16)}).`);\n        }\n\n        mainBufferView.set(sourceUint8Array, Number(addr));\n        console.log(`Memory.load: Loaded 0x${sourceUint8Array.byteLength.toString(16)} bytes to 0x${addr.toString(16)}`);\n    }\n}","import { log } from \"./utils.js\";\n\nexport class IOManager {\n    constructor() {\n        this.devices = new Map();\n    }\n\n    registerDevice(ports, device) {\n        const portArray = Array.isArray(ports) ? ports : [ports];\n        for (const port of portArray) {\n            this.devices.set(port, device);\n            log(`Registered device ${device.name} at port ${port}`);\n        }\n    }\n\n    portIn(port, size) {\n        const device = this.devices.get(port);\n        if (device && device.portIn) {\n            return device.portIn(port, size);\n        }\n        return 0;\n    }\n\n    portOut(port, value, size) {\n        const device = this.devices.get(port);\n        if (device && device.portOut) {\n            device.portOut(port, value, size);\n        }\n    }\n}\n\nexport class Device {\n    /**\n     * @param {string} name A descriptive name for the device for logging/debugging.\n     */\n    constructor(name = 'Unnamed Device') {\n        this.name = name;\n    }\n\n    /**\n     * Handles a read from an I/O port associated with this device.\n     * @param {number} port The port number being read from.\n     * @param {number} size The size of the read in bytes (1, 2, or 4).\n     * @returns {number} The value to be returned to the CPU.\n     */\n    portIn(port, size) {\n        // Default behavior for a write-only or unimplemented device.\n        // Real hardware often returns 0xFF on reads from empty ports, but 0 is also fine.\n        return 0;\n    }\n\n    /**\n     * Handles a write to an I/O port associated with this device.\n     * @param {number} port The port number being written to.\n     * @param {number} value The value being written by the CPU.\n     * @param {number} size The size of the write in bytes (1, 2, or 4).\n     */\n    portOut(port, value, size) {\n        // Default behavior for a read-only or unimplemented device is to do nothing.\n        // This is exactly like real hardware.\n    }\n}\n","import * as utils from \"./utils\";\nimport { Memory } from \"./memory.js\";\nimport { IOManager } from \"./io.js\";\n\nexport class PageFaultException extends Error {\n    constructor(message, errorCode) {\n        super(message);\n        this.name = \"PageFaultException\";\n        this.errorCode = errorCode;\n    }\n}\n\nexport class CPU {\n    // --- STATIC CONSTANTS ---\n    static CR0_PE = 1n << 0n;  // Protected Mode Enable\n    static CR0_PG = 1n << 31n; // Paging Enable\n\n    static CR4_PAE = 1n << 5n; // Physical Address Extension\n\n    static FLAG_CF_BIT = 0n;\n    static FLAG_ZF_BIT = 6n;\n    static FLAG_SF_BIT = 7n;\n    static FLAG_IF_BIT = 9n;\n    static FLAG_OF_BIT = 11n;\n\n    static EFER_LME = 1n << 8n; // Long Mode Enable\n    static EFER_NXE = 1n << 11n; // No-Execute Enable (for future NX bit support)\n\n    // Constants for Page Table Entry (PTE) bits\n    // These apply to PML4E, PDPTE, PDE, PTE\n    static PTE_PRESENT       = 1n << 0n;   // P: Present (must be 1 for valid entry)\n    static PTE_READ_WRITE    = 1n << 1n;   // RW: Read/Write (0=read-only, 1=read/write)\n    static PTE_USER_SUPER    = 1n << 2n;   // US: User/Supervisor (0=supervisor-only, 1=user/supervisor)\n    static PTE_WRITE_THROUGH = 1n << 3n;   // PWT: Page Write-Through\n    static PTE_CACHE_DISABLE = 1n << 4n;   // PCD: Page Cache Disable\n    static PTE_ACCESSED      = 1n << 5n;   // A: Accessed (set by CPU on access)\n    static PTE_DIRTY         = 1n << 6n;   // D: Dirty (set by CPU on write) - only for last-level entries (PTE, PDE for 2MB, PDPTE for 1GB)\n    static PTE_PAGE_SIZE     = 1n << 7n;   // PS: Page Size (0=4KB, 1=2MB or 1GB depending on level)\n    static PTE_GLOBAL        = 1n << 8n;   // G: Global (prevents TLB flush on CR3 load - for kernel pages)\n    // Bits 9-11 are ignored for software use\n    // Bits 12-51 for physical page address (for 4KB pages) or bits 21-51 for 2MB/1GB pages\n    // Bits 52-62 ignored for software use\n    // Bit 63 (NXE in EFER, if enabled) for No-Execute\n\n    /**\n     * Creates a minimal 4-level page table structure to identity-map a range of virtual addresses to physical.\n     * Assumes 4KB pages.\n     * @param {Memory} memory The emulated memory object.\n     * @param {BigInt} virtualStart The starting virtual address to map.\n     * @param {BigInt} physicalStart The starting physical address to map.\n     * @param {BigInt} sizeBytes The size of the region to map (must be a multiple of 4KB).\n     * @param {BigInt} pageTableBasePhysAddr The base physical address where page tables will be stored.\n     * @returns {BigInt} The physical address of the PML4 table.\n     */\n    static setupIdentityPaging(memory, virtualStart, physicalStart, sizeBytes, pageTableBasePhysAddr) {\n        const PAGE_SIZE = 4096n; // 4KB\n        if (sizeBytes % PAGE_SIZE !== 0n) {\n            throw new Error(\"Mapped size must be a multiple of 4KB.\");\n        }\n        const numPages = sizeBytes / PAGE_SIZE;\n\n        let currentTableAddr = pageTableBasePhysAddr;\n\n        const pml4TablePhys = currentTableAddr;\n        currentTableAddr += PAGE_SIZE;\n\n        const pdptTablePhys = currentTableAddr;\n        currentTableAddr += PAGE_SIZE;\n\n        const pdTablePhys = currentTableAddr;\n        currentTableAddr += PAGE_SIZE;\n\n        const ptTablePhys = currentTableAddr;\n        currentTableAddr += PAGE_SIZE;\n\n        utils.log(`Setting up identity map from VA 0x${virtualStart.toString(16)} to PA 0x${physicalStart.toString(16)}, size 0x${sizeBytes.toString(16)}`);\n        utils.log(`  PML4 Table at PA 0x${pml4TablePhys.toString(16)}`);\n        utils.log(`  PDPT Table at PA 0x${pdptTablePhys.toString(16)}`);\n        utils.log(`  PD Table at PA 0x${pdTablePhys.toString(16)}`);\n        utils.log(`  PT Table at PA 0x${ptTablePhys.toString(16)}`);\n\n\n        // Initialize all tables to 0\n        for (let i = 0n; i < PAGE_SIZE / 8n; i++) {\n            memory.writeBigUint64(Number(pml4TablePhys + i * 8n), 0n);\n            memory.writeBigUint64(Number(pdptTablePhys + i * 8n), 0n);\n            memory.writeBigUint64(Number(pdTablePhys + i * 8n), 0n);\n            memory.writeBigUint64(Number(ptTablePhys + i * 8n), 0n);\n        }\n\n        // Helper for writing and verifying page table entries\n        const writeAndVerifyPTE = (addr, value, description) => {\n            memory.writeBigUint64(Number(addr), value);\n            const readBack = memory.readBigUint64(Number(addr));\n            if (readBack !== value) {\n                console.error(`ERROR: ${description} write mismatch at 0x${addr.toString(16)}! Written: 0x${value.toString(16)}, Readback: 0x${readBack.toString(16)}`);\n                throw new Error(\"Page table write verification failed.\");\n            } else {\n                utils.log(`  VERIFIED: ${description} at 0x${addr.toString(16)} is 0x${readBack.toString(16)}`);\n            }\n        };\n\n        // Map the first entry in each table to point to the next table\n        // PML4[0] -> PDPT[0]\n        let pml4e_value = pdptTablePhys | CPU.PTE_PRESENT | CPU.PTE_READ_WRITE | CPU.PTE_USER_SUPER;\n        writeAndVerifyPTE(pml4TablePhys, pml4e_value, `PML4E[0] -> PDPT[0]`);\n\n        // PDPT[0] -> PD[0]\n        let pdpte_value = pdTablePhys | CPU.PTE_PRESENT | CPU.PTE_READ_WRITE | CPU.PTE_USER_SUPER;\n        writeAndVerifyPTE(pdptTablePhys, pdpte_value, `PDPTE[0] -> PD[0]`);\n\n        // PD[0] -> PT[0]\n        let pde_value = ptTablePhys | CPU.PTE_PRESENT | CPU.PTE_READ_WRITE | CPU.PTE_USER_SUPER;\n        writeAndVerifyPTE(pdTablePhys, pde_value, `PDE[0] -> PT[0]`); \n\n        // Now, map the actual pages in the Page Table\n        for (let i = 0n; i < numPages; i++) {\n            const currentVirtualPage = virtualStart + i * PAGE_SIZE;\n            const currentPhysicalPage = physicalStart + i * PAGE_SIZE;\n            \n            let pte_value = currentPhysicalPage | CPU.PTE_PRESENT | CPU.PTE_READ_WRITE | CPU.PTE_USER_SUPER;\n            // The index into the Page Table depends on the virtual address's bits 12-20\n            const ptIndex = (currentVirtualPage >> 12n) & 0x1FFn;\n            const pteWriteAddr = ptTablePhys + ptIndex * 8n; // Calculate the specific address for this PTE\n\n            // For detailed debugging, log every 100th page, or specific pages (like 0x7C00 or 0x8000)\n            if (i % 100n === 0n || currentVirtualPage === 0x7C00n || currentVirtualPage === 0x8000n) { \n                writeAndVerifyPTE(pteWriteAddr, pte_value, `PTE for VA 0x${currentVirtualPage.toString(16)}`);\n            } else {\n                // If not logging, just perform the write\n                memory.writeBigUint64(Number(pteWriteAddr), pte_value);\n            }\n        }\n\n        return pml4TablePhys; // Return the base address of the PML4 table for CR3\n    }\n\n    constructor(memory = new Memory(1024 * 1024 * 1), io = new IOManager()) {\n        this.memory = memory;\n        this.io = io;\n\n        // Interrupt Descriptor Table Register\n        this.idtr = {\n            base: 0n,\n            limit: 0\n        }\n\n        // Global Descriptor Table Register\n        this.gdtr = {\n            base: 0n,\n            limit: 0\n        }\n\n        // Interrupt Queue\n        this.interruptQueue = [];\n\n        // General Purpose Registers\n        this.rax = 0n; this.rbx = 0n; this.rcx = 0n; this.rdx = 0n;\n        this.rsp = 0n; this.rbp = 0n; this.rsi = 0n; this.rdi = 0n;\n        this.r8 = 0n; this.r9 = 0n; this.r10 = 0n; this.r11 = 0n;\n        this.r12 = 0n; this.r13 = 0n; this.r14 = 0n; this.r15 = 0n;\n\n        // Segment Registers\n        this.cs = 0n;\n        this.ds = 0n;\n        this.ss = 0n;\n        this.es = 0n;\n        this.fs = 0n;\n        this.gs = 0n;\n\n        // RFLAGS Register\n        this.rflags = 0n;\n\n        // Instruction Pointer\n        this.rip = 0n;\n\n        // Flags\n        this.halted = false;\n        this.flags = {\n            cf: 0, // Carry Flag\n            zf: 0, // Zero Flag\n            sf: 0, // Sign Flag\n            of: 0, // Overflow Flag\n            if: 1, // Interrupt Flag\n            // TODO: Add more flags\n        }\n\n        // CPU Modes and Control Registers\n        this.mode = \"real\"; // real, protected, long\n        this.cr0 = 0n; // Control Register 0\n        this.cr3 = 0n; // Control Register 3\n        this.cr4 = 0n; // Control Register 4\n        this.efer = 0n; // Extended Feature Enable Register\n\n        // Mapping register names to their internal names\n        this.registers = {\n            // Full 64-bit\n            'rax': 'rax', 'rcx': 'rcx', 'rdx': 'rdx', 'rbx': 'rbx',\n            'rsp': 'rsp', 'rbp': 'rbp', 'rsi': 'rsi', 'rdi': 'rdi',\n            'r8': 'r8', 'r9': 'r9', 'r10': 'r10', 'r11': 'r11',\n            'r12': 'r12', 'r13': 'r13', 'r14': 'r14', 'r15': 'r15',\n            // 32-bit (low half of 64-bit)\n            'eax': 'rax', 'ecx': 'rcx', 'edx': 'rdx', 'ebx': 'rbx',\n            'esp': 'rsp', 'ebp': 'rbp', 'esi': 'rsi', 'edi': 'rdi',\n            'r8d': 'r8', 'r9d': 'r9', 'r10d': 'r10', 'r11d': 'r11',\n            'r12d': 'r12', 'r13d': 'r13', 'r14d': 'r14', 'r15d': 'r15',\n            // 16-bit (low half of 32-bit)\n            'ax': 'rax', 'cx': 'rcx', 'dx': 'rdx', 'bx': 'rbx',\n            'sp': 'rsp', 'bp': 'rbp', 'si': 'rsi', 'di': 'rdi',\n            'r8w': 'r8', 'r9w': 'r9', 'r10w': 'r10', 'r11w': 'r11',\n            'r12w': 'r12', 'r13w': 'r13', 'r14w': 'r14', 'r15w': 'r15',\n            // 8-bit (low byte of 16-bit) - AL, CL, DL, BL\n            'al': 'rax', 'cl': 'rcx', 'dl': 'rdx', 'bl': 'rbx',\n            // 8-bit (high byte of 16-bit) - AH, CH, DH, BH\n            'ah': 'rax', 'ch': 'rcx', 'dh': 'rdx', 'bh': 'rbx',\n            // 8-bit (low byte of RBP/RSP/RSI/RDI when REX prefix is used) - SPL, BPL, SIL, DIL\n            'spl': 'rsp', 'bpl': 'rbp', 'sil': 'rsi', 'dil': 'rdi',\n            // 8-bit (low byte of R8-R15) - R8B-R15B\n            'r8b': 'r8', 'r9b': 'r9', 'r10b': 'r10', 'r11b': 'r11',\n            'r12b': 'r12', 'r13b': 'r13', 'r14b': 'r14', 'r15b': 'r15',\n            // 64-bit flags register\n            'rflags': 'rflags', 'eflags': 'rflags',\n            // Segment Registers\n            'cs': 'cs', 'ds': 'ds', 'es': 'es', 'ss': 'ss', 'fs': 'fs', 'gs': 'gs',\n        };\n    }\n\n    // Helper to read register values with size handling\n    readRegister(regName, sizeBytes) {\n        if (regName === 'rflags' || regName === 'eflags') {\n            return this.assembleRFlags();\n        }\n        const fullReg = this.registers[regName];\n        if (!fullReg) {\n            throw new Error(`Attempted to read unknown register name: ${regName}`);\n        }\n        let val = this[fullReg]; // val is BigInt (e.g. this.rax)\n        if (sizeBytes === 1) {\n            // Handle AH, CH, DH, BH (high byte of 16-bit)\n            if (['ah', 'ch', 'dh', 'bh'].includes(regName)) {\n                return (val >> 8n) & 0xFFn;\n            }\n            // For AL, CL, DL, BL, SPL, BPL, SIL, DIL, R8B-R15B, it's the lowest byte\n            return (val & 0xFFn);\n        }\n        if (sizeBytes === 2) return (val & 0xFFFFn);\n        if (sizeBytes === 4) return (val & 0xFFFFFFFFn);\n        if (sizeBytes === 8) return val;\n        throw new Error(`Invalid register size: ${sizeBytes}`);\n    }\n\n    // Helper to write values to register values with size handling\n    writeRegister(regName, value, sizeBytes) {\n        const fullReg = this.registers[regName];\n        if (fullReg === undefined) {\n            throw new Error(`Attempted to write to unknown register name: ${regName}`);\n        }\n        let currentVal = this[fullReg];\n        let valToWrite = BigInt(value);\n\n        if (sizeBytes === 1) {\n            if (['ah', 'ch', 'dh', 'bh'].includes(regName)) {\n                // Clear the old AH/CH/DH/BH byte, then set the new one\n                this[fullReg] = (currentVal & ~(0xFFn << 8n)) | ((valToWrite & 0xFFn) << 8n);\n            } else {\n                // AL, CL, DL, BL, SPL, BPL, SIL, DIL, R8B-R15B\n                // Clear the lowest byte, then set the new one. Upper bits untouched.\n                this[fullReg] = (currentVal & ~0xFFn) | (valToWrite & 0xFFn);\n            }\n        } else if (sizeBytes === 2) {\n            // AX, CX, DX, BX, SP, BP, SI, DI, R8W-R15W\n            // Clear the lowest 16 bits, then set the new one. Upper bits untouched.\n            this[fullReg] = (currentVal & ~0xFFFFn) | (valToWrite & 0xFFFFn);\n        } else if (sizeBytes === 4) {\n            // EAX, ECX, EDX, EBX, ESP, EBP, ESI, EDI, R8D-R15D\n            // In 64-bit mode, writing to a 32-bit register (like EAX) zeros the upper 32 bits of the 64-bit register (RAX).\n            this[fullReg] = valToWrite & 0xFFFFFFFFn; // THIS IS THE CRITICAL CHANGE\n        } else if (sizeBytes === 8) {\n            // RAX, RCX, etc. Full 64-bit write.\n            this[fullReg] = valToWrite;\n        } else {\n            throw new Error(`Invalid register size for writing: ${sizeBytes} for register ${regName}`);\n        }\n    }\n\n    // Updates arithmetic flags based on result and operands\n    // Result, operand1, operand2 should be BigInts.\n    // 'operation' can be 'add' or 'sub'\n    updateArithmeticFlags(result, operand1, operand2, sizeBytes, operation) {\n        const bitWidth = BigInt(sizeBytes * 8);\n        const bitMask = (1n << bitWidth) - 1n; \n        const signBitPos = bitWidth - 1n; \n        const signBitMask = 1n << signBitPos;\n\n        // Apply the size mask to ensure correct behavior for operations that wrap around\n        const maskedResult = result & bitMask;\n        const maskedOperand1 = operand1 & bitMask;\n        const maskedOperand2 = operand2 & bitMask;\n\n        // Zero Flag (ZF): Set if result is 0\n        this.flags.zf = (maskedResult === 0n) ? 1 : 0;\n\n        // Sign Flag (SF): Set if result's MSB is 1\n        this.flags.sf = ((maskedResult & signBitMask) !== 0n) ? 1 : 0;\n\n        // Carry Flag (CF): For unsigned overflow\n        // For ADD: CF = 1 if result (unsigned) > max_unsigned_value_for_size\n        // For SUB: CF = 1 if operand1 (unsigned) < operand2 (unsigned) (borrow occurred)\n        if (operation === 'add') {\n            this.flags.cf = (result > bitMask) ? 1 : 0;\n        } else if (operation === 'sub') {\n            this.flags.cf = (maskedOperand1 < maskedOperand2) ? 1 : 0;\n        } else {\n            // For logical operations (AND, OR, XOR), CF is always 0\n            this.flags.cf = 0; \n        }\n\n        // Overflow Flag (OF): For signed overflow\n        // OF is set if the result's sign is different from the operands' sign (for ADD)\n        // or if the result's sign is different from the minuend's sign when the subtrahend's sign is inverted (for SUB).\n        // This is often checked by XORing sign bits:\n        // For ADD: OF = ( (Op1 ^ Res) & (Op2 ^ Res) ) >> signBitPos\n        // For SUB: OF = ( (Op1 ^ Res) & (~Op2 ^ Res) ) >> signBitPos  (where ~Op2 means bitwise NOT of Op2 within its size)\n\n        const s1 = (maskedOperand1 & signBitMask) !== 0n; // Sign of first operand\n        const s2 = (maskedOperand2 & signBitMask) !== 0n; // Sign of second operand\n        const sR = (maskedResult & signBitMask) !== 0n;   // Sign of result\n\n        this.flags.of = 0; // Assume no overflow initially\n\n        if (operation === 'add') {\n            if ((s1 === s2) && (s1 !== sR)) { // Adding two positives makes negative, or two negatives makes positive\n                this.flags.of = 1;\n            }\n        } else if (operation === 'sub') {\n            // OF is set if: (positive - negative = negative) OR (negative - positive = positive)\n            // This is equivalent to: (s1 XOR s2) AND (s1 XOR sR)\n            if ((s1 !== s2) && (s1 !== sR)) { // e.g., 7 - (-1) = 8. s1=0, s2=1, sR=0. (0!=1) && (0!=0) -> false (no OF)\n                                             // e.g., 127 - (-1) = 128. s1=0, s2=1, sR=1. (0!=1) && (0!=1) -> true (OF)\n                this.flags.of = 1;\n            }\n        } else {\n            // For logical operations (AND, OR, XOR), OF is always 0\n            this.flags.of = 0;\n        }\n    }\n\n    step() {\n        let rexPrefix = 0;\n        let defaultOperandSize; // Default bits are determined on current CPU mode (unless REX.W or 0x66 override)\n\n        this.operandSizeOverride = false;\n\n        let rex_w = 0;\n        let rex_r = 0;\n        let rex_x = 0;\n        let rex_b = 0;\n\n        let currentRIPBeforeFetch = this.rip; // Store RIP to calculate instruction start accurately\n\n        if (this.flags.if && this.interruptQueue.length > 0) {\n            this.halted = false;\n            const interruptNumber = this.interruptQueue.shift();\n            this.triggerInterrupt(interruptNumber);\n        }\n\n        if (this.halted) {\n            return true;\n        }\n\n        let opcode; // Declare opcode here, will be assigned inside prefix loop\n\n        try {\n\n        // --- Handle Prefixes (Loop to consume all prefixes) ---\n        // Read bytes one by one, processing as prefixes until main opcode or 0x0F is found.\n            let byte = this.readInstructionByte(); // Read the first byte of the potential instruction\n\n            while (true) {\n                if (byte === 0x66) { // Operand Size Override Prefix\n                    this.operandSizeOverride = true;\n                    byte = this.readInstructionByte(); // Consume 0x66, read next byte\n                } else if ((byte & 0xF0) === 0x40) { // REX prefix: 0x40 - 0x4F\n                    rexPrefix = byte;\n                    rex_w = (rexPrefix & 0x08) >>> 3;\n                    rex_r = (rexPrefix & 0x04) >>> 2;\n                    rex_x = (rexPrefix & 0x02) >>> 1;\n                    rex_b = (rexPrefix & 0x01);\n                    byte = this.readInstructionByte(); // Consume REX, read next byte\n                } \n                // Add other prefixes here (e.g., segment overrides 0x2E, 0x36, REP prefixes 0xF2, 0xF3)\n                else {\n                    // If it's not a known prefix, it must be the main opcode or 0x0F prefix\n                    opcode = byte; // Assign the actual opcode\n                    break; // Exit loop\n                }\n            }\n\n            // Determine the final default operand size based on mode and prefixes.\n            if (this.mode === 'long') {\n                // In long mode, REX.W takes precedence for 64-bit.\n                if (rex_w) {\n                    defaultOperandSize = 8;\n                }\n                // 0x66 prefix forces 16-bit.\n                else if (this.operandSizeOverride) {\n                    defaultOperandSize = 2;\n                }\n                // Default for most instructions is 32-bit.\n                else {\n                    defaultOperandSize = 4;\n                }\n            } else { // Real or Protected Mode\n                // Default is 16-bit. A 0x66 prefix toggles it to 32-bit.\n                // TODO: Add CS.D bit logic for protected mode here later.\n                defaultOperandSize = this.operandSizeOverride ? 4 : 2;\n            }\n\n            // 2-byte opcode prefix (0x0F) - This comes *after* other prefixes\n            let twoByteOpcode = false;\n            if (opcode === 0x0F) {\n                twoByteOpcode = true;\n                opcode = this.readInstructionByte(); // Read the second byte of the opcode\n            }\n\n            // --- Logging the Instruction ---\n            utils.log(`RIP: 0x${currentRIPBeforeFetch.toString(16).padStart(4, '0')}, OPCODE: 0x${(twoByteOpcode ? '0F' : '')}${opcode.toString(16).padStart(2, '0')}${rexPrefix ? ` (REX: 0x${rexPrefix.toString(16)})` : ''}${this.operandSizeOverride ? ' (0x66)' : ''}`);\n\n            // --- Instruction Decoding and Execution ---\n\n            // Priority 1: Handle two-byte opcodes (opcodes that follow 0x0F)\n            if (twoByteOpcode) {\n                // MOV Reg, CRn (0x0F 20)\n                if (opcode === 0x20) {\n                    const modrm = this.readModRMByte();\n                    const crIdx = modrm.reg;\n                    const destRegFullIndex = modrm.rm + (rex_b << 3);\n\n                    // The operand size is determined by the effective operand size.\n                    // In long mode, a REX.W prefix makes it 64-bit. Otherwise, it's 32-bit.\n                    // In real/protected mode, it defaults to 16 or 32.\n                    let sizeBytes = defaultOperandSize;\n                    if (this.mode === 'long') {\n                        sizeBytes = rex_w ? 8 : 4;\n                    }\n\n                    const destRegName = this.getRegisterString(destRegFullIndex, sizeBytes, rexPrefix !== 0);\n\n                    let sourceValue;\n                    switch (crIdx) {\n                        case 0: sourceValue = this.cr0; break;\n                        case 2: sourceValue = this.cr2; break;\n                        case 3: sourceValue = this.cr3; break;\n                        case 4: sourceValue = this.cr4; break;\n                        default:\n                            throw new Error(`Attempted to read from unknown/unsupported CR${crIdx}`);\n                    }\n\n                    this.writeRegister(destRegName, sourceValue, sizeBytes);\n                    \n                    utils.log(`Decoded: MOV ${destRegName.toUpperCase()}, CR${crIdx}`);\n                    return true;\n                }\n\n                // MOV CRn, Reg/Mem64 (0x0F 22)\n                if (opcode === 0x22) {\n                    const modrm = this.readModRMByte();\n                    const crIdx = modrm.reg; // CR register is encoded in the 'reg' field of ModR/M\n                    const sourceRegFullIndex = modrm.rm + (rex_b << 3); // Source GPR is encoded in 'r/m' field, REX.B applies\n                    \n                    // Pass hasRexPrefix (rexPrefix !== 0) to getRegisterString.\n                    const sourceRegName = this.getRegisterString(sourceRegFullIndex, 8, rexPrefix !== 0);\n\n                    const sourceValue = this.readRegister(sourceRegName, 8);\n\n                    switch (crIdx) {\n                        case 0: this.cr0 = sourceValue; utils.log(`Decoded: MOV CR0, ${sourceRegName.toUpperCase()} (0x${sourceValue.toString(16)}n)`); this.updateCPUMode(); break;\n                        case 2: this.cr2 = sourceValue; utils.log(`Decoded: MOV CR2, ${sourceRegName.toUpperCase()} (0x${sourceValue.toString(16)}n)`); break;\n                        case 3: this.cr3 = sourceValue; utils.log(`Decoded: MOV CR3, ${sourceRegName.toUpperCase()} (0x${sourceValue.toString(16)}n)`); break;\n                        case 4: this.cr4 = sourceValue; utils.log(`Decoded: MOV CR4, ${sourceRegName.toUpperCase()} (0x${sourceValue.toString(16)}n)`); this.updateCPUMode(); break;\n                        default: console.warn(`MOV CR${crIdx}, ${sourceRegName.toUpperCase()} not fully implemented/valid.`); \n                    }\n                    return true;\n                }\n                // WRMSR (0x0F 30)\n                if (opcode === 0x30) {\n                    const msrAddr = this.readRegister('rcx', 8); \n                    const valueHigh = this.readRegister('rdx', 8) << 32n; \n                    const valueLow = this.readRegister('rax', 8) & 0xFFFFFFFFn; \n                    const value = valueHigh | valueLow;\n\n                    if (msrAddr === 0xC0000080n) { // EFER MSR\n                        this.efer = value;\n                        if ((this.efer & CPU.EFER_LME) !== 0n) {\n                            utils.log(`Long Mode Enable (LME) bit set in EFER!`);\n                        }\n                        this.updateCPUMode();\n                    } else {\n                        console.warn(`WRMSR to unknown MSR 0x${msrAddr.toString(16)}`);\n                    }\n                    return true;\n                }\n                // JE/JZ (0x0F 84) - near jump with 32-bit displacement\n                if (opcode === 0x84) {\n                    const displacement = this.readSignedImmediate(4); // Read 32-bit signed displacement\n                    utils.log(`Decoded: JE/JZ rel32 0x${displacement.toString(16)} (RIP adjusted)`);\n                    if (this.flags.zf === 1) {\n                        this.rip += displacement; // Apply displacement if ZF is set\n                        utils.log(`  Condition Met (ZF=1). Jumping to 0x${this.rip.toString(16)}`);\n                    } else {\n                        utils.log(`  Condition Not Met (ZF=0). Not jumping.`);\n                    }\n                    return true;\n                }\n                // JNE/JNZ (0x0F 85) - near jump with 32-bit displacement\n                if (opcode === 0x85) {\n                    const displacement = this.readSignedImmediate(4); // Read 32-bit signed displacement\n                    utils.log(`Decoded: JNE/JNZ rel32 0x${displacement.toString(16)} (RIP adjusted)`);\n                    if (this.flags.zf === 0) {\n                        this.rip += displacement; // Apply displacement if ZF is clear\n                        utils.log(`  Condition Met (ZF=0). Jumping to 0x${this.rip.toString(16)}`);\n                    } else {\n                        utils.log(`  Condition Not Met (ZF=1). Not jumping.`);\n                    }\n                    return true;\n                }\n\n                // TODO: Implement other 2-byte Jcc instructions here (e.g., JCC, JNC, JS, JNS, JO, JNO, JP, JNP, JL, JGE, JLE, JG)\n\n                // LGDT and LIDT (0F 01 /2 and /3)\n                if (opcode === 0x01) {\n                    const modrm = this.readModRMByte();\n\n                    // LGDT m64 (opcode extension /2)\n                    if (modrm.reg === 2) {\n                        // THIS IS THE CRITICAL LINE\n                        // We MUST call resolveModRMOperand to get the memory address\n                        // AND to advance RIP past the ModR/M and any displacement bytes.\n                        const memOperand = this.resolveModRMOperand(modrm, 8, rex_x, rex_b, rexPrefix !== 0);\n\n                        // Now use the CORRECT address from the operand\n                        const limit = this.readVirtualUint16(memOperand.address);\n                        const base = this.readVirtualBigUint64(memOperand.address + 2n);\n\n                        this.gdtr.limit = limit;\n                        this.gdtr.base = base;\n\n                        utils.log(`Decoded: LGDT [0x${memOperand.address.toString(16)}] (Base: 0x${base.toString(16)}, Limit: 0x${limit.toString(16)})`);\n                        return true;\n                    }\n                    \n                    // LIDT m64 (opcode extension /3)\n                    if (modrm.reg === 3) {\n                        // THIS IS THE CRITICAL LINE\n                        const memOperand = this.resolveModRMOperand(modrm, 8, rex_x, rex_b, rexPrefix !== 0);\n\n                        // Now use the CORRECT address from the operand\n                        const limit = this.readVirtualUint16(memOperand.address);\n                        const base = this.readVirtualBigUint64(memOperand.address + 2n);\n\n                        this.idtr.limit = limit;\n                        this.idtr.base = base;\n\n                        utils.log(`Decoded: LIDT [0x${memOperand.address.toString(16)}] (Base: 0x${base.toString(16)}, Limit: 0x${limit.toString(16)})`);\n                        return true;\n                    }\n                }\n\n                // If a two-byte opcode is not handled here, it's genuinely unknown\n                utils.log(`Unknown 2-byte opcode: 0x0F ${opcode.toString(16)} at 0x${currentRIPBeforeFetch.toString(16)}`);\n                return false; // Or false if you want to halt on unknown 2-byte opcodes\n            }\n\n            // Priority 2: Handle single-byte opcodes (only if not a two-byte opcode)\n\n            // ADD r/m8, reg8\n            if (opcode === 0x00) {\n                const modrm = this.readModRMByte();\n            \n                const regName = this.getRegisterString(modrm.reg, 1, false);\n                const regVal = this.readRegister(regName, 1) & 0xFFn;\n            \n                let destAddr;\n            \n                if (modrm.mod === 0 && modrm.rm === 0) {\n                    const bx = this.readRegister(\"bx\", 2);\n                    const si = this.readRegister(\"si\", 2);\n                    destAddr = Number((bx + si) & 0xFFFFn);\n                } else {\n                    throw new Error(`ADD: Mod/RM mode not yet implemented (mod=${modrm.mod}, rm=${modrm.rm})`);\n                }\n            \n                const memVal = BigInt(this.memory.readUint8(destAddr)) & 0xFFn;\n                const result = (memVal + regVal) & 0xFFn;\n            \n                this.memory.writeUint8(destAddr, Number(result));\n                utils.log(`Decoded: ADD [BX+SI], ${regName} (0x${regVal.toString(16)}) → Result: 0x${result.toString(16)}`);\n                return true;\n            }\n\n            // NOP instruction\n            if (opcode === 0x90) {\n                utils.log(\"Decoded: NOP\");\n                return true;\n            }\n\n            // HLT instruction\n            if (opcode === 0xF4) {\n                this.halted = true;\n                utils.log(\"HLT instruction encountered. Emulation halted.\");\n                return true;\n            }\n\n            // Conditional Jumps (short form: Jcc rel8)\n            // These take a 1-byte signed relative displacement.\n            // JE/JZ (0x74)\n            if (opcode === 0x74) {\n                const displacement = this.readSignedImmediate(1); // Read 1-byte signed displacement\n                utils.log(`Decoded: JE/JZ rel8 0x${displacement.toString(16)} (RIP adjusted)`);\n                if (this.flags.zf === 1) {\n                    this.rip += displacement; // Apply displacement if ZF is set\n                    utils.log(`  Condition Met (ZF=1). Jumping to 0x${this.rip.toString(16)}`);\n                } else {\n                    utils.log(`  Condition Not Met (ZF=0). Not jumping.`);\n                }\n                return true;\n            }\n\n            // JNE/JNZ (0x75)\n            if (opcode === 0x75) {\n                const displacement = this.readSignedImmediate(1); // Read 1-byte signed displacement\n                utils.log(`Decoded: JNE/JNZ rel8 0x${displacement.toString(16)} (RIP adjusted)`);\n                if (this.flags.zf === 0) {\n                    this.rip += displacement; // Apply displacement if ZF is clear\n                    utils.log(`  Condition Met (ZF=0). Jumping to 0x${this.rip.toString(16)}`);\n                } else {\n                    utils.log(`  Condition Not Met (ZF=1). Not jumping.`);\n                }\n                return true;\n            }\n\n            // Universal MOV reg, imm (0xB0 - 0xBF)\n            if (opcode >= 0xB0 && opcode <= 0xBF) {\n                const destRegIdx = (opcode & 0x07) + (rex_b << 3);\n                let sizeBytes;\n\n                if (opcode >= 0xB0 && opcode <= 0xB7) { // 8-bit MOV (B0-B7)\n                    sizeBytes = 1;\n                } else { // 16/32/64-bit MOV (B8-BF)\n                    // THIS IS THE CORRECTED LOGIC\n                    if (this.mode === 'long') {\n                        sizeBytes = rex_w ? 8 : (this.operandSizeOverride ? 2 : 4);\n                    } else { // Real or Protected mode\n                        // Default is 16-bit. 0x66 prefix makes it 32-bit.\n                        sizeBytes = this.operandSizeOverride ? 4 : 2;\n                    }\n                }\n\n                const destRegName = this.getRegisterString(destRegIdx, sizeBytes, rexPrefix !== 0);\n                const immValue = this.readSignedImmediate(sizeBytes === 8 ? 8 : sizeBytes); // 64-bit imm is 64-bit\n                \n                this.writeRegister(destRegName, immValue, sizeBytes);\n                utils.log(`Decoded: MOV ${destRegName.toUpperCase()}, 0x${immValue.toString(16)}`);\n                return true;\n            }\n            \n            // ADD reg, r/m (0x01 / 0x03)\n            if (opcode === 0x01 || opcode === 0x03) {\n                const modrm = this.readModRMByte();\n                const dBit = (opcode >>> 1) & 0x01; \n                const wBit = opcode & 0x01;         \n\n                let sizeBytes = (wBit === 0) ? 1 : defaultOperandSize;\n\n                const regOpFullIndex = modrm.reg + (rex_r << 3);\n                const regOpName = this.getRegisterString(regOpFullIndex, sizeBytes, rexPrefix !== 0); // Pass hasRexPrefix\n                const rmOperand = this.resolveModRMOperand(modrm, sizeBytes, rex_x, rex_b, rexPrefix !== 0); // Pass hasRexPrefixForNaming\n\n                let sourceValue;\n                let destValue;\n                let destOperand; \n\n                if (rmOperand.type === 'reg') {\n                    if (dBit === 0) { \n                        sourceValue = this.readRegister(regOpName, sizeBytes);\n                        destValue = this.readRegister(rmOperand.name, sizeBytes);\n                        destOperand = rmOperand; \n                    } else { \n                        sourceValue = this.readRegister(rmOperand.name, sizeBytes);\n                        destValue = this.readRegister(regOpName, sizeBytes);\n                        destOperand = { type: 'reg', name: regOpName }; \n                    }\n                } else { \n                    if (dBit === 0) { \n                        sourceValue = this.readRegister(regOpName, sizeBytes);\n                        if (sizeBytes === 1) destValue = BigInt(this.readVirtualUint8(rmOperand.address));\n                        else if (sizeBytes === 2) destValue = BigInt(this.readVirtualUint16(rmOperand.address));\n                        else if (sizeBytes === 4) destValue = BigInt(this.readVirtualUint32(rmOperand.address));\n                        else if (sizeBytes === 8) destValue = this.readVirtualBigUint64(rmOperand.address);\n                        else throw new Error(\"Unsupported memory read size for ADD.\");\n                        destOperand = rmOperand; \n                    } else { \n                        if (sizeBytes === 1) sourceValue = BigInt(this.readVirtualUint8(rmOperand.address));\n                        else if (sizeBytes === 2) sourceValue = BigInt(this.readVirtualUint16(rmOperand.address));\n                        else if (sizeBytes === 4) sourceValue = BigInt(this.readVirtualUint32(rmOperand.address));\n                        else if (sizeBytes === 8) sourceValue = this.readVirtualBigUint64(rmOperand.address);\n                        else throw new Error(\"Unsupported memory read size for ADD.\");\n                        destValue = this.readRegister(regOpName, sizeBytes);\n                        destOperand = { type: 'reg', name: regOpName }; \n                    }\n                }\n                \n                const result = destValue + sourceValue;\n                this.updateArithmeticFlags(result, destValue, sourceValue, sizeBytes, 'add');\n\n                if (destOperand.type === 'reg') {\n                    this.writeRegister(destOperand.name, result, sizeBytes);\n                } else { \n                    if (sizeBytes === 1) this.writeVirtualUint8(destOperand.address, Number(result));\n                    else if (sizeBytes === 2) this.writeVirtualUint16(destOperand.address, Number(result));\n                    else if (sizeBytes === 4) this.writeVirtualUint32(destOperand.address, Number(result));\n                    else if (sizeBytes === 8) this.writeVirtualBigUint64(destOperand.address, result);\n                    else throw new Error(\"Unsupported memory write size for ADD.\");\n                }\n                utils.log(`Decoded: ADD ${destOperand.type === 'reg' ? destOperand.name.toUpperCase() : `[0x${destOperand.address.toString(16)}]`}, ${sourceValue.toString(16)}${sizeBytes === 8 ? 'n' : ''} -> Result: 0x${result.toString(16)}n`);\n                return true;\n            }\n\n            // ADD EAX, imm32 (0x05)\n            if (opcode === 0x05) {\n                const imm32 = this.readSignedImmediate(4);\n                const eaxValue = this.readRegister('eax', 4);\n                const result = eaxValue + imm32;\n                this.updateArithmeticFlags(result, eaxValue, imm32, 4, 'add');\n                this.writeRegister('eax', result, 4);\n                utils.log(`Decoded: ADD EAX, 0x${imm32.toString(16)} (Result: 0x${result.toString(16)})`);\n                return true;\n            }\n\n            // OR reg, r/m; OR r/m, reg (0x09 / 0x0B for 16/32/64-bit, 0x08 / 0x0A for 8-bit)\n            if (opcode >= 0x08 && opcode <= 0x0B) {\n                const modrm = this.readModRMByte();\n                const dBit = (opcode >>> 1) & 0x01; // Direction bit\n                const wBit = opcode & 0x01;         // Width bit\n\n                let sizeBytes = (wBit === 0) ? 1 : defaultOperandSize;\n\n                const regOpFullIndex = modrm.reg + (rex_r << 3);\n                const regOpName = this.getRegisterString(regOpFullIndex, sizeBytes, rexPrefix !== 0); // Pass hasRexPrefix\n                const rmOperand = this.resolveModRMOperand(modrm, sizeBytes, rex_x, rex_b, rexPrefix !== 0); // Pass hasRexPrefixForNaming\n\n                let sourceValue;\n                let destValue;\n                let destOperand;\n\n                if (rmOperand.type === 'reg') {\n                    if (dBit === 0) { // OR r/m, reg (reg is source, r/m is dest)\n                        sourceValue = this.readRegister(regOpName, sizeBytes);\n                        destValue = this.readRegister(rmOperand.name, sizeBytes);\n                        destOperand = rmOperand;\n                    } else { // OR reg, r/m (r/m is source, reg is dest)\n                        sourceValue = this.readRegister(rmOperand.name, sizeBytes);\n                        destValue = this.readRegister(regOpName, sizeBytes);\n                        destOperand = { type: 'reg', name: regOpName };\n                    }\n                } else { // rmOperand.type === 'mem'\n                    if (dBit === 0) { // OR r/m, reg (reg is source, r/m is dest)\n                        sourceValue = this.readRegister(regOpName, sizeBytes);\n                        if (sizeBytes === 1) destValue = BigInt(this.readVirtualUint8(rmOperand.address));\n                        else if (sizeBytes === 2) destValue = BigInt(this.readVirtualUint16(rmOperand.address));\n                        else if (sizeBytes === 4) destValue = BigInt(this.readVirtualUint32(rmOperand.address));\n                        else if (sizeBytes === 8) destValue = this.readVirtualBigUint64(rmOperand.address);\n                        else throw new Error(\"Unsupported memory read size for OR.\");\n                        destOperand = rmOperand;\n                    } else { // OR reg, r/m (r/m is source, reg is dest)\n                        if (sizeBytes === 1) sourceValue = BigInt(this.readVirtualUint8(rmOperand.address));\n                        else if (sizeBytes === 2) sourceValue = BigInt(this.readVirtualUint16(rmOperand.address));\n                        else if (sizeBytes === 4) sourceValue = BigInt(this.readVirtualUint32(rmOperand.address));\n                        else if (sizeBytes === 8) sourceValue = this.readVirtualBigUint64(rmOperand.address);\n                        else throw new Error(\"Unsupported memory read size for OR.\");\n                        destValue = this.readRegister(regOpName, sizeBytes);\n                        destOperand = { type: 'reg', name: regOpName };\n                    }\n                }\n                \n                const result = destValue | sourceValue; // Perform OR operation\n\n                this.flags.cf = 0; \n                this.flags.of = 0; \n                this.flags.zf = (result === 0n) ? 1 : 0; \n                const bitWidth = BigInt(sizeBytes * 8);\n                const signBitMask = 1n << (bitWidth - 1n);\n                this.flags.sf = ((result & signBitMask) !== 0n) ? 1 : 0; \n\n                if (destOperand.type === 'reg') {\n                    this.writeRegister(destOperand.name, result, sizeBytes);\n                } else { \n                    if (sizeBytes === 1) this.writeVirtualUint8(destOperand.address, Number(result));\n                    else if (sizeBytes === 2) this.writeVirtualUint16(destOperand.address, Number(result));\n                    else if (sizeBytes === 4) this.writeVirtualUint32(destOperand.address, Number(result));\n                    else if (sizeBytes === 8) this.writeVirtualBigUint64(destOperand.address, result);\n                    else throw new Error(\"Unsupported memory write size for OR.\");\n                }\n                const destOperandString = destOperand.type === 'reg' ? destOperand.name.toUpperCase() : `[0x${destOperand.address.toString(16)}]`;\n                const srcOperandString = (dBit === 0) ? regOpName.toUpperCase() : (rmOperand.type === 'reg' ? rmOperand.name.toUpperCase() : `[0x${rmOperand.address.toString(16)}]`);\n                utils.log(`Decoded: OR ${destOperandString}, ${srcOperandString} (0x${destValue.toString(16)}n | 0x${sourceValue.toString(16)}n) -> Result: 0x${result.toString(16)}n`);\n                return true;\n            }\n\n            // OR AL/AX/EAX/RAX, imm (0x0C / 0x0D)\n            if (opcode === 0x0C || opcode === 0x0D) {\n                const wBit = opcode & 0x01;\n                \n                // USE the defaultOperandSize calculated at the top of step().\n                // This is the source of truth for the operation's size.\n                let sizeBytes = (wBit === 0) ? 1 : defaultOperandSize;\n\n                const regName = this.getRegisterString(0, sizeBytes, rexPrefix !== 0); // Accumulator\n                const regValue = this.readRegister(regName, sizeBytes);\n\n                // The immediate value's size matches the operand size,\n                // except in 64-bit mode where it's a 32-bit immediate.\n                const immediateSize = (sizeBytes === 8) ? 4 : sizeBytes;\n                const immediateValue = this.readSignedImmediate(immediateSize);\n\n                const result = regValue | immediateValue;\n\n                // Flag Calculation\n                this.flags.of = 0;\n                this.flags.cf = 0;\n                const bitMask = (1n << BigInt(sizeBytes * 8)) - 1n;\n                this.flags.zf = (result & bitMask) === 0n ? 1 : 0;\n                const signBitMask = 1n << (BigInt(sizeBytes * 8) - 1n);\n                this.flags.sf = ((result & signBitMask) !== 0n) ? 1 : 0;\n                \n                this.writeRegister(regName, result, sizeBytes);\n\n                utils.log(`Decoded: OR ${regName.toUpperCase()}, 0x${immediateValue.toString(16)}`);\n                return true;\n            }\n\n            // AND reg, r/m; AND r/m, reg (0x21 / 0x23 for 16/32/64-bit, 0x20 / 0x22 for 8-bit)\n            // Note: This block handles AND r/m, reg and AND reg, r/m forms.\n            // Opcodes:\n            // 0x20: AND r/m8, reg8\n            // 0x21: AND r/m16/32/64, reg16/32/64\n            // 0x22: AND reg8, r/m8\n            // 0x23: AND reg16/32/64, r/m16/32/64\n            if (opcode >= 0x20 && opcode <= 0x23) {\n                const modrm = this.readModRMByte();\n                const dBit = (opcode >>> 1) & 0x01; // Direction bit: 0 = r/m <- reg; 1 = reg <- r/m\n                const wBit = opcode & 0x01;         // Width bit: 0 = 8-bit; 1 = 16/32/64-bit\n\n                let sizeBytes = (wBit === 0) ? 1 : defaultOperandSize;\n\n                // Use REX.R for the 'reg' field and REX.B for the 'rm' field in ModR/M\n                const regOpFullIndex = modrm.reg + (rex_r << 3);\n\n                const regOpName = this.getRegisterString(regOpFullIndex, sizeBytes, rexPrefix !== 0); // Pass hasRexPrefix\n                \n                // Resolve rmOperand, noting it might be a register or memory\n                const rmOperand = this.resolveModRMOperand(modrm, sizeBytes, rex_x, rex_b, rexPrefix !== 0); // Pass hasRexPrefixForNaming\n\n                let sourceValue;\n                let destValue;\n                let destOperand; // This will store where the result should be written\n\n                // Determine source and destination based on D-bit\n                if (dBit === 0) { // AND r/m, reg (reg is source, r/m is dest)\n                    sourceValue = this.readRegister(regOpName, sizeBytes); // Source is the register specified by ModR/M.reg\n                    if (rmOperand.type === 'reg') {\n                        destValue = this.readRegister(rmOperand.name, sizeBytes);\n                        destOperand = rmOperand;\n                    } else { // Memory destination\n                        if (sizeBytes === 1) destValue = BigInt(this.readVirtualUint8(rmOperand.address));\n                        else if (sizeBytes === 2) destValue = BigInt(this.readVirtualUint16(rmOperand.address));\n                        else if (sizeBytes === 4) destValue = BigInt(this.readVirtualUint32(rmOperand.address));\n                        else if (sizeBytes === 8) destValue = this.readVirtualBigUint64(rmOperand.address);\n                        else throw new Error(\"Unsupported memory read size for AND (dBit=0).\");\n                        destOperand = rmOperand;\n                    }\n                } else { // dBit === 1: AND reg, r/m (r/m is source, reg is dest)\n                    destValue = this.readRegister(regOpName, sizeBytes); // Destination is the register specified by ModR/M.reg\n                    destOperand = { type: 'reg', name: regOpName }; // Set destination for writing\n\n                    if (rmOperand.type === 'reg') {\n                        sourceValue = this.readRegister(rmOperand.name, sizeBytes);\n                    } else { // Memory source\n                        if (sizeBytes === 1) sourceValue = BigInt(this.readVirtualUint8(rmOperand.address));\n                        else if (sizeBytes === 2) sourceValue = BigInt(this.readVirtualUint16(rmOperand.address));\n                        else if (sizeBytes === 4) sourceValue = BigInt(this.readVirtualUint32(rmOperand.address));\n                        else if (sizeBytes === 8) sourceValue = this.readVirtualBigUint64(rmOperand.address);\n                        else throw new Error(\"Unsupported memory read size for AND (dBit=1).\");\n                    }\n                }\n                \n                const result = destValue & sourceValue; // Perform AND operation\n\n                // For logical operations (AND, OR, XOR), CF and OF are always 0.\n                this.flags.cf = 0;\n                this.flags.of = 0;\n                this.flags.zf = (result === 0n) ? 1 : 0;\n                // SF is set if the most significant bit of the result is 1 (after masking to operand size)\n                const bitWidth = BigInt(sizeBytes * 8);\n                const signBitMask = 1n << (bitWidth - 1n);\n                this.flags.sf = ((result & signBitMask) !== 0n) ? 1 : 0;\n\n                // Write the result back to the destination operand\n                if (destOperand.type === 'reg') {\n                    this.writeRegister(destOperand.name, result, sizeBytes);\n                } else { // destOperand.type === 'mem'\n                    if (sizeBytes === 1) this.writeVirtualUint8(destOperand.address, Number(result));\n                    else if (sizeBytes === 2) this.writeVirtualUint16(destOperand.address, Number(result));\n                    else if (sizeBytes === 4) this.writeVirtualUint32(destOperand.address, Number(result));\n                    else if (sizeBytes === 8) this.writeVirtualBigUint64(destOperand.address, result);\n                    else throw new Error(\"Unsupported memory write size for AND.\");\n                }\n                \n                // Improved logging for AND\n                const destOperandString = destOperand.type === 'reg' ? destOperand.name.toUpperCase() : `[0x${destOperand.address.toString(16)}]`;\n                const srcOperandString = (dBit === 0) ? regOpName.toUpperCase() : (rmOperand.type === 'reg' ? rmOperand.name.toUpperCase() : `[0x${rmOperand.address.toString(16)}]`);\n                utils.log(`Decoded: AND ${destOperandString}, ${srcOperandString} (0x${destValue.toString(16)}n & 0x${sourceValue.toString(16)}n) -> Result: 0x${result.toString(16)}n`);\n                return true;\n            }\n\n            // XOR reg, r/m (0x31 / 0x33)\n            if (opcode === 0x31 || opcode === 0x33) {\n                const modrm = this.readModRMByte();\n                const dBit = (opcode >>> 1) & 0x01; \n                const wBit = opcode & 0x01;         \n\n                let sizeBytes = (wBit === 0) ? 1 : defaultOperandSize;\n\n                const regOpFullIndex = modrm.reg + (rex_r << 3);\n                const regOpName = this.getRegisterString(regOpFullIndex, sizeBytes, rexPrefix !== 0); // Pass hasRexPrefix\n                const rmOperand = this.resolveModRMOperand(modrm, sizeBytes, rex_x, rex_b, rexPrefix !== 0); // Pass hasRexPrefixForNaming\n\n                let sourceValue;\n                let destValue;\n                let destOperand;\n\n                if (rmOperand.type === 'reg') {\n                    if (dBit === 0) { \n                        sourceValue = this.readRegister(regOpName, sizeBytes);\n                        destValue = this.readRegister(rmOperand.name, sizeBytes);\n                        destOperand = rmOperand;\n                    } else { \n                        sourceValue = this.readRegister(rmOperand.name, sizeBytes);\n                        destValue = this.readRegister(regOpName, sizeBytes);\n                        destOperand = { type: 'reg', name: regOpName };\n                    }\n                } else { \n                    if (dBit === 0) { \n                        sourceValue = this.readRegister(regOpName, sizeBytes);\n                        if (sizeBytes === 1) destValue = BigInt(this.readVirtualUint8(rmOperand.address));\n                        else if (sizeBytes === 2) destValue = BigInt(this.readVirtualUint16(rmOperand.address));\n                        else if (sizeBytes === 4) destValue = BigInt(this.readVirtualUint32(rmOperand.address));\n                        else if (sizeBytes === 8) destValue = this.readVirtualBigUint64(rmOperand.address);\n                        else throw new Error(\"Unsupported memory read size for XOR.\");\n                        destOperand = rmOperand;\n                    } else { \n                        if (sizeBytes === 1) sourceValue = BigInt(this.readVirtualUint8(rmOperand.address));\n                        else if (sizeBytes === 2) sourceValue = BigInt(this.readVirtualUint16(rmOperand.address));\n                        else if (sizeBytes === 4) sourceValue = BigInt(this.readVirtualUint32(rmOperand.address));\n                        else if (sizeBytes === 8) sourceValue = this.readVirtualBigUint64(rmOperand.address);\n                        else throw new Error(\"Unsupported memory read size for XOR.\");\n                        destValue = this.readRegister(regOpName, sizeBytes);\n                        destOperand = { type: 'reg', name: regOpName };\n                    }\n                }\n                \n                const result = destValue ^ sourceValue; // Perform XOR operation\n\n                this.flags.cf = 0; \n                this.flags.of = 0; \n                this.flags.zf = (result === 0n) ? 1 : 0; \n                this.flags.sf = ((result >> (BigInt(sizeBytes * 8) - 1n)) & 1n) === 1n ? 1 : 0; \n\n                if (destOperand.type === 'reg') {\n                    this.writeRegister(destOperand.name, result, sizeBytes);\n                } else { \n                    if (sizeBytes === 1) this.writeVirtualUint8(destOperand.address, Number(result));\n                    else if (sizeBytes === 2) this.writeVirtualUint16(destOperand.address, Number(result));\n                    else if (sizeBytes === 4) this.writeVirtualUint32(destOperand.address, Number(result));\n                    else if (sizeBytes === 8) this.writeVirtualBigUint64(destOperand.address, result);\n                    else throw new Error(\"Unsupported memory write size for XOR.\");\n                }\n                utils.log(`Decoded: XOR ${destOperand.type === 'reg' ? destOperand.name.toUpperCase() : `[0x${destOperand.address.toString(16)}]`}, ${sourceValue.toString(16)}${sizeBytes === 8 ? 'n' : ''} -> Result: 0x${result.toString(16)}n`);\n                return true;\n            }\n\n            // SUB reg, r/m (0x29 / 0x2B)\n            if (opcode === 0x29 || opcode === 0x2B) {\n                const modrm = this.readModRMByte();\n                const dBit = (opcode >>> 1) & 0x01; // Direction bit\n                const wBit = opcode & 0x01;         // Width bit\n\n                let sizeBytes = (wBit === 0) ? 1 : defaultOperandSize;\n\n                const regOpFullIndex = modrm.reg + (rex_r << 3);\n                const regOpName = this.getRegisterString(regOpFullIndex, sizeBytes, rexPrefix !== 0); // Pass hasRexPrefix\n                const rmOperand = this.resolveModRMOperand(modrm, sizeBytes, rex_x, rex_b, rexPrefix !== 0); // Pass hasRexPrefixForNaming\n\n                let sourceValue; // Subtrahend\n                let destValue;   // Minuend\n                let destOperand; \n\n                if (rmOperand.type === 'reg') {\n                    if (dBit === 0) { // SUB r/m, reg (reg is subtrahend, r/m is minuend/dest)\n                        sourceValue = this.readRegister(regOpName, sizeBytes);\n                        destValue = this.readRegister(rmOperand.name, sizeBytes);\n                        destOperand = rmOperand; \n                    } else { // SUB reg, r/m (r/m is subtrahend, reg is minuend/dest)\n                        sourceValue = this.readRegister(rmOperand.name, sizeBytes);\n                        destValue = this.readRegister(regOpName, sizeBytes);\n                        destOperand = { type: 'reg', name: regOpName }; \n                    }\n                } else { // rmOperand.type === 'mem'\n                    if (dBit === 0) { // SUB r/m, reg (reg is subtrahend, r/m is minuend/dest)\n                        sourceValue = this.readRegister(regOpName, sizeBytes);\n                        if (sizeBytes === 1) destValue = BigInt(this.readVirtualUint8(rmOperand.address));\n                        else if (sizeBytes === 2) destValue = BigInt(this.readVirtualUint16(rmOperand.address));\n                        else if (sizeBytes === 4) destValue = BigInt(this.readVirtualUint32(rmOperand.address));\n                        else if (sizeBytes === 8) destValue = this.readVirtualBigUint64(rmOperand.address);\n                        else throw new Error(\"Unsupported memory read size for SUB.\");\n                        destOperand = rmOperand; \n                    } else { // SUB reg, r/m (r/m is subtrahend, reg is minuend/dest)\n                        if (sizeBytes === 1) sourceValue = BigInt(this.readVirtualUint8(rmOperand.address));\n                        else if (sizeBytes === 2) sourceValue = BigInt(this.readVirtualUint16(rmOperand.address));\n                        else if (sizeBytes === 4) sourceValue = BigInt(this.readVirtualUint32(rmOperand.address));\n                        else if (sizeBytes === 8) sourceValue = this.readVirtualBigUint64(rmOperand.address);\n                        else throw new Error(\"Unsupported memory read size for SUB.\");\n                        destValue = this.readRegister(regOpName, sizeBytes);\n                        destOperand = { type: 'reg', name: regOpName }; \n                    }\n                }\n                \n                const result = destValue - sourceValue;\n                this.updateArithmeticFlags(result, destValue, sourceValue, sizeBytes, 'sub');\n\n                if (destOperand.type === 'reg') {\n                    this.writeRegister(destOperand.name, result, sizeBytes);\n                } else { // destOperand.type === 'mem'\n                    if (sizeBytes === 1) this.writeVirtualUint8(destOperand.address, Number(result));\n                    else if (sizeBytes === 2) this.writeVirtualUint16(destOperand.address, Number(result));\n                    else if (sizeBytes === 4) this.writeVirtualUint32(destOperand.address, Number(result));\n                    else if (sizeBytes === 8) this.writeVirtualBigUint64(destOperand.address, result);\n                    else throw new Error(\"Unsupported memory write size for SUB.\");\n                }\n                utils.log(`Decoded: SUB ${destOperand.type === 'reg' ? destOperand.name.toUpperCase() : `[0x${destOperand.address.toString(16)}]`}, ${sourceValue.toString(16)}${sizeBytes === 8 ? 'n' : ''} -> Result: 0x${result.toString(16)}n`);\n                return true;\n            }\n\n            // CMP reg, r/m; CMP r/m, reg (0x39 / 0x3B for 32/64-bit, 0x38 / 0x3A for 8-bit)\n            if (opcode >= 0x38 && opcode <= 0x3B) {\n                const modrm = this.readModRMByte();\n                const dBit = (opcode >>> 1) & 0x01; // Direction bit\n                const wBit = opcode & 0x01;         // Width bit\n\n                let sizeBytes = (wBit === 0) ? 1 : defaultOperandSize;\n\n                const regOpFullIndex = modrm.reg + (rex_r << 3);\n                const regOpName = this.getRegisterString(regOpFullIndex, sizeBytes, rexPrefix !== 0); // Pass hasRexPrefix\n                const rmOperand = this.resolveModRMOperand(modrm, sizeBytes, rex_x, rex_b, rexPrefix !== 0); // Pass hasRexPrefixForNaming\n\n                let sourceValue; // Subtrahend\n                let destValue;   // Minuend\n\n                if (rmOperand.type === 'reg') {\n                    if (dBit === 0) { // CMP r/m, reg (reg is subtrahend, r/m is minuend)\n                        sourceValue = this.readRegister(regOpName, sizeBytes);\n                        destValue = this.readRegister(rmOperand.name, sizeBytes);\n                    } else { // CMP reg, r/m (r/m is subtrahend, reg is minuend)\n                        sourceValue = this.readRegister(rmOperand.name, sizeBytes);\n                        destValue = this.readRegister(regOpName, sizeBytes);\n                    }\n                } else { // rmOperand.type === 'mem'\n                    if (dBit === 0) { // CMP r/m, reg (reg is subtrahend, r/m is minuend)\n                        sourceValue = this.readRegister(regOpName, sizeBytes);\n                        if (sizeBytes === 1) destValue = BigInt(this.readVirtualUint8(rmOperand.address));\n                        else if (sizeBytes === 2) destValue = BigInt(this.readVirtualUint16(rmOperand.address));\n                        else if (sizeBytes === 4) destValue = BigInt(this.readVirtualUint32(rmOperand.address));\n                        else if (sizeBytes === 8) destValue = this.readVirtualBigUint64(rmOperand.address);\n                        else throw new Error(\"Unsupported memory read size for CMP.\");\n                    } else { // CMP reg, r/m (r/m is subtrahend, reg is minuend)\n                        if (sizeBytes === 1) sourceValue = BigInt(this.readVirtualUint8(rmOperand.address));\n                        else if (sizeBytes === 2) sourceValue = BigInt(this.readVirtualUint16(rmOperand.address));\n                        else if (sizeBytes === 4) sourceValue = BigInt(this.readVirtualUint32(rmOperand.address));\n                        else if (sizeBytes === 8) sourceValue = this.readVirtualBigUint64(rmOperand.address);\n                        else throw new Error(\"Unsupported memory read size for CMP.\");\n                        destValue = this.readRegister(regOpName, sizeBytes);\n                    }\n                }\n                \n                // Perform the subtraction for flags, but do not write the result back\n                const result = destValue - sourceValue;\n                this.updateArithmeticFlags(result, destValue, sourceValue, sizeBytes, 'sub');\n\n                const destOperandString = (dBit === 0) ? (rmOperand.type === 'reg' ? rmOperand.name.toUpperCase() : `[0x${rmOperand.address.toString(16)}]`) : regOpName.toUpperCase();\n                const srcOperandString = (dBit === 0) ? regOpName.toUpperCase() : (rmOperand.type === 'reg' ? rmOperand.name.toUpperCase() : `[0x${rmOperand.address.toString(16)}]`);\n                utils.log(`Decoded: CMP ${destOperandString}, ${srcOperandString} (0x${destValue.toString(16)}n - 0x${sourceValue.toString(16)}n)`);\n                return true;\n            }\n\n            // CMP r/m32, imm32 (0x81 /7)\n            if (opcode === 0x81) {\n                const modrm = this.readModRMByte();\n                if (modrm.reg === 7) {\n                    const imm32 = this.readSignedImmediate(4);\n                    let sizeBytes = 4;\n                    const rmOperand = this.resolveModRMOperand(modrm, sizeBytes, rex_x, rex_b, rexPrefix !== 0);\n\n                    let destValue;\n                    if (rmOperand.type === 'reg') {\n                        destValue = this.readRegister(rmOperand.name, sizeBytes);\n                    } else {\n                        destValue = BigInt(this.readVirtualUint32(rmOperand.address));\n                    }\n                    const result = destValue - imm32;\n                    this.updateArithmeticFlags(result, destValue, imm32, sizeBytes, 'sub');\n                    utils.log(`Decoded: CMP ${rmOperand.type === 'reg' ? rmOperand.name.toUpperCase() : `[0x${rmOperand.address.toString(16)}]`}, 0x${imm32.toString(16)}`);\n                    return true;\n                }\n            }\n\n            // Group 1 Instructions (ADD, OR, ADC, SBB, AND, SUB, XOR, CMP) with immediate\n            // 0x81: r/m, imm32\n            // 0x83: r/m, imm8 (sign-extended)\n            if (opcode === 0x81 || opcode === 0x83) {\n                const modrm = this.readModRMByte();\n                let sizeBytes = defaultOperandSize;\n\n                const rmOperand = this.resolveModRMOperand(modrm, sizeBytes, rex_x, rex_b, rexPrefix !== 0);\n\n                // Opcode 0x83 uses a sign-extended 8-bit immediate.\n                // Opcode 0x81 uses a 16/32-bit immediate.\n                const immediateSizeBytes = (opcode === 0x83) ? 1 : (sizeBytes === 2 ? 2 : 4);\n                const immediateValue = this.readSignedImmediate(immediateSizeBytes);\n\n                // Read the destination value\n                let destValue;\n                if (rmOperand.type === 'reg') {\n                    destValue = this.readRegister(rmOperand.name, sizeBytes);\n                } else { // Memory\n                    if (sizeBytes === 1) destValue = BigInt(this.readVirtualUint8(rmOperand.address));\n                    else if (sizeBytes === 2) destValue = BigInt(this.readVirtualUint16(rmOperand.address));\n                    else if (sizeBytes === 4) destValue = BigInt(this.readVirtualUint32(rmOperand.address));\n                    else destValue = this.readVirtualBigUint64(rmOperand.address);\n                }\n\n                let result;\n                let operation = 'unknown';\n\n                // The 'reg' field selects the operation\n                switch (modrm.reg) {\n                    case 0: // ADD\n                        operation = 'add';\n                        result = destValue + immediateValue;\n                        break;\n                    case 1: // OR\n                        operation = 'or';\n                        result = destValue | immediateValue;\n                        break;\n                    case 2: // ADC\n                        operation = 'adc';\n                        result = destValue + immediateValue + this.flags.cf;\n                        break;\n                    case 3: // SBB\n                        operation = 'sbb';\n                        result = destValue - immediateValue - this.flags.cf;\n                        break;\n                    case 4: // AND\n                        operation = 'and';\n                        result = destValue & immediateValue;\n                        break;\n                    case 5: // SUB\n                        operation = 'sub';\n                        result = destValue - immediateValue;\n                        break;\n                    case 6: // XOR\n                        operation = 'xor';\n                        result = destValue ^ immediateValue;\n                        break;\n                    case 7: // CMP\n                        operation = 'sub'; // CMP performs a subtraction for flags\n                        result = destValue - immediateValue;\n                        break;\n                    default:\n                        throw new Error(`Unsupported Group 1 operation with /reg=${modrm.reg}`);\n                }\n\n                // Update flags based on the operation\n                if (operation === 'add' || operation === 'sub' || operation === 'adc' || operation === 'sbb') {\n                    // For ADC and SBB, the \"second operand\" is conceptually the immediate value PLUS the carry/borrow.\n                    const effectiveOperand2 = (operation === 'adc' || operation === 'sbb')\n                        ? immediateValue + BigInt(this.flags.cf)\n                        : immediateValue;\n                    \n                    // The operation for flags is always a simple add or sub.\n                    const flagOperation = (operation === 'add' || operation === 'adc') ? 'add' : 'sub';\n\n                    this.updateArithmeticFlags(result, destValue, effectiveOperand2, sizeBytes, flagOperation);\n                } else { // Logical ops (AND, OR, XOR)\n                    this.flags.cf = 0;\n                    this.flags.of = 0;\n                    const bitMask = (1n << BigInt(sizeBytes * 8)) - 1n;\n                    this.flags.zf = (result & bitMask) === 0n ? 1 : 0;\n                    const signBitMask = 1n << (BigInt(sizeBytes * 8) - 1n);\n                    this.flags.sf = ((result & signBitMask) !== 0n) ? 1 : 0;\n                }\n\n                // For all operations except CMP, write the result back\n                if (modrm.reg !== 7) { // if not CMP\n                    if (rmOperand.type === 'reg') {\n                        this.writeRegister(rmOperand.name, result, sizeBytes);\n                    } else { // Memory\n                        if (sizeBytes === 1) this.writeVirtualUint8(rmOperand.address, Number(result));\n                        else if (sizeBytes === 2) this.writeVirtualUint16(rmOperand.address, Number(result));\n                        else if (sizeBytes === 4) this.writeVirtualUint32(rmOperand.address, Number(result));\n                        else this.writeVirtualBigUint64(rmOperand.address, result);\n                    }\n                }\n                \n                const mnemonic = ['ADD', 'OR', 'ADC', 'SBB', 'AND', 'SUB', 'XOR', 'CMP'][modrm.reg];\n                const rmStr = rmOperand.type === 'reg' ? rmOperand.name.toUpperCase() : `[0x${rmOperand.address.toString(16)}]`;\n                utils.log(`Decoded: ${mnemonic} ${rmStr}, 0x${immediateValue.toString(16)}`);\n                return true;\n            }\n\n            // CMP AL/AX/EAX/RAX, imm (0x3C / 0x3D)\n            if (opcode === 0x3C || opcode === 0x3D) {\n                const wBit = opcode & 0x01;\n                let sizeBytes = (wBit === 0) ? 1 : defaultOperandSize;\n\n                const regName = this.getRegisterString(0, sizeBytes, rexPrefix !== 0); // Always AL/AX/EAX/RAX\n                const regValue = this.readRegister(regName, sizeBytes);\n                \n                // Note: Even for CMP RAX, the immediate is only 32 bits and is sign-extended.\n                const immediateSize = (sizeBytes === 1) ? 1 : 4;\n                const immediateValue = this.readSignedImmediate(immediateSize);\n\n                const result = regValue - immediateValue;\n                this.updateArithmeticFlags(result, regValue, immediateValue, sizeBytes, 'sub');\n                \n                // CMP does not store the result, it only sets flags.\n\n                utils.log(`Decoded: CMP ${regName.toUpperCase()}, 0x${immediateValue.toString(16)}`);\n                return true;\n            }\n\n            // MOV r/m, reg; MOV reg, r/m (0x88, 0x89, 0x8A, 0x8B)\n            if (opcode >= 0x88 && opcode <= 0x8B) {\n                const modrm = this.readModRMByte();\n                const dBit = (opcode >>> 1) & 0x01;\n                const wBit = opcode & 0x01;\n\n                let sizeBytes = (wBit === 0) ? 1 : defaultOperandSize;\n\n                const regOpFullIndex = modrm.reg + (rex_r << 3);\n                const regOpName = this.getRegisterString(regOpFullIndex, sizeBytes, rexPrefix !== 0);\n                const rmOperand = this.resolveModRMOperand(modrm, sizeBytes, rex_r, rex_b, rex_x, rexPrefix !== 0);\n                \n                const fullRegNameForVerify = this.registers[regOpName]; // Get the full 64-bit register name (e.g., 'rax' from 'ax')\n\n                utils.log(`--- MOV [r/m],reg START (Opcode: 0x${opcode.toString(16)}) ---`);\n                utils.log(`  dBit=${dBit}, sizeBytes=${sizeBytes}, regOp=${regOpName}, rmOperand.addr=0x${rmOperand.address?.toString(16)}`);\n\n                if (dBit === 0) { // Direction: r/m <- reg\n                    const sourceValue = this.readRegister(regOpName, sizeBytes);\n                    utils.log(`  DIRECTION: r/m <- reg. Writing 0x${sourceValue.toString(16)} from ${regOpName}...`);\n                    \n                    if (rmOperand.type === 'reg') {\n                        this.writeRegister(rmOperand.name, sourceValue, sizeBytes);\n                    } else { // Memory Destination\n                        utils.log(`  ...to MEMORY at 0x${rmOperand.address.toString(16)}`);\n                        if (sizeBytes === 1) this.writeVirtualUint8(rmOperand.address, sourceValue);\n                        else if (sizeBytes === 2) this.writeVirtualUint16(rmOperand.address, sourceValue);\n                        else if (sizeBytes === 4) this.writeVirtualUint32(rmOperand.address, sourceValue);\n                        else this.writeVirtualBigUint64(rmOperand.address, sourceValue);\n                    }\n                } else { // dBit === 1, Direction: reg <- r/m\n                    const destRegName = regOpName;\n                    let sourceValue;\n                    \n                    utils.log(`  DIRECTION: reg <- r/m. Reading from r/m operand...`);\n\n                    if (rmOperand.type === 'reg') {\n                        sourceValue = this.readRegister(rmOperand.name, sizeBytes);\n                    } else { // Memory Source\n                        sourceValue = sizeBytes === 1 ? BigInt(this.readVirtualUint8(rmOperand.address))\n                                    : sizeBytes === 2 ? BigInt(this.readVirtualUint16(rmOperand.address))\n                                    : sizeBytes === 4 ? BigInt(this.readVirtualUint32(rmOperand.address))\n                                    : this.readVirtualBigUint64(rmOperand.address);\n                    }\n                    \n                    utils.log(`  Read value 0x${sourceValue.toString(16)} from r/m. Writing to ${destRegName}.`);\n                    this.writeRegister(destRegName, sourceValue, sizeBytes);\n\n                    // === THIS IS THE CRITICAL NEW LOG ===\n                    utils.log(`  VERIFY: After writing to ${destRegName}, the full register ${fullRegNameForVerify} is now 0x${this[fullRegNameForVerify].toString(16)}`);\n                    // ===================================\n                }\n                utils.log(`--- MOV [r/m],reg END ---`);\n                return true;\n            }\n\n            // MOV r/m{16,32,64}, imm{16,32,64} (0xC7 /0)\n            if (opcode === 0xC7) {\n                const modrm = this.readModRMByte();\n                \n                // For 0xC7, the reg field in ModR/M should be 0\n                if (modrm.reg !== 0) {\n                    throw new Error(`Invalid ModR/M reg field for MOV r/m, imm: ${modrm.reg}`);\n                }\n                \n                // Determine operand size based on prefix and mode\n                let sizeBytes, targetSizeBytes;\n                if (rexPrefix !== 0 && (rexPrefix & 0x08)) {  // REX.W prefix\n                    sizeBytes = 4;  // 32-bit immediate sign-extended to 64-bit\n                    targetSizeBytes = 8;  // Target is 64-bit\n                } else if (this.operandSizeOverride) {\n                    sizeBytes = 2; // 16-bit with 66h prefix\n                    targetSizeBytes = 2;\n                } else {\n                    sizeBytes = 4; // 32-bit\n                    targetSizeBytes = 4;\n                }\n                \n                // Read immediate value\n                let immValue = this.readSignedImmediate(sizeBytes);\n                \n                // Sign extend to 64 bits if needed\n                if (sizeBytes === 4 && targetSizeBytes === 8) {\n                    immValue = BigInt.asIntN(32, immValue);\n                }\n                \n                // Resolve the destination operand with target size\n                const rmOperand = this.resolveModRMOperand(modrm, targetSizeBytes, rex_r, rex_b, rexPrefix !== 0);\n                \n                // Write the immediate to the destination\n                if (rmOperand.type === 'reg') {\n                    this.writeRegister(rmOperand.name, immValue, targetSizeBytes);\n                } else {\n                    // For memory destination, use the actual size of the immediate\n                    if (sizeBytes === 1) {\n                        this.writeVirtualUint8(rmOperand.address, Number(immValue));\n                    } else if (sizeBytes === 2) {\n                        this.writeVirtualUint16(rmOperand.address, Number(immValue));\n                    } else if (sizeBytes === 4) {\n                        this.writeVirtualUint32(rmOperand.address, Number(immValue));\n                    } else {\n                        throw new Error(`Unsupported size for MOV r/m, imm: ${sizeBytes} bytes`);\n                    }\n                }\n                \n                utils.log(`Decoded: MOV ${rmOperand.type === 'reg' ? rmOperand.name.toUpperCase() : `[0x${rmOperand.address.toString(16)}]`}, 0x${immValue.toString(16)}`);\n                return true;\n            }\n\n            // MOV r/m8, imm8 (0xC6 /0)\n            if (opcode === 0xC6) {\n                const modrm = this.readModRMByte();\n            \n                if (modrm.reg !== 0) {\n                    throw new Error(`Invalid ModR/M reg field for MOV r/m8, imm8: ${modrm.reg}`);\n                }\n            \n                const rmOperand = this.resolveModRMOperand(modrm, 1, rex_r, rex_b, rexPrefix !== 0);\n            \n                const immValue = this.readSignedImmediate(1); // Reads and advances RIP by 1\n            \n                if (rmOperand.type === 'reg') {\n                    this.writeRegister(rmOperand.name, immValue, 1);\n                } else {\n                    this.writeVirtualUint8(rmOperand.address, Number(immValue));\n                }\n            \n                utils.log(`Decoded: MOV byte ${rmOperand.type === 'reg' ? rmOperand.name.toUpperCase() : `[0x${rmOperand.address.toString(16)}]`}, 0x${immValue.toString(16)}`);\n                return true;\n            }\n\n            // MOV SR, r/m16 (0x8E /r)\n            if (opcode === 0x8E) {\n                const modrm = this.readModRMByte();\n            \n                const segmentRegs = ['es', 'cs', 'ss', 'ds', 'fs', 'gs'];\n                const sregName = segmentRegs[modrm.reg];\n            \n                if (!sregName) {\n                    throw new Error(`Invalid segment register index: ${modrm.reg}`);\n                }\n            \n                const rmOperand = this.resolveModRMOperand(modrm, 2, rex_r, rex_b, rexPrefix !== 0);\n            \n                let value;\n                if (rmOperand.type === 'reg') {\n                    value = Number(this.readRegister(rmOperand.name, 2)); // value is 16-bit number\n                } else {\n                    value = this.readVirtualUint16(rmOperand.address);\n                }\n            \n                // Write value into the segment register (16-bit)\n                this.writeRegister(sregName, BigInt(value), 2);\n            \n                utils.log(`Decoded: MOV ${sregName.toUpperCase()}, ${rmOperand.type === 'reg' ? rmOperand.name.toUpperCase() : `[0x${rmOperand.address.toString(16)}]`} (0x${value.toString(16)})`);\n                return true;\n            }\n\n            // PUSH reg (0x50 + reg_index)\n            if (opcode >= 0x50 && opcode <= 0x57) {\n                const regIdx = opcode - 0x50;\n                const sizeBytes = 8;\n                const regName = this.getRegisterString(regIdx, sizeBytes, rexPrefix !== 0);\n                const value = this.readRegister(regName, sizeBytes);\n                utils.log(`PUSH ${regName.toUpperCase()} - RSP Before: 0x${this.rsp.toString(16)}`);\n                this.rsp -= BigInt(sizeBytes);\n                this.writeVirtualBigUint64(this.rsp, value);\n                utils.log(`Decoded: PUSH ${regName.toUpperCase()} (0x${value.toString(16)}n)`);\n                utils.log(`PUSH ${regName.toUpperCase()} - RSP After: 0x${this.rsp.toString(16)}`);\n                return true;\n            }\n\n            // PUSH r/m (0xFF /6)\n            if (opcode === 0xFF) {\n                const modrm = this.readModRMByte();\n                if (modrm.reg === 6) { // PUSH r/m\n                    let sizeBytes = defaultOperandSize;\n                    const rmOperand = this.resolveModRMOperand(modrm, sizeBytes, rex_x, rex_b, rexPrefix !== 0);\n                    \n                    let value;\n                    if (rmOperand.type === 'reg') {\n                        value = this.readRegister(rmOperand.name, sizeBytes);\n                    } else {\n                        if (sizeBytes === 1) value = BigInt(this.readVirtualUint8(rmOperand.address));\n                        else if (sizeBytes === 2) value = BigInt(this.readVirtualUint16(rmOperand.address));\n                        else if (sizeBytes === 4) value = BigInt(this.readVirtualUint32(rmOperand.address));\n                        else if (sizeBytes === 8) value = this.readVirtualBigUint64(rmOperand.address);\n                        else throw new Error(\"Unsupported memory read size for PUSH r/m.\");\n                    }\n                    utils.log(`PUSH ${rmOperand.type === 'reg' ? rmOperand.name.toUpperCase() : `[0x${rmOperand.address.toString(16)}]`} - RSP Before: 0x${this.rsp.toString(16)}`);\n                    this.rsp -= BigInt(sizeBytes);\n                    this.writeVirtualBigUint64(this.rsp, value);\n                    \n                    utils.log(`Decoded: PUSH ${rmOperand.type === 'reg' ? rmOperand.name.toUpperCase() : `[0x${rmOperand.address.toString(16)}]`} (0x${value.toString(16)}n)`);\n                    utils.log(`PUSH ${rmOperand.type === 'reg' ? rmOperand.name.toUpperCase() : `[0x${rmOperand.address.toString(16)}]`} - RSP After: 0x${this.rsp.toString(16)}`);\n                    return true;\n                }\n            }\n\n            // POP reg (0x58 + reg_index)\n            if (opcode >= 0x58 && opcode <= 0x5F) {\n                const regIdx = opcode - 0x58;\n                const sizeBytes = 8;\n                const regName = this.getRegisterString(regIdx, sizeBytes, rexPrefix !== 0);\n                utils.log(`POP ${regName.toUpperCase()} - RSP Before: 0x${this.rsp.toString(16)}`);\n                const value = this.readVirtualBigUint64(this.rsp);\n                this.writeRegister(regName, value, sizeBytes);\n                this.rsp += BigInt(sizeBytes);\n                \n                utils.log(`Decoded: POP ${regName.toUpperCase()} (0x${value.toString(16)}n)`);\n                utils.log(`POP ${regName.toUpperCase()} - RSP After: 0x${this.rsp.toString(16)}`);\n                return true;\n            }\n\n            // POP r/m (0x8F /0)\n            if (opcode === 0x8F) {\n                const modrm = this.readModRMByte();\n                if (modrm.reg === 0) { // POP r/m\n                    let sizeBytes = defaultOperandSize;\n                    const rmOperand = this.resolveModRMOperand(modrm, sizeBytes, rex_x, rex_b, rexPrefix !== 0);\n                    \n                    utils.log(`POP ${rmOperand.type === 'reg' ? rmOperand.name.toUpperCase() : `[0x${rmOperand.address.toString(16)}]`} - RSP Before: 0x${this.rsp.toString(16)}`);\n                    this.rsp += BigInt(sizeBytes);\n                    this.writeRegister(rmOperand.name, value, sizeBytes);\n\n                    let value;\n                    if (rmOperand.type === 'reg') {\n                        value = this.readRegister(rmOperand.name, sizeBytes);\n                    } else {\n                        if (sizeBytes === 1) value = BigInt(this.readVirtualUint8(rmOperand.address));\n                        else if (sizeBytes === 2) value = BigInt(this.readVirtualUint16(rmOperand.address));\n                        else if (sizeBytes === 4) value = BigInt(this.readVirtualUint32(rmOperand.address));\n                        else if (sizeBytes === 8) value = this.readVirtualBigUint64(rmOperand.address);\n                        else throw new Error(\"Unsupported memory read size for POP r/m.\");\n                    }\n\n                    utils.log(`Decoded: POP ${rmOperand.type === 'reg' ? rmOperand.name.toUpperCase() : `[0x${rmOperand.address.toString(16)}]`} (0x${value.toString(16)}n)`);\n                    utils.log(`POP ${rmOperand.type === 'reg' ? rmOperand.name.toUpperCase() : `[0x${rmOperand.address.toString(16)}]`} - RSP After: 0x${this.rsp.toString(16)}`);\n                    return true;\n                }\n            }\n\n            // CALL rel32 (0xE8) - Near, relative, 32-bit displacement\n            if (opcode === 0xE8) {\n                const displacement = this.readSignedImmediate(4);\n                const retAddr = this.rip;\n                utils.log(`CALL rel32 - RSP Before: 0x${this.rsp.toString(16)}`);\n                this.rsp -= 8n;\n                this.writeVirtualBigUint64(this.rsp, retAddr);\n                this.rip += BigInt(displacement);\n\n                utils.log(`Decoded: CALL rel32 0x${displacement.toString(16)} (RIP adjusted to 0x${this.rip.toString(16)})`);\n                utils.log(`CALL rel32 - RSP After: 0x${this.rsp.toString(16)}`);\n                return true;\n            }\n\n            // CALL r/m (0xFF /2) - Near, absolute, indirect\n            if (opcode === 0xFF) {\n                const modrm = this.readModRMByte();\n                if (modrm.reg === 2) { // opcode extension /2\n                    let sizeBytes = defaultOperandSize;\n                    const rmOperand = this.resolveModRMOperand(modrm, sizeBytes, rex_x, rex_b, rexPrefix !== 0);\n                    \n                    let tgtAddr;\n                    if (rmOperand.type === 'reg') {\n                        tgtAddr = this.readRegister(rmOperand.name, sizeBytes);\n                    } else {\n                        if (sizeBytes === 1) tgtAddr = BigInt(this.readVirtualUint8(rmOperand.address));\n                        else if (sizeBytes === 2) tgtAddr = BigInt(this.readVirtualUint16(rmOperand.address));\n                        else if (sizeBytes === 4) tgtAddr = BigInt(this.readVirtualUint32(rmOperand.address));\n                        else if (sizeBytes === 8) tgtAddr = this.readVirtualBigUint64(rmOperand.address);\n                        else throw new Error(\"Unsupported memory read size for CALL r/m.\");\n                    }\n                    \n                    const retAddr = this.rip;\n                    utils.log(`CALL r/m - RSP Before: 0x${this.rsp.toString(16)}`);\n                    this.rsp -= 8n;\n                    this.writeVirtualBigUint64(this.rsp, retAddr);\n                    this.rip = tgtAddr;\n\n                    utils.log(`Decoded: CALL ${rmOperand.type === 'reg' ? rmOperand.name.toUpperCase() : `[0x${rmOperand.address.toString(16)}]`} (Indirect, jumping to 0x${this.rip.toString(16)})`);\n                    utils.log(`CALL r/m - RSP After: 0x${this.rsp.toString(16)}`);\n                    return true;\n                }\n            }\n\n            // RET (0xC3) - Near return\n            if (opcode === 0xC3) {\n                utils.log(`RET - RSP Before: 0x${this.rsp.toString(16)}`);\n                const retAddr = this.readVirtualBigUint64(this.rsp);\n                this.rsp += 8n;\n                this.rip = retAddr;\n\n                utils.log(`Decoded: RET (Near, jumping to 0x${this.rip.toString(16)})`);\n                utils.log(`RET - RSP After: 0x${this.rsp.toString(16)}`);\n                return true;\n            }\n\n            // RET imm16 (0xC2) - Near, return with immediate\n            if (opcode === 0xC2) {\n                const imm16 = this.readSignedImmediate(2);\n                utils.log(`RET imm16 - RSP Before: 0x${this.rsp.toString(16)}`);\n                const retAddr = this.readVirtualBigUint64(this.rsp);\n                this.rsp += 8n;\n                this.rip = retAddr;\n                this.rsp += BigInt(imm16);\n\n                utils.log(`Decoded: RET imm16 (jumping to 0x${this.rip.toString(16)}, stack adjust by 0x${imm16.toString(16)})`);\n                utils.log(`RET imm16 - RSP After: 0x${this.rsp.toString(16)}`);\n                return true;\n            }\n\n            // LEA r/m, reg (0x8D)\n            if (opcode === 0x8D) {\n                const modrm = this.readModRMByte();\n                // LEA only works with memory sources, so mod must not be 3\n                if (modrm.mod === 3) {\n                    throw new Error(\"Invalid use of LEA with register source.\");\n                }\n\n                let sizeBytes = defaultOperandSize;\n                // Note: In 64-bit mode, operand size can be 16, 32, or 64.\n                // REX.W=1 -> 64-bit. No REX.W -> 32-bit. 0x66 prefix -> 16-bit.\n\n                const destRegFullIndex = modrm.reg + (rex_r << 3);\n                const destRegName = this.getRegisterString(destRegFullIndex, sizeBytes, rexPrefix !== 0);\n\n                // Here's the magic: we use resolveModRMOperand to get the address\n                const memOperand = this.resolveModRMOperand(modrm, sizeBytes, rex_x, rex_b, rexPrefix !== 0);\n                const effectiveAddress = memOperand.address;\n\n                // ...but we write the address itself to the destination register.\n                this.writeRegister(destRegName, effectiveAddress, sizeBytes);\n\n                utils.log(`Decoded: LEA ${destRegName.toUpperCase()}, [address] (Calculated address: 0x${effectiveAddress.toString(16)})`);\n                return true;\n            }\n\n            // TEST r/m, reg (0x84, 0x85)\n            if (opcode === 0x84 || opcode === 0x85) {\n                const modrm = this.readModRMByte();\n                const wBit = opcode & 0x01;\n                let sizeBytes = (wBit === 0) ? 1 : defaultOperandSize;\n\n                const regOpFullIndex = modrm.reg + (rex_r << 3);\n                const regOpName = this.getRegisterString(regOpFullIndex, sizeBytes, rexPrefix !== 0);\n                const rmOperand = this.resolveModRMOperand(modrm, sizeBytes, rex_x, rex_b, rexPrefix !== 0);\n\n                let val1, val2;\n                val1 = this.readRegister(regOpName, sizeBytes); // Operand from reg field\n\n                if (rmOperand.type === 'reg') {\n                    val2 = this.readRegister(rmOperand.name, sizeBytes);\n                } else { // Memory operand\n                    if (sizeBytes === 1) val2 = BigInt(this.readVirtualUint8(rmOperand.address));\n                    else if (sizeBytes === 2) val2 = BigInt(this.readVirtualUint16(rmOperand.address));\n                    else if (sizeBytes === 4) val2 = BigInt(this.readVirtualUint32(rmOperand.address));\n                    else val2 = this.readVirtualBigUint64(rmOperand.address);\n                }\n\n                const result = val1 & val2;\n\n                // TEST sets flags based on the result but doesn't store it\n                this.flags.cf = 0;\n                this.flags.of = 0;\n                this.flags.zf = (result === 0n) ? 1 : 0;\n                const signBitMask = 1n << (BigInt(sizeBytes * 8) - 1n);\n                this.flags.sf = ((result & signBitMask) !== 0n) ? 1 : 0;\n                // Parity Flag (PF) is also affected, but you can add that later.\n\n                const rmOperandStr = rmOperand.type === 'reg' ? rmOperand.name.toUpperCase() : `[0x${rmOperand.address.toString(16)}]`;\n                utils.log(`Decoded: TEST ${rmOperandStr}, ${regOpName.toUpperCase()}`);\n                return true;\n            }\n\n            // TEST AL, imm8 (0xA8)\n            if (opcode === 0xA8) {\n                const imm8 = this.readSignedImmediate(1);\n                const alValue = this.readRegister('al', 1);\n                const result = alValue & imm8;\n\n                // TEST instruction updates flags but does not store the result.\n                // It performs a bitwise AND and sets flags based on the outcome.\n                this.flags.cf = 0; // Cleared by TEST\n                this.flags.of = 0; // Cleared by TEST\n\n                this.flags.zf = (result === 0n) ? 1 : 0;\n                this.flags.sf = ((result & 0x80n) !== 0n) ? 1 : 0;\n                // Note: Parity Flag (PF) is also affected but not implemented here.\n\n                utils.log(`Decoded: TEST AL, 0x${imm8.toString(16)} (Result for flags: 0x${result.toString(16)})`);\n                return true;\n            }\n\n            // TEST AX/EAX/RAX, imm16/imm32 (0xA9)\n            if (opcode === 0xA9) {\n                let sizeBytes = defaultOperandSize;\n\n                // Determine the size of the immediate value. \n                // For 64-bit operations, the immediate is a 32-bit value.\n                const immediateSizeBytes = (sizeBytes === 8) ? 4 : sizeBytes;\n                const immediateValue = this.readSignedImmediate(immediateSizeBytes);\n                \n                const regName = this.getRegisterString(0, sizeBytes, rexPrefix !== 0); // Accumulator (AX/EAX/RAX)\n                const regValue = this.readRegister(regName, sizeBytes);\n\n                const result = regValue & immediateValue;\n\n                // TEST updates flags and discards the result.\n                this.flags.cf = 0;\n                this.flags.of = 0;\n\n                this.flags.zf = (result === 0n) ? 1 : 0;\n                \n                // Set Sign Flag if the most significant bit of the result is 1.\n                const signBitMask = 1n << (BigInt(sizeBytes * 8) - 1n);\n                this.flags.sf = ((result & signBitMask) !== 0n) ? 1 : 0;\n                // Note: Parity Flag (PF) is also affected but not implemented here.\n\n                utils.log(`Decoded: TEST ${regName.toUpperCase()}, 0x${immediateValue.toString(16)} (Result for flags: 0x${result.toString(16)})`);\n                return true;\n            }\n\n            // Group 2 Immediate Instructions (ROL, ROR, RCL, RCR, SHL, SHR, SAR)\n            if (opcode === 0xC0 || opcode === 0xC1) {\n                const modrm = this.readModRMByte();\n                const wBit = opcode & 0x01;\n                let sizeBytes = (wBit === 0) ? 1 : defaultOperandSize;\n                \n                const rmOperand = this.resolveModRMOperand(modrm, sizeBytes, rex_x, rex_b, rexPrefix !== 0);\n                const shiftCount = this.readSignedImmediate(1); // imm8\n\n                // Read the value to be shifted\n                let value;\n                if (rmOperand.type === 'reg') {\n                    value = this.readRegister(rmOperand.name, sizeBytes);\n                } else {\n                    // Read from memory\n                    if (sizeBytes === 1) value = BigInt(this.readVirtualUint8(rmOperand.address));\n                    else if (sizeBytes === 2) value = BigInt(this.readVirtualUint16(rmOperand.address));\n                    else if (sizeBytes === 4) value = BigInt(this.readVirtualUint32(rmOperand.address));\n                    else value = this.readVirtualBigUint64(rmOperand.address);\n                }\n\n                let result;\n                let mnemonic = \"UNKNOWN_SHIFT\";\n\n                // The 'reg' field of ModR/M acts as an opcode extension here\n                switch (modrm.reg) {\n                    case 4: // SHL\n                        mnemonic = \"SHL\";\n                        result = value << shiftCount;\n                        // TODO: Set CF and OF correctly for SHL\n                        break;\n                    case 5: // SHR\n                        mnemonic = \"SHR\";\n                        result = value >> shiftCount;\n                        // TODO: Set CF and OF correctly for SHR\n                        break;\n                    // Add other shifts like SAR (case 7) here\n                    default:\n                        throw new Error(`Unhandled Group 2 instruction with /reg=${modrm.reg}`);\n                }\n\n                // Update flags (simplified for now)\n                this.flags.zf = (result === 0n) ? 1 : 0;\n                // SF update needs to consider the size\n                const bitWidth = BigInt(sizeBytes * 8);\n                const signBitMask = 1n << (bitWidth - 1n);\n                this.flags.sf = ((result & signBitMask) !== 0n) ? 1 : 0;\n\n                // Write the result back\n                if (rmOperand.type === 'reg') {\n                    this.writeRegister(rmOperand.name, result, sizeBytes);\n                } else {\n                    // Write to memory\n                    if (sizeBytes === 1) this.writeVirtualUint8(rmOperand.address, Number(result));\n                    else if (sizeBytes === 2) this.writeVirtualUint16(rmOperand.address, Number(result));\n                    else if (sizeBytes === 4) this.writeVirtualUint32(rmOperand.address, Number(result));\n                    else this.writeVirtualBigUint64(rmOperand.address, result);\n                }\n\n                const rmOperandStr = rmOperand.type === 'reg' ? rmOperand.name.toUpperCase() : `[0x${rmOperand.address.toString(16)}]`;\n                utils.log(`Decoded: ${mnemonic} ${rmOperandStr}, ${shiftCount}`);\n                return true;\n            }\n\n            // JL rel8 (0x7C)\n            if (opcode === 0x7C) {\n                const displacement = this.readSignedImmediate(1);\n                utils.log(`Decoded: JL rel8 0x${displacement.toString(16)}`);\n                if (this.flags.sf !== this.flags.of) { // Condition for JL\n                    this.rip += displacement;\n                    utils.log(`  Condition Met (SF!=OF). Jumping to 0x${this.rip.toString(16)}`);\n                } else {\n                    utils.log(`  Condition Not Met. Not jumping.`);\n                }\n                return true;\n            }\n\n            // JB rel8 (0x72)\n            if (opcode === 0x72) {\n                const displacement = this.readSignedImmediate(1);\n                utils.log(`Decoded: JB rel8 0x${displacement.toString(16)}`);\n                if (this.flags.cf !== 0) { // Condition for JB\n                    this.rip += displacement;\n                    utils.log(`  Condition Met (CF!=0). Jumping to 0x${this.rip.toString(16)}`);\n                } else {\n                    utils.log(`  Condition Not Met. Not jumping.`);\n                }\n                return true;\n            }\n\n            // JMP rel8 (0xEB)\n            if (opcode === 0xEB) {\n                // Read the 8-bit signed relative displacement\n                const displacement = this.readSignedImmediate(1);\n                \n                // Add the displacement to the current RIP to perform the jump\n                this.rip += displacement;\n                \n                utils.log(`Decoded: JMP rel8 0x${displacement.toString(16)} (Jumping to 0x${this.rip.toString(16)})`);\n                return true;\n            }\n\n            // IRETQ (0xCF)\n            if (opcode === 0xCF) {\n                // Pop the interrupt number we pushed\n                const interruptNumber = Number(this.readVirtualBigUint64(this.rsp));\n                this.rsp += 8n;\n\n                // Page Faults (#8, #10-14, #17) push an error code.\n                const hasErrorCode = [8, 10, 11, 12, 13, 14, 17].includes(interruptNumber);\n                if (hasErrorCode) {\n                    this.rsp += 8n; // Discard the error code\n                }\n\n                // Now pop the standard frame\n                this.rip = this.readVirtualBigUint64(this.rsp);\n                this.rsp += 8n;\n                \n                const new_cs = this.readVirtualBigUint64(this.rsp);\n                this.rsp += 8n;\n                \n                const new_rflags = this.readVirtualBigUint64(this.rsp);\n                this.disassembleRFlags(new_rflags);\n                this.rsp += 8n;\n                \n                utils.log(`Decoded: IRETQ from INT #${interruptNumber} (Returning to 0x${this.rip.toString(16)})`);\n                return true;\n            }\n\n            // OUT DX, AL (0xEE)\n            if (opcode === 0xEE) {\n                // The port number is read from the 16-bit DX register\n                const port = this.readRegister('dx', 2);\n                const value = this.readRegister('al', 1);\n                \n                this.io.portOut(Number(port), Number(value), 1); // size is 1 byte\n                \n                utils.log(`Decoded: OUT DX, AL (Wrote 0x${value.toString(16)} to port 0x${port.toString(16)})`);\n                return true;\n            }\n\n            // OUT imm8, AL (0xE6)\n            if (opcode === 0xE6) {\n                const port = this.readInstructionByte(); // Read the port number from the instruction\n                const value = this.readRegister('al', 1); // Get the value from the AL register\n                \n                this.io.portOut(port, Number(value), 1); // Send the data to the I/O bus\n\n                utils.log(`Decoded: OUT imm8, AL (Wrote 0x${value.toString(16)} to port 0x${port.toString(16)})`);\n                return true;\n            }\n\n            // LODSB (0xAC)\n            if (opcode === 0xAC) {\n                // 1. Read the byte from memory at [RSI]\n                const value = this.readVirtualUint8(this.rsi);\n                \n                // 2. Put that byte into AL\n                this.writeRegister('al', value, 1);\n                \n                // 3. Increment RSI by 1\n                // (Note: A full implementation would check the Direction Flag (DF),\n                // but the default is to increment, which is all we need here).\n                this.rsi += 1n;\n    \n                utils.log(`Decoded: LODSB (Loaded 0x${value.toString(16)} into AL, RSI is now 0x${this.rsi.toString(16)})`);\n                return true;\n            }\n\n            // IN AL, imm8 (0xE4)\n            if (opcode === 0xE4) {\n                const port = this.readInstructionByte(); // Read 8-bit port from instruction\n                const value = this.io.portIn(port, 1);   // Read 1 byte from the I/O bus\n                this.writeRegister('al', value, 1);      // Write the value to AL\n\n                utils.log(`Decoded: IN AL, imm8 (Read 0x${value.toString(16)} from port 0x${port.toString(16)} into AL)`);\n                return true;\n            }\n\n            // IN AL, DX (0xEC)\n            if (opcode === 0xEC) {\n                const port = this.readRegister('dx', 2);   // Read 16-bit port from DX\n                const value = this.io.portIn(Number(port), 1); // Read 1 byte from the I/O bus\n                this.writeRegister('al', value, 1);        // Write the value to AL\n\n                utils.log(`Decoded: IN AL, DX (Read 0x${value.toString(16)} from port 0x${port.toString(16)} into AL)`);\n                return true;\n            }\n\n            // INC r/m (0xFE /0 for byte, 0xFF /0 for word/dword/qword)\n            if (opcode === 0xFE || opcode === 0xFF) {\n                const modrm = this.readModRMByte();\n                \n                // This instruction is selected when the /reg field of the ModR/M byte is 0.\n                if (modrm.reg === 0) {\n                    const wBit = opcode & 0x01;\n                    // Opcode 0xFE is always 1 byte.\n                    // Opcode 0xFF uses defaultOperandSize (word, dword, or qword).\n                    let sizeBytes = (wBit === 0) ? 1 : defaultOperandSize;\n\n                    const rmOperand = this.resolveModRMOperand(modrm, sizeBytes, rex_r, rex_b, rex_x, rexPrefix !== 0);\n                    \n                    let value;\n                    // Read the current value from the register or memory\n                    if (rmOperand.type === 'reg') {\n                        value = this.readRegister(rmOperand.name, sizeBytes);\n                    } else {\n                        if (sizeBytes === 1) value = BigInt(this.readVirtualUint8(rmOperand.address));\n                        else if (sizeBytes === 2) value = BigInt(this.readVirtualUint16(rmOperand.address));\n                        else if (sizeBytes === 4) value = BigInt(this.readVirtualUint32(rmOperand.address));\n                        else value = this.readVirtualBigUint64(rmOperand.address);\n                    }\n\n                    const result = value + 1n;\n\n                    // --- Correct Flag Calculation for INC ---\n                    // IMPORTANT: INC does NOT affect the Carry Flag (CF).\n                    // It affects OF, SF, ZF, AF, PF.\n                    const originalCF = this.flags.cf; // Preserve the original Carry Flag\n\n                    // We can use our existing function, but for a fake 'add' of 1\n                    this.updateArithmeticFlags(result, value, 1n, sizeBytes, 'add');\n\n                    this.flags.cf = originalCF; // Restore the Carry Flag\n                    // --- End Flag Calculation ---\n                    \n                    // Write the result back\n                    if (rmOperand.type === 'reg') {\n                        this.writeRegister(rmOperand.name, result, sizeBytes);\n                    } else {\n                        if (sizeBytes === 1) this.writeVirtualUint8(rmOperand.address, Number(result));\n                        else if (sizeBytes === 2) this.writeVirtualUint16(rmOperand.address, Number(result));\n                        else if (sizeBytes === 4) this.writeVirtualUint32(rmOperand.address, Number(result));\n                        else this.writeVirtualBigUint64(rmOperand.address, result);\n                    }\n                    \n                    const operandStr = rmOperand.type === 'reg' ? rmOperand.name.toUpperCase() : `[0x${rmOperand.address.toString(16)}]`;\n                    utils.log(`Decoded: INC ${operandStr}`);\n                    return true;\n                }\n            }\n\n            // STI (Set Interrupt Flag)\n            if (opcode === 0xFB) {\n                this.flags.if = 1;\n                utils.log(\"Decoded: STI\");\n                return true;\n            }\n\n            // CLI (Clear Interrupt Flag)\n            if (opcode === 0xFA) {\n                this.flags.if = 0;\n                utils.log(\"Decoded: CLI\");\n                return true;\n            }\n\n            // JMP ptr16:16 (Far Jump) - Opcode 0xEA\n            if (opcode === 0xEA) {\n                // This instruction is special. In the 16-bit boot stub, the assembler\n                // always generates a 16-bit offset and a 16-bit selector.\n                // We will hardcode the handler to read these sizes to match the\n                // machine code, ignoring defaultOperandSize for this specific opcode.\n                \n                // We must use physical reads because paging is not yet effective\n                // for the instruction stream itself.\n                const offset = this.memory.readUint16(Number(this.rip));\n                this.rip += 2n;\n\n                const new_cs = this.memory.readUint16(Number(this.rip));\n                this.rip += 2n;\n\n                // Set the new segment and instruction pointer\n                this.cs = BigInt(new_cs);\n                this.rip = BigInt(offset);\n                \n                // Re-evaluating the CPU mode here is good practice after loading CS.\n                this.updateCPUMode();\n                \n                utils.log(`Decoded: JMP far 0x${new_cs.toString(16)}:0x${offset.toString(16)}`);\n                return true;\n            }\n\n            // If an instruction falls through all specific handlers, it's truly unknown\n            utils.log(`Unknown opcode: 0x${(twoByteOpcode ? '0F ' : '')}${opcode.toString(16)} at 0x${currentRIPBeforeFetch.toString(16)}`); // Use currentRIPBeforeFetch for unknown opcodes\n            return false;\n        } catch (e) {\n            if (e instanceof PageFaultException) {\n                console.warn(`--- Caught Page Fault at RIP 0x${currentRIPBeforeFetch.toString(16)}. Invoking handler. ---`);\n                this.rip = currentRIPBeforeFetch; // IMPORTANT: Restore RIP to the address of the *faulting* instruction\n                this.triggerInterrupt(14, e.errorCode);\n            } else {\n                console.error(`Fatal error during execution at RIP 0x${currentRIPBeforeFetch.toString(16)}:`, e);\n                throw e;\n            }\n        }\n        return true;\n    }\n\n    readInstructionByte() {\n        let byte;\n        // Instruction fetches (RIP-relative access) depend on current mode and paging state\n        // If Protected Mode (CR0.PE) is enabled, all accesses are virtual from instruction stream's perspective.\n        // The translateVirtualToPhysical will handle the specific paging checks (PG, PAE, LME).\n        if ((this.cr0 & CPU.CR0_PE) !== 0n) { \n            byte = this.readVirtualUint8(this.rip);\n        } else { // Real Mode\n            byte = this.memory.readUint8(Number(this.rip));\n        }\n        this.rip++;\n        return byte;\n    }\n\n    readInstructionUint16() {\n        const lo = this.readInstructionByte();\n        const hi = this.readInstructionByte();\n        return (hi << 8) | lo;\n    }\n\n    readInstructionUint32() {\n        const b1 = this.readInstructionByte();\n        const b2 = this.readInstructionByte();\n        const b3 = this.readInstructionByte();\n        const b4 = this.readInstructionByte();\n        return (b4 << 24) | (b3 << 16) | (b2 << 8) | b1;\n    }\n\n    readModRMByte() {\n        // ModR/M byte is also part of the instruction stream, so it should use readInstructionByte logic\n        // This ensures it correctly reads from virtual or physical memory.\n        const modrm = this.readInstructionByte(); \n        const mod = (modrm >>> 6) & 0x03;\n        const reg = (modrm >>> 3) & 0x07;\n        const rm = modrm & 0x07;\n        return { mod, reg, rm, raw: modrm };\n    }\n\n    getRegisterString(regIndex, sizeBytes, hasRexPrefix = false) {\n        const regNames64 = ['rax', 'rcx', 'rdx', 'rbx', 'rsp', 'rbp', 'rsi', 'rdi', 'r8', 'r9', 'r10', 'r11', 'r12', 'r13', 'r14', 'r15'];\n        const regNames32 = ['eax', 'ecx', 'edx', 'ebx', 'esp', 'ebp', 'esi', 'edi', 'r8d', 'r9d', 'r10d', 'r11d', 'r12d', 'r13d', 'r14d', 'r15d'];\n        const regNames16 = ['ax', 'cx', 'dx', 'bx', 'sp', 'bp', 'si', 'di', 'r8w', 'r9w', 'r10w', 'r11w', 'r12w', 'r13w', 'r14w', 'r15w'];\n        \n        // Arrays for 8-bit register naming based on REX prefix presence\n        const regNames8Low = ['al', 'cl', 'dl', 'bl']; // Indices 0-3 (always same)\n        const regNames8HighNoRex = ['ah', 'ch', 'dh', 'bh']; // Indices 4-7 (if NO REX prefix)\n        const regNames8NewRex = ['spl', 'bpl', 'sil', 'dil']; // Indices 4-7 (if REX prefix IS present)\n        const regNames8Extended = ['r8b', 'r9b', 'r10b', 'r11b', 'r12b', 'r13b', 'r14b', 'r15b']; // Indices 8-15 (always used with REX)\n\n        if (regIndex < 0 || regIndex > 15) {\n            throw new Error(`Invalid register index: ${regIndex}`);\n        }\n\n        switch (sizeBytes) {\n            case 1:\n                if (regIndex >= 8) { // Registers R8B-R15B (always require REX to be accessed by these names)\n                    return regNames8Extended[regIndex - 8];\n                } else if (regIndex >= 4) { // Registers AX/CX/DX/BX's high byte or SPL/BPL/SIL/DIL\n                    if (hasRexPrefix) {\n                        return regNames8NewRex[regIndex - 4];\n                    } else {\n                        return regNames8HighNoRex[regIndex - 4];\n                    }\n                } else { // Registers AL/CL/DL/BL\n                    return regNames8Low[regIndex];\n                }\n            case 2: return regNames16[regIndex];\n            case 4: return regNames32[regIndex];\n            case 8: return regNames64[regIndex];\n            default: throw new Error(`Invalid register size for naming: ${sizeBytes}`);\n        }\n    }\n\n    readSignedImmediate(sizeBytes) {\n        let rawValue;\n        if (sizeBytes === 1) {\n            rawValue = this.readInstructionByte();\n            if (rawValue & 0x80) return BigInt(rawValue - 0x100);\n            return BigInt(rawValue);\n        }\n        if (sizeBytes === 2) {\n            rawValue = this.readInstructionUint16();\n            if (rawValue & 0x8000) return BigInt(rawValue - 0x10000);\n            return BigInt(rawValue);\n        }\n        if (sizeBytes === 4) {\n            rawValue = this.readInstructionUint32();\n            if (rawValue & 0x80000000) return BigInt(rawValue - 0x100000000);\n            return BigInt(rawValue);\n        }\n        // For 64-bit, we need a 64-bit reader\n        const lo = this.readInstructionUint32();\n        const hi = this.readInstructionUint32();\n        return (BigInt(hi) << 32n) | BigInt(lo);\n    }\n\n    readSIBByte(mod) {\n        const sib = this.readInstructionByte();\n        const scaleBits = (sib >>> 6) & 0x03;\n        const indexBits = (sib >>> 3) & 0x07;\n        const baseBits = sib & 0x07;\n\n        // Scale is either 1, 2, 4, or 8\n        const scale = 1 << scaleBits;\n\n        const idxRegName = this.getRegisterString(indexBits, 8, false);\n        const baseRegName = this.getRegisterString(baseBits, 8, false);\n\n        let baseValue = 0n;\n\n        // Special case: if base is RBP/EBP and mod is 00, there is no base register\n        if (!(baseBits === 5 && mod === 0)) {\n            baseValue = this.readRegister(baseRegName, 8);\n        }\n\n        let indexValue = 0n;\n       // Special case: if index is RSP, there is no index register\n        if (indexBits !== 4) {\n            indexValue = this.readRegister(idxRegName, 8);\n        }\n\n        const addr = baseValue + (indexValue * BigInt(scale));\n        utils.log(`  SIB Decoded: Base=${baseRegName}, Index=${idxRegName}, Scale=${scale} => Address component = 0x${addr.toString(16)}`);\n        return addr;\n    }\n\n    resolveModRMOperand(modrm, sizeBytes, rex_x, rex_b, hasRexPrefixForNaming) {\n        if (modrm.mod === 0x03) {\n            const rmIndex = modrm.rm + (rex_b << 3);\n            return { type: 'reg', name: this.getRegisterString(rmIndex, sizeBytes, hasRexPrefixForNaming) };\n        }\n\n        let effectiveAddress = 0n;\n        let displacement = 0n;\n        const sibPresent = (modrm.rm === 0x04);\n\n        // --- Step 1: Calculate Base + Index*Scale ---\n        if (sibPresent) {\n            const sib = this.readInstructionByte();\n            const scale = 1 << ((sib >>> 6) & 0x03);\n            const indexBits = ((sib >>> 3) & 0x07) + (rex_x << 3);\n            const baseBits = (sib & 0x07) + (rex_b << 3);\n\n            // Add Index * Scale (if index is not RSP)\n            if (indexBits !== 4) {\n                const indexRegName = this.getRegisterString(indexBits, 8, true);\n                effectiveAddress += this.readRegister(indexRegName, 8) * BigInt(scale);\n            }\n\n            // Add Base register. The special disp32-only case is handled below.\n            if (modrm.mod !== 0x00 || baseBits !== 5) {\n                const baseRegName = this.getRegisterString(baseBits, 8, true);\n                effectiveAddress += this.readRegister(baseRegName, 8);\n            }\n\n        } else if (modrm.rm === 0x05) {\n            // RIP-relative addressing is a disp32 added to the *next* RIP\n            effectiveAddress = this.rip; // Base for calculation is the RIP after this instruction\n        } else {\n            // Simple [reg] base\n            const baseRegIndex = modrm.rm + (rex_b << 3);\n            const baseRegName = this.getRegisterString(baseRegIndex, 8, true);\n            effectiveAddress = this.readRegister(baseRegName, 8);\n        }\n\n        // --- Step 2: Add Displacement based on ModR/M.mod ---\n        if (modrm.mod === 0x01) {\n            displacement = this.readSignedImmediate(1); // disp8\n            effectiveAddress += displacement;\n        } else if (modrm.mod === 0x02) {\n            displacement = this.readSignedImmediate(4); // disp32\n            effectiveAddress += displacement;\n        } else if (modrm.mod === 0x00) {\n            // THIS IS THE CRITICAL FIX\n            // Check for disp32 cases that exist even when mod is 00.\n            // Case 1: [RIP + disp32] (ModR/M.r/m = 5)\n            // Case 2: [SIB + disp32] (SIB.base = 5)\n            const sibBaseIsRBP = sibPresent && ((this.memory.readUint8(Number(this.rip - 1n)) & 0x07) === 5);\n            if ((!sibPresent && modrm.rm === 5) || sibBaseIsRBP) {\n                displacement = this.readSignedImmediate(4);\n                effectiveAddress += displacement;\n            }\n        }\n\n        return { type: 'mem', address: effectiveAddress, sizeBytes: sizeBytes };\n    }\n\n    updateCPUMode() {\n        const peBit = (this.cr0 & CPU.CR0_PE) !== 0n;       \n        const pgBit = (this.cr0 & CPU.CR0_PG) !== 0n; \n        const paeBit = (this.cr4 & CPU.CR4_PAE) !== 0n; \n        const lmeBit = (this.efer & CPU.EFER_LME) !== 0n; \n\n        // --- NEW DEBUGGING LOGS ---\n        utils.log(`\\n--- DEBUG: updateCPUMode called ---`);\n        utils.log(`  Current CR0:  0x${this.cr0.toString(16).padStart(16, '0')} (PE: ${peBit}, PG: ${pgBit})`);\n        utils.log(`  Current CR4:  0x${this.cr4.toString(16).padStart(16, '0')} (PAE: ${paeBit})`);\n        utils.log(`  Current EFER: 0x${this.efer.toString(16).padStart(16, '0')} (LME: ${lmeBit})`);\n        utils.log(`  Combined Condition (LME && PAE && PG): ${lmeBit && paeBit && pgBit}`);\n        // --- END DEBUGGING LOGS ---\n    \n        if (!peBit) {\n            this.mode = 'real';\n        } else { \n            if (lmeBit && paeBit && pgBit) { \n                this.mode = 'long';\n                utils.log(\"CPU Mode: Long Mode (64-bit) enabled.\");\n            } else if (pgBit && paeBit) { \n                this.mode = 'protected_pae'; \n                utils.log(\"CPU Mode: Protected Mode (32-bit) with PAE enabled.\");\n            } else if (pgBit) {\n                this.mode = 'protected_32bit_paging'; \n                utils.log(\"CPU Mode: Protected Mode (32-bit) with Paging enabled.\");\n            } else {\n                this.mode = 'protected'; \n                utils.log(\"CPU Mode: Protected Mode (32-bit) enabled (no paging).\");\n            }\n        }\n        utils.log(`DEBUG: updateCPUMode - Mode finalized as: ${this.mode}\\n`);\n    }\n\n    readVirtualUint8(virtualAddr) {\n        const physicalAddr = this.translateVirtualToPhysical(virtualAddr, 1, 'read');\n        // Add bounds check for physical memory to catch issues *before* DataView throws\n        if (physicalAddr < 0n || physicalAddr >= BigInt(this.memory.buffer.byteLength)) {\n            console.error(`Attempt to read physical address 0x${physicalAddr.toString(16)} outside memory bounds (0x0 to 0x${BigInt(this.memory.buffer.byteLength).toString(16)}).`);\n            throw new Error(`MEMORY_ACCESS_VIOLATION: Read from physical address 0x${physicalAddr.toString(16)}`);\n        }\n        return this.memory.readUint8(Number(physicalAddr));\n    }\n\n    writeVirtualUint8(virtualAddr, value) {\n        const physicalAddr = this.translateVirtualToPhysical(virtualAddr, 1, 'write');\n        if (physicalAddr < 0n || physicalAddr >= BigInt(this.memory.buffer.byteLength)) {\n            console.error(`Attempt to write physical address 0x${physicalAddr.toString(16)} outside memory bounds (0x0 to 0x${BigInt(this.memory.buffer.byteLength).toString(16)}).`);\n            throw new Error(`MEMORY_ACCESS_VIOLATION: Write to physical address 0x${physicalAddr.toString(16)}`);\n        }\n        this.memory.writeUint8(Number(physicalAddr), value);\n    }\n\n    readVirtualUint16(virtualAddr) {\n        const physicalAddr = this.translateVirtualToPhysical(virtualAddr, 2, 'read');\n        if (physicalAddr < 0n || physicalAddr + 1n >= BigInt(this.memory.buffer.byteLength)) { // +1n for 2-byte read\n            console.error(`Attempt to read physical address 0x${physicalAddr.toString(16)} outside memory bounds.`);\n            throw new Error(`MEMORY_ACCESS_VIOLATION: Read from physical address 0x${physicalAddr.toString(16)}`);\n        }\n        return this.memory.readUint16(Number(physicalAddr));\n    }\n\n    writeVirtualUint16(virtualAddr, value) {\n        const physicalAddr = this.translateVirtualToPhysical(virtualAddr, 2, 'write');\n        if (physicalAddr < 0n || physicalAddr + 1n >= BigInt(this.memory.buffer.byteLength)) { // +1n for 2-byte write\n            console.error(`Attempt to write physical address 0x${physicalAddr.toString(16)} outside memory bounds.`);\n            throw new Error(`MEMORY_ACCESS_VIOLATION: Write to physical address 0x${physicalAddr.toString(16)}`);\n        }\n        this.memory.writeUint16(Number(physicalAddr), value);\n    }\n\n    readVirtualUint32(virtualAddr) {\n        const physicalAddr = this.translateVirtualToPhysical(virtualAddr, 4, 'read');\n        if (physicalAddr < 0n || physicalAddr + 3n >= BigInt(this.memory.buffer.byteLength)) { // +3n for 4-byte read\n            console.error(`Attempt to read physical address 0x${physicalAddr.toString(16)} outside memory bounds.`);\n            throw new Error(`MEMORY_ACCESS_VIOLATION: Read from physical address 0x${physicalAddr.toString(16)}`);\n        }\n        return this.memory.readUint32(Number(physicalAddr));\n    }\n\n    writeVirtualUint32(virtualAddr, value) {\n        const physicalAddr = this.translateVirtualToPhysical(virtualAddr, 4, 'write');\n        if (physicalAddr < 0n || physicalAddr + 3n >= BigInt(this.memory.buffer.byteLength)) { // +3n for 4-byte write\n            console.error(`Attempt to write physical address 0x${physicalAddr.toString(16)} outside memory bounds.`);\n            throw new Error(`MEMORY_ACCESS_VIOLATION: Write to physical address 0x${physicalAddr.toString(16)}`);\n        }\n        this.memory.writeUint32(Number(physicalAddr), value);\n    }\n\n    readVirtualBigUint64(virtualAddr) {\n        const physicalAddr = this.translateVirtualToPhysical(virtualAddr, 8, 'read');\n        if (physicalAddr < 0n || physicalAddr + 7n >= BigInt(this.memory.buffer.byteLength)) { // +7n for 8-byte read\n            console.error(`Attempt to read physical address 0x${physicalAddr.toString(16)} outside memory bounds.`);\n            throw new Error(`MEMORY_ACCESS_VIOLATION: Read from physical address 0x${physicalAddr.toString(16)}`);\n        }\n        return this.memory.readBigUint64(Number(physicalAddr)); \n    }\n\n    writeVirtualBigUint64(virtualAddr, value) {\n        const physicalAddr = this.translateVirtualToPhysical(virtualAddr, 8, 'write');\n        if (physicalAddr < 0n || physicalAddr + 7n >= BigInt(this.memory.buffer.byteLength)) { // +7n for 8-byte write\n            console.error(`Attempt to write physical address 0x${physicalAddr.toString(16)} outside memory bounds.`);\n            throw new Error(`MEMORY_ACCESS_VIOLATION: Write to physical address 0x${physicalAddr.toString(16)}`);\n        }\n        this.memory.writeBigUint64(Number(physicalAddr), value); \n    }\n\n    translateVirtualToPhysical(virtualAddr, sizeBytes, accessType) {\n        if (this.mode === 'real') {\n            return virtualAddr;\n        }\n\n        const pgBit = (this.cr0 & CPU.CR0_PG) !== 0n;\n        const paeBit = (this.cr4 & CPU.CR4_PAE) !== 0n;\n        const lmeBit = (this.efer & CPU.EFER_LME) !== 0n;\n\n        // This guard determines when the full 4-level paging logic is active.\n        if (this.mode !== 'long' || !pgBit || !paeBit || !lmeBit) {\n            console.warn(`Paging not fully enabled for Long Mode. Current mode: ${this.mode}. CR0.PG=${pgBit}, CR4.PAE=${paeBit}, EFER.LME=${lmeBit}. Returning virtual as physical.`);\n            return virtualAddr; // Pass through if paging is not fully active\n        }\n\n        // --- Paging Enabled for Long Mode (the real work begins here) ---\n        utils.log(`Paging: Translating virtual address 0x${virtualAddr.toString(16)} in ${this.mode} mode.`);\n\n        const pml4BasePhys = this.cr3 & ~0xFFFn;\n        utils.log(`  PML4 Base Phys: 0x${pml4BasePhys.toString(16).padStart(16, '0')}`); \n\n        const pml4Index = (virtualAddr >> 39n) & 0x1FFn; \n        let pml4eAddr = pml4BasePhys + (pml4Index * 8n); \n        utils.log(`  PML4E Addr: 0x${pml4eAddr.toString(16).padStart(16, '0')} (Index: ${pml4Index})`);\n        let pml4e = this.memory.readBigUint64(Number(pml4eAddr));\n        utils.log(`  PML4E Value: 0x${pml4e.toString(16).padStart(16, '0')}`);\n\n        if ((pml4e & CPU.PTE_PRESENT) === 0n) {\n            console.error(`Page Fault (#PF): PML4E not present for VA 0x${virtualAddr.toString(16)}`);\n            throw new PageFaultException(`PML4E not present`, 0n);\n        }        \n\n        let pdptBasePhys = pml4e & ~0xFFFn;\n        utils.log(`  PDPT Base Phys: 0x${pdptBasePhys.toString(16).padStart(16, '0')}`); \n        const pdptIndex = (virtualAddr >> 30n) & 0x1FFn; \n        let pdpteAddr = pdptBasePhys + (pdptIndex * 8n); \n        utils.log(`  PDPTE Addr: 0x${pdpteAddr.toString(16).padStart(16, '0')} (Index: ${pdptIndex})`);\n        let pdpte = this.memory.readBigUint64(Number(pdpteAddr));\n        utils.log(`  PDPTE Value: 0x${pdpte.toString(16).padStart(16, '0')}`);\n\n        if ((pdpte & CPU.PTE_PRESENT) === 0n) {\n            console.error(`Page Fault (#PF): PDPTE not present for VA 0x${virtualAddr.toString(16)}`);\n            throw new PageFaultException(`PDPTE not present`, 0n);\n        }\n\n        if ((pdpte & CPU.PTE_PAGE_SIZE) !== 0n) { // 1GB page\n            const pageBaseAddr = pdpte & 0xFFFFFFFC0000000n; \n            const offset = virtualAddr & 0x3FFFFFFFfn; \n            const physical = pageBaseAddr | offset;\n            utils.log(`  Translated 1GB page: VA 0x${virtualAddr.toString(16)} -> PA 0x${physical.toString(16)}`);\n            return physical;\n        }\n\n        let pdBasePhys = pdpte & ~0xFFFn;\n        utils.log(`  PD Base Phys: 0x${pdBasePhys.toString(16).padStart(16, '0')}`); \n        const pdIndex = (virtualAddr >> 21n) & 0x1FFn; \n        let pdeAddr = pdBasePhys + (pdIndex * 8n); \n        utils.log(`  PDE Addr: 0x${pdeAddr.toString(16).padStart(16, '0')} (Index: ${pdIndex})`);\n        let pde = this.memory.readBigUint64(Number(pdeAddr));\n        utils.log(`  PDE Value: 0x${pde.toString(16).padStart(16, '0')}`);\n\n        if ((pde & CPU.PTE_PRESENT) === 0n) {\n            console.error(`Page Fault (#PF): PDE not present for VA 0x${virtualAddr.toString(16)}`);\n            throw new PageFaultException(`PDE not present`, 0n);\n        }\n\n        if ((pde & CPU.PTE_PAGE_SIZE) !== 0n) { // 2MB page\n            const pageBaseAddr = pde & 0xFFFFFFFE00000n; \n            const offset = virtualAddr & 0x1FFFFFn; \n            const physical = pageBaseAddr | offset;\n            utils.log(`  Translated 2MB page: VA 0x${virtualAddr.toString(16)} -> PA 0x${physical.toString(16)}`);\n            return physical;\n        }\n\n        let ptBasePhys = pde & ~0xFFFn;\n        utils.log(`  PT Base Phys: 0x${ptBasePhys.toString(16).padStart(16, '0')}`); \n        const ptIndex = (virtualAddr >> 12n) & 0x1FFn; \n        let pteAddr = ptBasePhys + (ptIndex * 8n); \n        utils.log(`  PTE Addr: 0x${pteAddr.toString(16).padStart(16, '0')} (Index: ${ptIndex})`);\n        let pte = this.memory.readBigUint64(Number(pteAddr));\n        utils.log(`  PTE Value: 0x${pte.toString(16).padStart(16, '0')}`);\n\n        if ((pte & CPU.PTE_PRESENT) === 0n) {\n            console.error(`Page Fault (#PF): PTE not present for VA 0x${virtualAddr.toString(16)}`);\n            throw new PageFaultException(`PTE not present`, 0n);\n        }\n\n        if (accessType === 'write' && (pte & CPU.PTE_READ_WRITE) === 0n) {\n            // The page is present but read-only. This is a page fault.\n            // The error code for a protection violation has bit 0 set.\n            throw new PageFaultException(`Protection Violation on write to VA 0x${virtualAddr.toString(16)}`, 1n);\n        }\n\n        const pageBaseAddr = pte & ~0xFFFn; \n        const offset = virtualAddr & 0xFFFn; \n        const physical = pageBaseAddr | offset;\n        utils.log(`  Final Page Base Addr: 0x${pageBaseAddr.toString(16).padStart(16, '0')}`);\n        utils.log(`  Page Offset: 0x${offset.toString(16).padStart(3, '0')}`);\n        utils.log(`  Calculated Physical: 0x${physical.toString(16).padStart(16, '0')}`);\n\n        return physical;\n    }\n\n    triggerInterrupt(interruptNumber, errorCode = null) {\n        utils.log(`--- INTERRUPT TRIGGERED: #${interruptNumber} ---`);\n\n        const descriptorAddr = this.idtr.base + BigInt(interruptNumber * 16);\n\n        utils.log(`  IDTR.base = 0x${this.idtr.base.toString(16)}`);\n        utils.log(`  Interrupt #${interruptNumber} @ 0x${descriptorAddr.toString(16)}`);\n        utils.log(`  Raw bytes: ${[...new Uint8Array(this.memory.buffer.slice(Number(descriptorAddr), Number(descriptorAddr + 16n)))]\n            .map(b => b.toString(16).padStart(2, '0')).join(' ')}`);\n\n        const lowSlice = this.readVirtualBigUint64(descriptorAddr);\n        const highSlice = this.readVirtualBigUint64(descriptorAddr + 8n);\n        utils.log(`DEBUG: Descriptor at 0x${descriptorAddr.toString(16)} is: LOW=0x${lowSlice.toString(16)} HIGH=0x${highSlice.toString(16)}`);\n\n        // === FINAL, CORRECTED PARSING LOGIC v3 ===\n        // This logic correctly decodes the structure created by the assembly code.\n        const offset_15_0  = lowSlice & 0xFFFFn;\n        const offset_31_16 = (lowSlice >> 48n) & 0xFFFFn;\n        const offset_63_32 = highSlice & 0xFFFFFFFFn;\n\n        const handlerAddr = (offset_63_32 << 32n) | (offset_31_16 << 16n) | offset_15_0;\n        // ===========================================\n\n        const segmentSelector = (lowSlice >> 16n) & 0xFFFFn;\n        const type_attrs = (lowSlice >> 40n) & 0xFFn;\n        const present = (type_attrs & 0x80n) !== 0n;\n\n        if (!present) {\n            throw new Error(`Interrupt Handler #${interruptNumber} not present! Double Fault.`);\n        }\n\n        // Push state onto the stack\n        this.rsp -= 8n;\n        this.writeVirtualBigUint64(this.rsp, this.assembleRFlags());\n        this.rsp -= 8n;\n        this.writeVirtualBigUint64(this.rsp, segmentSelector);\n        this.rsp -= 8n;\n        this.writeVirtualBigUint64(this.rsp, this.rip);\n        if (errorCode !== null) {\n            this.rsp -= 8n;\n            this.writeVirtualBigUint64(this.rsp, errorCode);\n        }\n        this.rsp -= 8n;\n        this.writeVirtualBigUint64(this.rsp, BigInt(interruptNumber));\n\n        utils.log(`DEBUG: Parsed handlerAddr = 0x${handlerAddr.toString(16)}`);\n        utils.log(`  offset_15_0  = 0x${offset_15_0.toString(16)}`);\n        utils.log(`  offset_31_16 = 0x${offset_31_16.toString(16)}`);\n        utils.log(`  offset_63_32 = 0x${offset_63_32.toString(16)}`);\n\n        // Jump to the handler\n        this.rip = handlerAddr;\n        \n        utils.log(`  Jumping to handler at 0x${handlerAddr.toString(16)}`);\n    }\n\n    assembleRFlags() {\n        let flags = 0n;\n        if (this.flags.cf) flags |= (1n << CPU.FLAG_CF_BIT);\n        if (this.flags.zf) flags |= (1n << CPU.FLAG_ZF_BIT);\n        if (this.flags.sf) flags |= (1n << CPU.FLAG_SF_BIT);\n        if (this.flags.of) flags |= (1n << CPU.FLAG_OF_BIT);\n        if (this.flags.if) flags |= (1n << CPU.FLAG_IF_BIT);\n        // Always set bit 1 to 1, as per specification\n        flags |= (1n << 1n);\n        return flags;\n    }\n\n    disassembleRFlags(rflagsValue) {\n        this.flags.cf = ((rflagsValue >> CPU.FLAG_CF_BIT) & 1n) === 1n ? 1 : 0;\n        this.flags.zf = ((rflagsValue >> CPU.FLAG_ZF_BIT) & 1n) === 1n ? 1 : 0;\n        this.flags.sf = ((rflagsValue >> CPU.FLAG_SF_BIT) & 1n) === 1n ? 1 : 0;\n        this.flags.of = ((rflagsValue >> CPU.FLAG_OF_BIT) & 1n) === 1n ? 1 : 0;\n        this.flags.if = ((rflagsValue >> CPU.FLAG_IF_BIT) & 1n) === 1n ? 1 : 0;\n    }\n\n    raiseInterrupt(interruptNumber) {\n        // In a real system, this would go through an Interrupt Controller (PIC).\n        // For now, we'll just queue it. We need a queue in case an interrupt\n        // happens while the CPU has interrupts disabled.\n        this.interruptQueue.push(interruptNumber);\n    }\n}"],"names":["_console","console","mode","log","args","Memory","constructor","size","this","buffer","ArrayBuffer","view","DataView","Uint8Array","fill","readUint8","addr","getUint8","readUint16","getUint16","readUint32","getUint32","readBigUint64","getBigUint64","writeUint8","value","setUint8","Number","writeUint16","setUint16","writeUint32","setUint32","writeBigUint64","setBigUint64","load","data","sourceUint8Array","mainBufferView","byteLength","Error","toString","set","IOManager","devices","Map","registerDevice","ports","device","portArray","Array","isArray","port","name","portIn","get","portOut","PageFaultException","message","errorCode","super","CPU","static","setupIdentityPaging","memory","virtualStart","physicalStart","sizeBytes","pageTableBasePhysAddr","PAGE_SIZE","numPages","currentTableAddr","pml4TablePhys","pdptTablePhys","pdTablePhys","ptTablePhys","utils.log","i","writeAndVerifyPTE","description","readBack","error","PTE_PRESENT","PTE_READ_WRITE","PTE_USER_SUPER","currentVirtualPage","pte_value","pteWriteAddr","io","idtr","base","limit","gdtr","interruptQueue","rax","rbx","rcx","rdx","rsp","rbp","rsi","rdi","r8","r9","r10","r11","r12","r13","r14","r15","cs","ds","ss","es","fs","gs","rflags","rip","halted","flags","cf","zf","sf","of","if","cr0","cr3","cr4","efer","registers","eax","ecx","edx","ebx","esp","ebp","esi","edi","r8d","r9d","r10d","r11d","r12d","r13d","r14d","r15d","ax","cx","dx","bx","sp","bp","si","di","r8w","r9w","r10w","r11w","r12w","r13w","r14w","r15w","al","cl","dl","bl","ah","ch","dh","bh","spl","bpl","sil","dil","r8b","r9b","r10b","r11b","r12b","r13b","r14b","r15b","eflags","readRegister","regName","assembleRFlags","fullReg","val","includes","writeRegister","undefined","currentVal","valToWrite","BigInt","updateArithmeticFlags","result","operand1","operand2","operation","bitWidth","bitMask","signBitMask","maskedResult","maskedOperand1","maskedOperand2","s1","s2","sR","step","defaultOperandSize","rexPrefix","operandSizeOverride","opcode","rex_w","rex_r","rex_x","rex_b","currentRIPBeforeFetch","length","interruptNumber","shift","triggerInterrupt","byte","readInstructionByte","twoByteOpcode","padStart","modrm","readModRMByte","crIdx","reg","destRegFullIndex","rm","destRegName","getRegisterString","sourceValue","cr2","toUpperCase","sourceRegFullIndex","sourceRegName","updateCPUMode","warn","msrAddr","valueHigh","EFER_LME","displacement","readSignedImmediate","memOperand","resolveModRMOperand","readVirtualUint16","address","readVirtualBigUint64","regVal","destAddr","mod","destRegIdx","immValue","dBit","regOpFullIndex","regOpName","rmOperand","destValue","destOperand","type","readVirtualUint8","readVirtualUint32","writeVirtualUint8","writeVirtualUint16","writeVirtualUint32","writeVirtualBigUint64","imm32","eaxValue","destOperandString","regValue","immediateSize","immediateValue","immediateSizeBytes","effectiveOperand2","flagOperation","mnemonic","fullRegNameForVerify","targetSizeBytes","asIntN","sregName","regIdx","retAddr","tgtAddr","imm16","effectiveAddress","val1","val2","imm8","shiftCount","new_rflags","disassembleRFlags","originalCF","offset","new_cs","e","CR0_PE","readInstructionUint16","lo","readInstructionUint32","b1","b2","b3","raw","regIndex","hasRexPrefix","regNames64","regNames32","regNames16","regNames8Low","regNames8HighNoRex","regNames8NewRex","regNames8Extended","rawValue","hi","readSIBByte","sib","indexBits","baseBits","scale","idxRegName","baseRegName","baseValue","indexValue","hasRexPrefixForNaming","rmIndex","sibPresent","indexRegName","baseRegIndex","sibBaseIsRBP","peBit","pgBit","CR0_PG","paeBit","CR4_PAE","lmeBit","virtualAddr","physicalAddr","translateVirtualToPhysical","accessType","pml4BasePhys","pml4Index","pml4eAddr","pml4e","pdptBasePhys","pdptIndex","pdpteAddr","pdpte","PTE_PAGE_SIZE","physical","pdBasePhys","pdIndex","pdeAddr","pde","ptBasePhys","ptIndex","pteAddr","pte","pageBaseAddr","descriptorAddr","slice","map","b","join","lowSlice","highSlice","offset_15_0","offset_31_16","offset_63_32","handlerAddr","segmentSelector","FLAG_CF_BIT","FLAG_ZF_BIT","FLAG_SF_BIT","FLAG_OF_BIT","FLAG_IF_BIT","rflagsValue","raiseInterrupt","push","m"],"mappings":"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"}