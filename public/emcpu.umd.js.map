{"version":3,"file":"emcpu.umd.js","sources":["../cpu/utils.js","../cpu/memory.js","../cpu/io.js","../cpu/cpu.js"],"sourcesContent":["const _console = console;\n\nlet mode = \"prod\";\n\nexport function getMode() {\n    return mode;\n}\n\nexport function setMode(m) {\n    if (m !== \"dev\" && m !== \"prod\") throw new Error(\"Invalid mode\");\n    mode = m;\n}\n\nexport function log(...args) {\n    if (mode === \"dev\") _console.log(...args);\n}\n","export class Memory {\n    constructor(size) {\n        this.buffer = new ArrayBuffer(size);\n        this.view = new DataView(this.buffer);\n        new Uint8Array(this.buffer).fill(0); \n    }\n\n    // Read methods\n    readUint8(addr) { return this.view.getUint8(addr); }\n    readUint16(addr) { return this.view.getUint16(addr, true); } // true for little-endian\n    readUint32(addr) { return this.view.getUint32(addr, true); }\n    readBigUint64(addr) { return this.view.getBigUint64(addr, true); }\n\n    // Write methods\n    writeUint8(addr, value) { return this.view.setUint8(addr, value); }\n    writeUint16(addr, value) { return this.view.setUint16(addr, value, true); } // true for little-endian\n    writeUint32(addr, value) { return this.view.setUint32(addr, value, true); }\n    writeBigUint64(addr, value) { return this.view.setBigUint64(addr, value, true); }\n\n    // Helper to load binary data into memory (eg. boot sector)\n    load(addr, data) {\n        const sourceUint8Array = new Uint8Array(data);\n        const mainBufferView = new Uint8Array(this.buffer);\n\n        if (Number(addr) < 0 || (Number(addr) + sourceUint8Array.byteLength) > mainBufferView.byteLength) {\n            throw new Error(`Memory.load: Attempted to load 0x${sourceUint8Array.byteLength.toString(16)} bytes at 0x${addr.toString(16)} which is outside the allocated memory bounds (0x0 to 0x${mainBufferView.byteLength.toString(16)}).`);\n        }\n\n        mainBufferView.set(sourceUint8Array, Number(addr));\n        console.log(`Memory.load: Loaded 0x${sourceUint8Array.byteLength.toString(16)} bytes to 0x${addr.toString(16)}`);\n    }\n}","import { log } from \"./utils.js\";\n\nexport class IOManager {\n    constructor() {\n        this.devices = new Map();\n    }\n\n    registerDevice(ports, device) {\n        const portArray = Array.isArray(ports) ? ports : [ports];\n        for (const port of portArray) {\n            this.devices.set(port, device);\n            log(`Registered device ${device.name} at port ${port}`);\n        }\n    }\n\n    portIn(port, size) {\n        const device = this.devices.get(port);\n        if (device && device.portIn) {\n            return device.portIn(port, size);\n        }\n        return 0;\n    }\n\n    portOut(port, value, size) {\n        const device = this.devices.get(port);\n        if (device && device.portOut) {\n            device.portOut(port, value, size);\n        }\n    }\n}\n\nexport class Device {\n    /**\n     * @param {string} name A descriptive name for the device for logging/debugging.\n     */\n    constructor(name = 'Unnamed Device') {\n        this.name = name;\n    }\n\n    /**\n     * Handles a read from an I/O port associated with this device.\n     * @param {number} port The port number being read from.\n     * @param {number} size The size of the read in bytes (1, 2, or 4).\n     * @returns {number} The value to be returned to the CPU.\n     */\n    portIn(port, size) {\n        // Default behavior for a write-only or unimplemented device.\n        // Real hardware often returns 0xFF on reads from empty ports, but 0 is also fine.\n        return 0;\n    }\n\n    /**\n     * Handles a write to an I/O port associated with this device.\n     * @param {number} port The port number being written to.\n     * @param {number} value The value being written by the CPU.\n     * @param {number} size The size of the write in bytes (1, 2, or 4).\n     */\n    portOut(port, value, size) {\n        // Default behavior for a read-only or unimplemented device is to do nothing.\n        // This is exactly like real hardware.\n    }\n}\n","import * as utils from \"./utils\";\nimport { Memory } from \"./memory.js\";\nimport { IOManager } from \"./io.js\";\n\nexport class PageFaultException extends Error {\n    constructor(message, errorCode) {\n        super(message);\n        this.name = \"PageFaultException\";\n        this.errorCode = errorCode;\n    }\n}\n\nexport class CPU {\n    // --- STATIC CONSTANTS ---\n    static CR0_PE = 1n << 0n;  // Protected Mode Enable\n    static CR0_PG = 1n << 31n; // Paging Enable\n\n    static CR4_PAE = 1n << 5n; // Physical Address Extension\n\n    static FLAG_CF_BIT = 0n;\n    static FLAG_ZF_BIT = 6n;\n    static FLAG_SF_BIT = 7n;\n    static FLAG_OF_BIT = 11n;\n\n    static EFER_LME = 1n << 8n; // Long Mode Enable\n    static EFER_NXE = 1n << 11n; // No-Execute Enable (for future NX bit support)\n\n    // Constants for Page Table Entry (PTE) bits\n    // These apply to PML4E, PDPTE, PDE, PTE\n    static PTE_PRESENT       = 1n << 0n;   // P: Present (must be 1 for valid entry)\n    static PTE_READ_WRITE    = 1n << 1n;   // RW: Read/Write (0=read-only, 1=read/write)\n    static PTE_USER_SUPER    = 1n << 2n;   // US: User/Supervisor (0=supervisor-only, 1=user/supervisor)\n    static PTE_WRITE_THROUGH = 1n << 3n;   // PWT: Page Write-Through\n    static PTE_CACHE_DISABLE = 1n << 4n;   // PCD: Page Cache Disable\n    static PTE_ACCESSED      = 1n << 5n;   // A: Accessed (set by CPU on access)\n    static PTE_DIRTY         = 1n << 6n;   // D: Dirty (set by CPU on write) - only for last-level entries (PTE, PDE for 2MB, PDPTE for 1GB)\n    static PTE_PAGE_SIZE     = 1n << 7n;   // PS: Page Size (0=4KB, 1=2MB or 1GB depending on level)\n    static PTE_GLOBAL        = 1n << 8n;   // G: Global (prevents TLB flush on CR3 load - for kernel pages)\n    // Bits 9-11 are ignored for software use\n    // Bits 12-51 for physical page address (for 4KB pages) or bits 21-51 for 2MB/1GB pages\n    // Bits 52-62 ignored for software use\n    // Bit 63 (NXE in EFER, if enabled) for No-Execute\n\n    /**\n     * Creates a minimal 4-level page table structure to identity-map a range of virtual addresses to physical.\n     * Assumes 4KB pages.\n     * @param {Memory} memory The emulated memory object.\n     * @param {BigInt} virtualStart The starting virtual address to map.\n     * @param {BigInt} physicalStart The starting physical address to map.\n     * @param {BigInt} sizeBytes The size of the region to map (must be a multiple of 4KB).\n     * @param {BigInt} pageTableBasePhysAddr The base physical address where page tables will be stored.\n     * @returns {BigInt} The physical address of the PML4 table.\n     */\n    static setupIdentityPaging(memory, virtualStart, physicalStart, sizeBytes, pageTableBasePhysAddr) {\n        const PAGE_SIZE = 4096n; // 4KB\n        if (sizeBytes % PAGE_SIZE !== 0n) {\n            throw new Error(\"Mapped size must be a multiple of 4KB.\");\n        }\n        const numPages = sizeBytes / PAGE_SIZE;\n\n        let currentTableAddr = pageTableBasePhysAddr;\n\n        const pml4TablePhys = currentTableAddr;\n        currentTableAddr += PAGE_SIZE;\n\n        const pdptTablePhys = currentTableAddr;\n        currentTableAddr += PAGE_SIZE;\n\n        const pdTablePhys = currentTableAddr;\n        currentTableAddr += PAGE_SIZE;\n\n        const ptTablePhys = currentTableAddr;\n        currentTableAddr += PAGE_SIZE;\n\n        utils.log(`Setting up identity map from VA 0x${virtualStart.toString(16)} to PA 0x${physicalStart.toString(16)}, size 0x${sizeBytes.toString(16)}`);\n        utils.log(`  PML4 Table at PA 0x${pml4TablePhys.toString(16)}`);\n        utils.log(`  PDPT Table at PA 0x${pdptTablePhys.toString(16)}`);\n        utils.log(`  PD Table at PA 0x${pdTablePhys.toString(16)}`);\n        utils.log(`  PT Table at PA 0x${ptTablePhys.toString(16)}`);\n\n\n        // Initialize all tables to 0\n        for (let i = 0n; i < PAGE_SIZE / 8n; i++) {\n            memory.writeBigUint64(Number(pml4TablePhys + i * 8n), 0n);\n            memory.writeBigUint64(Number(pdptTablePhys + i * 8n), 0n);\n            memory.writeBigUint64(Number(pdTablePhys + i * 8n), 0n);\n            memory.writeBigUint64(Number(ptTablePhys + i * 8n), 0n);\n        }\n\n        // Helper for writing and verifying page table entries\n        const writeAndVerifyPTE = (addr, value, description) => {\n            memory.writeBigUint64(Number(addr), value);\n            const readBack = memory.readBigUint64(Number(addr));\n            if (readBack !== value) {\n                console.error(`ERROR: ${description} write mismatch at 0x${addr.toString(16)}! Written: 0x${value.toString(16)}, Readback: 0x${readBack.toString(16)}`);\n                throw new Error(\"Page table write verification failed.\");\n            } else {\n                utils.log(`  VERIFIED: ${description} at 0x${addr.toString(16)} is 0x${readBack.toString(16)}`);\n            }\n        };\n\n        // Map the first entry in each table to point to the next table\n        // PML4[0] -> PDPT[0]\n        let pml4e_value = pdptTablePhys | CPU.PTE_PRESENT | CPU.PTE_READ_WRITE | CPU.PTE_USER_SUPER;\n        writeAndVerifyPTE(pml4TablePhys, pml4e_value, `PML4E[0] -> PDPT[0]`);\n\n        // PDPT[0] -> PD[0]\n        let pdpte_value = pdTablePhys | CPU.PTE_PRESENT | CPU.PTE_READ_WRITE | CPU.PTE_USER_SUPER;\n        writeAndVerifyPTE(pdptTablePhys, pdpte_value, `PDPTE[0] -> PD[0]`);\n\n        // PD[0] -> PT[0]\n        let pde_value = ptTablePhys | CPU.PTE_PRESENT | CPU.PTE_READ_WRITE | CPU.PTE_USER_SUPER;\n        writeAndVerifyPTE(pdTablePhys, pde_value, `PDE[0] -> PT[0]`); \n\n        // Now, map the actual pages in the Page Table\n        for (let i = 0n; i < numPages; i++) {\n            const currentVirtualPage = virtualStart + i * PAGE_SIZE;\n            const currentPhysicalPage = physicalStart + i * PAGE_SIZE;\n            \n            let pte_value = currentPhysicalPage | CPU.PTE_PRESENT | CPU.PTE_READ_WRITE | CPU.PTE_USER_SUPER;\n            // The index into the Page Table depends on the virtual address's bits 12-20\n            const ptIndex = (currentVirtualPage >> 12n) & 0x1FFn;\n            const pteWriteAddr = ptTablePhys + ptIndex * 8n; // Calculate the specific address for this PTE\n\n            // For detailed debugging, log every 100th page, or specific pages (like 0x7C00 or 0x8000)\n            if (i % 100n === 0n || currentVirtualPage === 0x7C00n || currentVirtualPage === 0x8000n) { \n                writeAndVerifyPTE(pteWriteAddr, pte_value, `PTE for VA 0x${currentVirtualPage.toString(16)}`);\n            } else {\n                // If not logging, just perform the write\n                memory.writeBigUint64(Number(pteWriteAddr), pte_value);\n            }\n        }\n\n        return pml4TablePhys; // Return the base address of the PML4 table for CR3\n    }\n\n    constructor(memory = new Memory(1024 * 1024 * 1), io = new IOManager()) {\n        this.memory = memory;\n        this.io = io;\n\n        // Interrupt Descriptor Table Register\n        this.idtr = {\n            base: 0n,\n            limit: 0\n        }\n\n        // Global Descriptor Table Register\n        this.gdtr = {\n            base: 0n,\n            limit: 0\n        }\n\n        // General Purpose Registers\n        this.rax = 0n; this.rbx = 0n; this.rcx = 0n; this.rdx = 0n;\n        this.rsp = 0n; this.rbp = 0n; this.rsi = 0n; this.rdi = 0n;\n        this.r8 = 0n; this.r9 = 0n; this.r10 = 0n; this.r11 = 0n;\n        this.r12 = 0n; this.r13 = 0n; this.r14 = 0n; this.r15 = 0n;\n\n        this.rflags = 0n;\n\n        // Instruction Pointer\n        this.rip = 0n;\n\n        // Flags\n        this.flags = {\n            cf: 0, // Carry Flag\n            zf: 0, // Zero Flag\n            sf: 0, // Sign Flag\n            of: 0, // Overflow Flag\n            // TODO: Add more flags\n        }\n\n        // CPU Modes and Control Registers\n        this.mode = \"real\"; // real, protected, long\n        this.cr0 = 0n; // Control Register 0\n        this.cr3 = 0n; // Control Register 3\n        this.cr4 = 0n; // Control Register 4\n        this.efer = 0n; // Extended Feature Enable Register\n\n        // Mapping register names to their internal names\n        this.registers = {\n            // Full 64-bit\n            'rax': 'rax', 'rcx': 'rcx', 'rdx': 'rdx', 'rbx': 'rbx',\n            'rsp': 'rsp', 'rbp': 'rbp', 'rsi': 'rsi', 'rdi': 'rdi',\n            'r8': 'r8', 'r9': 'r9', 'r10': 'r10', 'r11': 'r11',\n            'r12': 'r12', 'r13': 'r13', 'r14': 'r14', 'r15': 'r15',\n            // 32-bit (low half of 64-bit)\n            'eax': 'rax', 'ecx': 'rcx', 'edx': 'rdx', 'ebx': 'rbx',\n            'esp': 'rsp', 'ebp': 'rbp', 'esi': 'rsi', 'edi': 'rdi',\n            'r8d': 'r8', 'r9d': 'r9', 'r10d': 'r10', 'r11d': 'r11',\n            'r12d': 'r12', 'r13d': 'r13', 'r14d': 'r14', 'r15d': 'r15',\n            // 16-bit (low half of 32-bit)\n            'ax': 'rax', 'cx': 'rcx', 'dx': 'rdx', 'bx': 'rbx',\n            'sp': 'rsp', 'bp': 'rbp', 'si': 'rsi', 'di': 'rdi',\n            'r8w': 'r8', 'r9w': 'r9', 'r10w': 'r10', 'r11w': 'r11',\n            'r12w': 'r12', 'r13w': 'r13', 'r14w': 'r14', 'r15w': 'r15',\n            // 8-bit (low byte of 16-bit) - AL, CL, DL, BL\n            'al': 'rax', 'cl': 'rcx', 'dl': 'rdx', 'bl': 'rbx',\n            // 8-bit (high byte of 16-bit) - AH, CH, DH, BH\n            'ah': 'rax', 'ch': 'rcx', 'dh': 'rdx', 'bh': 'rbx',\n            // 8-bit (low byte of RBP/RSP/RSI/RDI when REX prefix is used) - SPL, BPL, SIL, DIL\n            'spl': 'rsp', 'bpl': 'rbp', 'sil': 'rsi', 'dil': 'rdi',\n            // 8-bit (low byte of R8-R15) - R8B-R15B\n            'r8b': 'r8', 'r9b': 'r9', 'r10b': 'r10', 'r11b': 'r11',\n            'r12b': 'r12', 'r13b': 'r13', 'r14b': 'r14', 'r15b': 'r15',\n            // 64-bit flags register\n            'rflags': 'rflags', 'eflags': 'rflags',\n        };\n    }\n\n    // Helper to read register values with size handling\n    readRegister(regName, sizeBytes) {\n        if (regName === 'rflags' || regName === 'eflags') {\n            return this.assembleRFlags();\n        }\n        const fullReg = this.registers[regName];\n        if (!fullReg) {\n            throw new Error(`Attempted to read unknown register name: ${regName}`);\n        }\n        let val = this[fullReg]; // val is BigInt (e.g. this.rax)\n        if (sizeBytes === 1) {\n            // Handle AH, CH, DH, BH (high byte of 16-bit)\n            if (['ah', 'ch', 'dh', 'bh'].includes(regName)) {\n                return (val >> 8n) & 0xFFn;\n            }\n            // For AL, CL, DL, BL, SPL, BPL, SIL, DIL, R8B-R15B, it's the lowest byte\n            return (val & 0xFFn);\n        }\n        if (sizeBytes === 2) return (val & 0xFFFFn);\n        if (sizeBytes === 4) return (val & 0xFFFFFFFFn);\n        if (sizeBytes === 8) return val;\n        throw new Error(`Invalid register size: ${sizeBytes}`);\n    }\n\n    // Helper to write values to register values with size handling\n    writeRegister(regName, value, sizeBytes) {\n        const fullReg = this.registers[regName];\n        if (fullReg === undefined) {\n            throw new Error(`Attempted to write to unknown register name: ${regName}`);\n        }\n        let currentVal = this[fullReg];\n        let valToWrite = BigInt(value);\n\n        if (sizeBytes === 1) {\n            if (['ah', 'ch', 'dh', 'bh'].includes(regName)) {\n                // Clear the old AH/CH/DH/BH byte, then set the new one\n                this[fullReg] = (currentVal & ~(0xFFn << 8n)) | ((valToWrite & 0xFFn) << 8n);\n            } else {\n                // AL, CL, DL, BL, SPL, BPL, SIL, DIL, R8B-R15B\n                // Clear the lowest byte, then set the new one. Upper bits untouched.\n                this[fullReg] = (currentVal & ~0xFFn) | (valToWrite & 0xFFn);\n            }\n        } else if (sizeBytes === 2) {\n            // AX, CX, DX, BX, SP, BP, SI, DI, R8W-R15W\n            // Clear the lowest 16 bits, then set the new one. Upper bits untouched.\n            this[fullReg] = (currentVal & ~0xFFFFn) | (valToWrite & 0xFFFFn);\n        } else if (sizeBytes === 4) {\n            // EAX, ECX, EDX, EBX, ESP, EBP, ESI, EDI, R8D-R15D\n            // In 64-bit mode, writing to a 32-bit register (like EAX) zeros the upper 32 bits of the 64-bit register (RAX).\n            this[fullReg] = valToWrite & 0xFFFFFFFFn; // THIS IS THE CRITICAL CHANGE\n        } else if (sizeBytes === 8) {\n            // RAX, RCX, etc. Full 64-bit write.\n            this[fullReg] = valToWrite;\n        } else {\n            throw new Error(`Invalid register size for writing: ${sizeBytes} for register ${regName}`);\n        }\n    }\n\n    // Updates arithmetic flags based on result and operands\n    // Result, operand1, operand2 should be BigInts.\n    // 'operation' can be 'add' or 'sub'\n    updateArithmeticFlags(result, operand1, operand2, sizeBytes, operation) {\n        const bitWidth = BigInt(sizeBytes * 8);\n        const bitMask = (1n << bitWidth) - 1n; \n        const signBitPos = bitWidth - 1n; \n        const signBitMask = 1n << signBitPos;\n\n        // Apply the size mask to ensure correct behavior for operations that wrap around\n        const maskedResult = result & bitMask;\n        const maskedOperand1 = operand1 & bitMask;\n        const maskedOperand2 = operand2 & bitMask;\n\n        // Zero Flag (ZF): Set if result is 0\n        this.flags.zf = (maskedResult === 0n) ? 1 : 0;\n\n        // Sign Flag (SF): Set if result's MSB is 1\n        this.flags.sf = ((maskedResult & signBitMask) !== 0n) ? 1 : 0;\n\n        // Carry Flag (CF): For unsigned overflow\n        // For ADD: CF = 1 if result (unsigned) > max_unsigned_value_for_size\n        // For SUB: CF = 1 if operand1 (unsigned) < operand2 (unsigned) (borrow occurred)\n        if (operation === 'add') {\n            this.flags.cf = (result > bitMask) ? 1 : 0;\n        } else if (operation === 'sub') {\n            this.flags.cf = (maskedOperand1 < maskedOperand2) ? 1 : 0;\n        } else {\n            // For logical operations (AND, OR, XOR), CF is always 0\n            this.flags.cf = 0; \n        }\n\n        // Overflow Flag (OF): For signed overflow\n        // OF is set if the result's sign is different from the operands' sign (for ADD)\n        // or if the result's sign is different from the minuend's sign when the subtrahend's sign is inverted (for SUB).\n        // This is often checked by XORing sign bits:\n        // For ADD: OF = ( (Op1 ^ Res) & (Op2 ^ Res) ) >> signBitPos\n        // For SUB: OF = ( (Op1 ^ Res) & (~Op2 ^ Res) ) >> signBitPos  (where ~Op2 means bitwise NOT of Op2 within its size)\n\n        const s1 = (maskedOperand1 & signBitMask) !== 0n; // Sign of first operand\n        const s2 = (maskedOperand2 & signBitMask) !== 0n; // Sign of second operand\n        const sR = (maskedResult & signBitMask) !== 0n;   // Sign of result\n\n        this.flags.of = 0; // Assume no overflow initially\n\n        if (operation === 'add') {\n            if ((s1 === s2) && (s1 !== sR)) { // Adding two positives makes negative, or two negatives makes positive\n                this.flags.of = 1;\n            }\n        } else if (operation === 'sub') {\n            // OF is set if: (positive - negative = negative) OR (negative - positive = positive)\n            // This is equivalent to: (s1 XOR s2) AND (s1 XOR sR)\n            if ((s1 !== s2) && (s1 !== sR)) { // e.g., 7 - (-1) = 8. s1=0, s2=1, sR=0. (0!=1) && (0!=0) -> false (no OF)\n                                             // e.g., 127 - (-1) = 128. s1=0, s2=1, sR=1. (0!=1) && (0!=1) -> true (OF)\n                this.flags.of = 1;\n            }\n        } else {\n            // For logical operations (AND, OR, XOR), OF is always 0\n            this.flags.of = 0;\n        }\n    }\n\n    step() {\n        let rexPrefix = 0;\n        let defaultOperandSize = 4; // Default 32 bit (unless REX.W or 0x66 override)\n        this.operandSizeOverride = false;\n\n        let rex_w = 0;\n        let rex_r = 0;\n        let rex_x = 0;\n        let rex_b = 0;\n\n        let currentRIPBeforeFetch = this.rip; // Store RIP to calculate instruction start accurately\n\n        let opcode; // Declare opcode here, will be assigned inside prefix loop\n\n        try {\n\n        // --- Handle Prefixes (Loop to consume all prefixes) ---\n        // Read bytes one by one, processing as prefixes until main opcode or 0x0F is found.\n            let byte = this.readInstructionByte(); // Read the first byte of the potential instruction\n\n            while (true) {\n                if (byte === 0x66) { // Operand Size Override Prefix\n                    this.operandSizeOverride = true;\n                    byte = this.readInstructionByte(); // Consume 0x66, read next byte\n                } else if ((byte & 0xF0) === 0x40) { // REX prefix: 0x40 - 0x4F\n                    rexPrefix = byte;\n                    rex_w = (rexPrefix & 0x08) >>> 3;\n                    rex_r = (rexPrefix & 0x04) >>> 2;\n                    rex_x = (rexPrefix & 0x02) >>> 1;\n                    rex_b = (rexPrefix & 0x01);\n                    byte = this.readInstructionByte(); // Consume REX, read next byte\n                } \n                // Add other prefixes here (e.g., segment overrides 0x2E, 0x36, REP prefixes 0xF2, 0xF3)\n                else {\n                    // If it's not a known prefix, it must be the main opcode or 0x0F prefix\n                    opcode = byte; // Assign the actual opcode\n                    break; // Exit loop\n                }\n            }\n\n            // After consuming all prefixes, determine the final operand size\n            // REX.W (0x08 bit) indicates 64-bit operand size. It takes precedence over 0x66.\n            // If REX.W is NOT set, AND 0x66 is present, then it's 16-bit.\n            // Otherwise, it's 32-bit default for protected mode or 64-bit default for long mode.\n            if (rex_w !== 0) {\n                defaultOperandSize = 8;\n            } else if (this.operandSizeOverride) { // 0x66 present, but no REX.W\n                defaultOperandSize = 2; // Set to 16-bit\n            } \n            // If no REX.W and no 0x66, defaultOperandSize remains 4 (32-bit default for protected mode).\n            // A truly comprehensive emulator would set defaultOperandSize = 8 if in long mode,\n            // but for now, rely on REX.W or 0x66 to set it explicitly from the instruction.\n\n            // 2-byte opcode prefix (0x0F) - This comes *after* other prefixes\n            let twoByteOpcode = false;\n            if (opcode === 0x0F) {\n                twoByteOpcode = true;\n                opcode = this.readInstructionByte(); // Read the second byte of the opcode\n            }\n\n            // --- Logging the Instruction ---\n            utils.log(`RIP: 0x${currentRIPBeforeFetch.toString(16).padStart(4, '0')}, OPCODE: 0x${(twoByteOpcode ? '0F' : '')}${opcode.toString(16).padStart(2, '0')}${rexPrefix ? ` (REX: 0x${rexPrefix.toString(16)})` : ''}${this.operandSizeOverride ? ' (0x66)' : ''}`);\n\n            // --- Instruction Decoding and Execution ---\n\n            // Priority 1: Handle two-byte opcodes (opcodes that follow 0x0F)\n            if (twoByteOpcode) {\n                // MOV CRn, Reg/Mem64 (0x0F 22)\n                if (opcode === 0x22) {\n                    const modrm = this.readModRMByte();\n                    const crIdx = modrm.reg; // CR register is encoded in the 'reg' field of ModR/M\n                    const sourceRegFullIndex = modrm.rm + (rex_b << 3); // Source GPR is encoded in 'r/m' field, REX.B applies\n                    \n                    // Pass hasRexPrefix (rexPrefix !== 0) to getRegisterString.\n                    const sourceRegName = this.getRegisterString(sourceRegFullIndex, 8, rexPrefix !== 0);\n\n                    const sourceValue = this.readRegister(sourceRegName, 8);\n\n                    switch (crIdx) {\n                        case 0: this.cr0 = sourceValue; utils.log(`Decoded: MOV CR0, ${sourceRegName.toUpperCase()} (0x${sourceValue.toString(16)}n)`); this.updateCPUMode(); break;\n                        case 2: this.cr2 = sourceValue; utils.log(`Decoded: MOV CR2, ${sourceRegName.toUpperCase()} (0x${sourceValue.toString(16)}n)`); break;\n                        case 3: this.cr3 = sourceValue; utils.log(`Decoded: MOV CR3, ${sourceRegName.toUpperCase()} (0x${sourceValue.toString(16)}n)`); break;\n                        case 4: this.cr4 = sourceValue; utils.log(`Decoded: MOV CR4, ${sourceRegName.toUpperCase()} (0x${sourceValue.toString(16)}n)`); this.updateCPUMode(); break;\n                        default: console.warn(`MOV CR${crIdx}, ${sourceRegName.toUpperCase()} not fully implemented/valid.`); \n                    }\n                    return true;\n                }\n                // WRMSR (0x0F 30)\n                if (opcode === 0x30) {\n                    const msrAddr = this.readRegister('rcx', 8); \n                    const valueHigh = this.readRegister('rdx', 8) << 32n; \n                    const valueLow = this.readRegister('rax', 8) & 0xFFFFFFFFn; \n                    const value = valueHigh | valueLow;\n\n                    if (msrAddr === 0xC0000080n) { // EFER MSR\n                        this.efer = value;\n                        if ((this.efer & CPU.EFER_LME) !== 0n) {\n                            utils.log(`Long Mode Enable (LME) bit set in EFER!`);\n                        }\n                        this.updateCPUMode();\n                    } else {\n                        console.warn(`WRMSR to unknown MSR 0x${msrAddr.toString(16)}`);\n                    }\n                    return true;\n                }\n                // JE/JZ (0x0F 84) - near jump with 32-bit displacement\n                if (opcode === 0x84) {\n                    const displacement = this.readSignedImmediate(4); // Read 32-bit signed displacement\n                    utils.log(`Decoded: JE/JZ rel32 0x${displacement.toString(16)} (RIP adjusted)`);\n                    if (this.flags.zf === 1) {\n                        this.rip += displacement; // Apply displacement if ZF is set\n                        utils.log(`  Condition Met (ZF=1). Jumping to 0x${this.rip.toString(16)}`);\n                    } else {\n                        utils.log(`  Condition Not Met (ZF=0). Not jumping.`);\n                    }\n                    return true;\n                }\n                // JNE/JNZ (0x0F 85) - near jump with 32-bit displacement\n                if (opcode === 0x85) {\n                    const displacement = this.readSignedImmediate(4); // Read 32-bit signed displacement\n                    utils.log(`Decoded: JNE/JNZ rel32 0x${displacement.toString(16)} (RIP adjusted)`);\n                    if (this.flags.zf === 0) {\n                        this.rip += displacement; // Apply displacement if ZF is clear\n                        utils.log(`  Condition Met (ZF=0). Jumping to 0x${this.rip.toString(16)}`);\n                    } else {\n                        utils.log(`  Condition Not Met (ZF=1). Not jumping.`);\n                    }\n                    return true;\n                }\n\n                // TODO: Implement other 2-byte Jcc instructions here (e.g., JCC, JNC, JS, JNS, JO, JNO, JP, JNP, JL, JGE, JLE, JG)\n\n                // LGDT and LIDT (0F 01 /2 and /3)\n                if (opcode === 0x01) {\n                    const modrm = this.readModRMByte();\n\n                    // LGDT m64 (opcode extension /2)\n                    if (modrm.reg === 2) {\n                        // THIS IS THE CRITICAL LINE\n                        // We MUST call resolveModRMOperand to get the memory address\n                        // AND to advance RIP past the ModR/M and any displacement bytes.\n                        const memOperand = this.resolveModRMOperand(modrm, 8, rex_x, rex_b, rexPrefix !== 0);\n\n                        // Now use the CORRECT address from the operand\n                        const limit = this.readVirtualUint16(memOperand.address);\n                        const base = this.readVirtualBigUint64(memOperand.address + 2n);\n\n                        this.gdtr.limit = limit;\n                        this.gdtr.base = base;\n\n                        utils.log(`Decoded: LGDT [0x${memOperand.address.toString(16)}] (Base: 0x${base.toString(16)}, Limit: 0x${limit.toString(16)})`);\n                        return true;\n                    }\n                    \n                    // LIDT m64 (opcode extension /3)\n                    if (modrm.reg === 3) {\n                        // THIS IS THE CRITICAL LINE\n                        const memOperand = this.resolveModRMOperand(modrm, 8, rex_x, rex_b, rexPrefix !== 0);\n\n                        // Now use the CORRECT address from the operand\n                        const limit = this.readVirtualUint16(memOperand.address);\n                        const base = this.readVirtualBigUint64(memOperand.address + 2n);\n\n                        this.idtr.limit = limit;\n                        this.idtr.base = base;\n\n                        utils.log(`Decoded: LIDT [0x${memOperand.address.toString(16)}] (Base: 0x${base.toString(16)}, Limit: 0x${limit.toString(16)})`);\n                        return true;\n                    }\n                }\n\n                // If a two-byte opcode is not handled here, it's genuinely unknown\n                utils.log(`Unknown 2-byte opcode: 0x0F ${opcode.toString(16)} at 0x${currentRIPBeforeFetch.toString(16)}`);\n                return false; // Or false if you want to halt on unknown 2-byte opcodes\n            }\n\n            // Priority 2: Handle single-byte opcodes (only if not a two-byte opcode)\n\n            // NOP instruction\n            if (opcode === 0x90) {\n                utils.log(\"Decoded: NOP\");\n                return true;\n            }\n\n            // HLT instruction\n            if (opcode === 0xF4) {\n                utils.log(\"HLT instruction encountered. Emulation halted.\");\n                return false;\n            }\n\n            // Conditional Jumps (short form: Jcc rel8)\n            // These take a 1-byte signed relative displacement.\n            // JE/JZ (0x74)\n            if (opcode === 0x74) {\n                const displacement = this.readSignedImmediate(1); // Read 1-byte signed displacement\n                utils.log(`Decoded: JE/JZ rel8 0x${displacement.toString(16)} (RIP adjusted)`);\n                if (this.flags.zf === 1) {\n                    this.rip += displacement; // Apply displacement if ZF is set\n                    utils.log(`  Condition Met (ZF=1). Jumping to 0x${this.rip.toString(16)}`);\n                } else {\n                    utils.log(`  Condition Not Met (ZF=0). Not jumping.`);\n                }\n                return true;\n            }\n\n            // JNE/JNZ (0x75)\n            if (opcode === 0x75) {\n                const displacement = this.readSignedImmediate(1); // Read 1-byte signed displacement\n                utils.log(`Decoded: JNE/JNZ rel8 0x${displacement.toString(16)} (RIP adjusted)`);\n                if (this.flags.zf === 0) {\n                    this.rip += displacement; // Apply displacement if ZF is clear\n                    utils.log(`  Condition Met (ZF=0). Jumping to 0x${this.rip.toString(16)}`);\n                } else {\n                    utils.log(`  Condition Not Met (ZF=1). Not jumping.`);\n                }\n                return true;\n            }\n\n            // Universal MOV reg, imm (0xB0 - 0xBF)\n            if (opcode >= 0xB0 && opcode <= 0xBF) {\n                const destRegIdx = opcode & 0x07;\n                \n                let immValue;\n                let sizeBytes;\n                let destRegName;\n\n                const getImmediateValue = (currentRip, numBytes) => {\n                    if ((this.cr0 & CPU.CR0_PE) !== 0n) { \n                        if (numBytes === 1) return BigInt(this.readVirtualUint8(currentRip));\n                        else if (numBytes === 2) return BigInt(this.readVirtualUint16(currentRip)); \n                        else if (numBytes === 4) return BigInt(this.readVirtualUint32(currentRip));\n                        else if (numBytes === 8) return this.readVirtualBigUint64(currentRip);\n                    } else {\n                        if (numBytes === 1) return BigInt(this.memory.readUint8(Number(currentRip)));\n                        else if (numBytes === 2) return BigInt(this.memory.readUint16(Number(currentRip))); \n                        else if (numBytes === 4) return BigInt(this.memory.readUint32(Number(currentRip)));\n                        else if (numBytes === 8) return BigInt(this.memory.readBigUint64(Number(currentRip))); // Ensure BigInt\n                    }\n                    throw new Error(`Unsupported immediate size for MOV reg, imm: ${numBytes}`);\n                };\n\n                if (opcode >= 0xB0 && opcode <= 0xB7) { // 8-bit MOV (B0-B7)\n                    destRegName = this.getRegisterString(destRegIdx + (rex_b << 3), 1, rexPrefix !== 0); // Pass hasRexPrefix\n                    sizeBytes = 1;\n                    immValue = getImmediateValue(this.rip, 1);\n                    this.rip += 1n;\n                } else { // 16/32/64-bit MOV (B8-BF)\n                    sizeBytes = defaultOperandSize; // Use the determined operand size\n                    destRegName = this.getRegisterString(destRegIdx + (rex_b << 3), sizeBytes, rexPrefix !== 0); // Pass hasRexPrefix\n                    if (sizeBytes === 2) { // 16-bit\n                        immValue = getImmediateValue(this.rip, 2);\n                        this.rip += 2n;\n                    } else if (sizeBytes === 4) { // 32-bit\n                        immValue = getImmediateValue(this.rip, 4);\n                        this.rip += 4n;\n                    } else if (sizeBytes === 8) { // 64-bit\n                        immValue = getImmediateValue(this.rip, 8);\n                        this.rip += 8n;\n                    } else {\n                        throw new Error(`Unsupported immediate size for MOV reg, imm (B8-BF variant) with sizeBytes: ${sizeBytes}`);\n                    }\n                }\n                this.writeRegister(destRegName, immValue, sizeBytes);\n                utils.log(`Decoded: MOV ${destRegName.toUpperCase()}, 0x${immValue.toString(16)}${sizeBytes === 8 ? 'n' : ''}`);\n                return true;\n            }\n            \n            // ADD reg, r/m (0x01 / 0x03)\n            if (opcode === 0x01 || opcode === 0x03) {\n                const modrm = this.readModRMByte();\n                const dBit = (opcode >>> 1) & 0x01; \n                const wBit = opcode & 0x01;         \n\n                let sizeBytes = (wBit === 0) ? 1 : defaultOperandSize;\n\n                const regOpFullIndex = modrm.reg + (rex_r << 3);\n                const regOpName = this.getRegisterString(regOpFullIndex, sizeBytes, rexPrefix !== 0); // Pass hasRexPrefix\n                const rmOperand = this.resolveModRMOperand(modrm, sizeBytes, rex_x, rex_b, rexPrefix !== 0); // Pass hasRexPrefixForNaming\n\n                let sourceValue;\n                let destValue;\n                let destOperand; \n\n                if (rmOperand.type === 'reg') {\n                    if (dBit === 0) { \n                        sourceValue = this.readRegister(regOpName, sizeBytes);\n                        destValue = this.readRegister(rmOperand.name, sizeBytes);\n                        destOperand = rmOperand; \n                    } else { \n                        sourceValue = this.readRegister(rmOperand.name, sizeBytes);\n                        destValue = this.readRegister(regOpName, sizeBytes);\n                        destOperand = { type: 'reg', name: regOpName }; \n                    }\n                } else { \n                    if (dBit === 0) { \n                        sourceValue = this.readRegister(regOpName, sizeBytes);\n                        if (sizeBytes === 1) destValue = BigInt(this.readVirtualUint8(rmOperand.address));\n                        else if (sizeBytes === 2) destValue = BigInt(this.readVirtualUint16(rmOperand.address));\n                        else if (sizeBytes === 4) destValue = BigInt(this.readVirtualUint32(rmOperand.address));\n                        else if (sizeBytes === 8) destValue = this.readVirtualBigUint64(rmOperand.address);\n                        else throw new Error(\"Unsupported memory read size for ADD.\");\n                        destOperand = rmOperand; \n                    } else { \n                        if (sizeBytes === 1) sourceValue = BigInt(this.readVirtualUint8(rmOperand.address));\n                        else if (sizeBytes === 2) sourceValue = BigInt(this.readVirtualUint16(rmOperand.address));\n                        else if (sizeBytes === 4) sourceValue = BigInt(this.readVirtualUint32(rmOperand.address));\n                        else if (sizeBytes === 8) sourceValue = this.readVirtualBigUint64(rmOperand.address);\n                        else throw new Error(\"Unsupported memory read size for ADD.\");\n                        destValue = this.readRegister(regOpName, sizeBytes);\n                        destOperand = { type: 'reg', name: regOpName }; \n                    }\n                }\n                \n                const result = destValue + sourceValue;\n                this.updateArithmeticFlags(result, destValue, sourceValue, sizeBytes, 'add');\n\n                if (destOperand.type === 'reg') {\n                    this.writeRegister(destOperand.name, result, sizeBytes);\n                } else { \n                    if (sizeBytes === 1) this.writeVirtualUint8(destOperand.address, Number(result));\n                    else if (sizeBytes === 2) this.writeVirtualUint16(destOperand.address, Number(result));\n                    else if (sizeBytes === 4) this.writeVirtualUint32(destOperand.address, Number(result));\n                    else if (sizeBytes === 8) this.writeVirtualBigUint64(destOperand.address, result);\n                    else throw new Error(\"Unsupported memory write size for ADD.\");\n                }\n                utils.log(`Decoded: ADD ${destOperand.type === 'reg' ? destOperand.name.toUpperCase() : `[0x${destOperand.address.toString(16)}]`}, ${sourceValue.toString(16)}${sizeBytes === 8 ? 'n' : ''} -> Result: 0x${result.toString(16)}n`);\n                return true;\n            }\n\n            // ADD EAX, imm32 (0x05)\n            if (opcode === 0x05) {\n                const imm32 = this.readSignedImmediate(4);\n                const eaxValue = this.readRegister('eax', 4);\n                const result = eaxValue + imm32;\n                this.updateArithmeticFlags(result, eaxValue, imm32, 4, 'add');\n                this.writeRegister('eax', result, 4);\n                utils.log(`Decoded: ADD EAX, 0x${imm32.toString(16)} (Result: 0x${result.toString(16)})`);\n                return true;\n            }\n\n            // OR reg, r/m; OR r/m, reg (0x09 / 0x0B for 16/32/64-bit, 0x08 / 0x0A for 8-bit)\n            if (opcode >= 0x08 && opcode <= 0x0B) {\n                const modrm = this.readModRMByte();\n                const dBit = (opcode >>> 1) & 0x01; // Direction bit\n                const wBit = opcode & 0x01;         // Width bit\n\n                let sizeBytes = (wBit === 0) ? 1 : defaultOperandSize;\n\n                const regOpFullIndex = modrm.reg + (rex_r << 3);\n                const regOpName = this.getRegisterString(regOpFullIndex, sizeBytes, rexPrefix !== 0); // Pass hasRexPrefix\n                const rmOperand = this.resolveModRMOperand(modrm, sizeBytes, rex_x, rex_b, rexPrefix !== 0); // Pass hasRexPrefixForNaming\n\n                let sourceValue;\n                let destValue;\n                let destOperand;\n\n                if (rmOperand.type === 'reg') {\n                    if (dBit === 0) { // OR r/m, reg (reg is source, r/m is dest)\n                        sourceValue = this.readRegister(regOpName, sizeBytes);\n                        destValue = this.readRegister(rmOperand.name, sizeBytes);\n                        destOperand = rmOperand;\n                    } else { // OR reg, r/m (r/m is source, reg is dest)\n                        sourceValue = this.readRegister(rmOperand.name, sizeBytes);\n                        destValue = this.readRegister(regOpName, sizeBytes);\n                        destOperand = { type: 'reg', name: regOpName };\n                    }\n                } else { // rmOperand.type === 'mem'\n                    if (dBit === 0) { // OR r/m, reg (reg is source, r/m is dest)\n                        sourceValue = this.readRegister(regOpName, sizeBytes);\n                        if (sizeBytes === 1) destValue = BigInt(this.readVirtualUint8(rmOperand.address));\n                        else if (sizeBytes === 2) destValue = BigInt(this.readVirtualUint16(rmOperand.address));\n                        else if (sizeBytes === 4) destValue = BigInt(this.readVirtualUint32(rmOperand.address));\n                        else if (sizeBytes === 8) destValue = this.readVirtualBigUint64(rmOperand.address);\n                        else throw new Error(\"Unsupported memory read size for OR.\");\n                        destOperand = rmOperand;\n                    } else { // OR reg, r/m (r/m is source, reg is dest)\n                        if (sizeBytes === 1) sourceValue = BigInt(this.readVirtualUint8(rmOperand.address));\n                        else if (sizeBytes === 2) sourceValue = BigInt(this.readVirtualUint16(rmOperand.address));\n                        else if (sizeBytes === 4) sourceValue = BigInt(this.readVirtualUint32(rmOperand.address));\n                        else if (sizeBytes === 8) sourceValue = this.readVirtualBigUint64(rmOperand.address);\n                        else throw new Error(\"Unsupported memory read size for OR.\");\n                        destValue = this.readRegister(regOpName, sizeBytes);\n                        destOperand = { type: 'reg', name: regOpName };\n                    }\n                }\n                \n                const result = destValue | sourceValue; // Perform OR operation\n\n                this.flags.cf = 0; \n                this.flags.of = 0; \n                this.flags.zf = (result === 0n) ? 1 : 0; \n                const bitWidth = BigInt(sizeBytes * 8);\n                const signBitMask = 1n << (bitWidth - 1n);\n                this.flags.sf = ((result & signBitMask) !== 0n) ? 1 : 0; \n\n                if (destOperand.type === 'reg') {\n                    this.writeRegister(destOperand.name, result, sizeBytes);\n                } else { \n                    if (sizeBytes === 1) this.writeVirtualUint8(destOperand.address, Number(result));\n                    else if (sizeBytes === 2) this.writeVirtualUint16(destOperand.address, Number(result));\n                    else if (sizeBytes === 4) this.writeVirtualUint32(destOperand.address, Number(result));\n                    else if (sizeBytes === 8) this.writeVirtualBigUint64(destOperand.address, result);\n                    else throw new Error(\"Unsupported memory write size for OR.\");\n                }\n                const destOperandString = destOperand.type === 'reg' ? destOperand.name.toUpperCase() : `[0x${destOperand.address.toString(16)}]`;\n                const srcOperandString = (dBit === 0) ? regOpName.toUpperCase() : (rmOperand.type === 'reg' ? rmOperand.name.toUpperCase() : `[0x${rmOperand.address.toString(16)}]`);\n                utils.log(`Decoded: OR ${destOperandString}, ${srcOperandString} (0x${destValue.toString(16)}n | 0x${sourceValue.toString(16)}n) -> Result: 0x${result.toString(16)}n`);\n                return true;\n            }\n\n            // AND reg, r/m; AND r/m, reg (0x21 / 0x23 for 16/32/64-bit, 0x20 / 0x22 for 8-bit)\n            // Note: This block handles AND r/m, reg and AND reg, r/m forms.\n            // Opcodes:\n            // 0x20: AND r/m8, reg8\n            // 0x21: AND r/m16/32/64, reg16/32/64\n            // 0x22: AND reg8, r/m8\n            // 0x23: AND reg16/32/64, r/m16/32/64\n            if (opcode >= 0x20 && opcode <= 0x23) {\n                const modrm = this.readModRMByte();\n                const dBit = (opcode >>> 1) & 0x01; // Direction bit: 0 = r/m <- reg; 1 = reg <- r/m\n                const wBit = opcode & 0x01;         // Width bit: 0 = 8-bit; 1 = 16/32/64-bit\n\n                let sizeBytes = (wBit === 0) ? 1 : defaultOperandSize;\n\n                // Use REX.R for the 'reg' field and REX.B for the 'rm' field in ModR/M\n                const regOpFullIndex = modrm.reg + (rex_r << 3);\n\n                const regOpName = this.getRegisterString(regOpFullIndex, sizeBytes, rexPrefix !== 0); // Pass hasRexPrefix\n                \n                // Resolve rmOperand, noting it might be a register or memory\n                const rmOperand = this.resolveModRMOperand(modrm, sizeBytes, rex_x, rex_b, rexPrefix !== 0); // Pass hasRexPrefixForNaming\n\n                let sourceValue;\n                let destValue;\n                let destOperand; // This will store where the result should be written\n\n                // Determine source and destination based on D-bit\n                if (dBit === 0) { // AND r/m, reg (reg is source, r/m is dest)\n                    sourceValue = this.readRegister(regOpName, sizeBytes); // Source is the register specified by ModR/M.reg\n                    if (rmOperand.type === 'reg') {\n                        destValue = this.readRegister(rmOperand.name, sizeBytes);\n                        destOperand = rmOperand;\n                    } else { // Memory destination\n                        if (sizeBytes === 1) destValue = BigInt(this.readVirtualUint8(rmOperand.address));\n                        else if (sizeBytes === 2) destValue = BigInt(this.readVirtualUint16(rmOperand.address));\n                        else if (sizeBytes === 4) destValue = BigInt(this.readVirtualUint32(rmOperand.address));\n                        else if (sizeBytes === 8) destValue = this.readVirtualBigUint64(rmOperand.address);\n                        else throw new Error(\"Unsupported memory read size for AND (dBit=0).\");\n                        destOperand = rmOperand;\n                    }\n                } else { // dBit === 1: AND reg, r/m (r/m is source, reg is dest)\n                    destValue = this.readRegister(regOpName, sizeBytes); // Destination is the register specified by ModR/M.reg\n                    destOperand = { type: 'reg', name: regOpName }; // Set destination for writing\n\n                    if (rmOperand.type === 'reg') {\n                        sourceValue = this.readRegister(rmOperand.name, sizeBytes);\n                    } else { // Memory source\n                        if (sizeBytes === 1) sourceValue = BigInt(this.readVirtualUint8(rmOperand.address));\n                        else if (sizeBytes === 2) sourceValue = BigInt(this.readVirtualUint16(rmOperand.address));\n                        else if (sizeBytes === 4) sourceValue = BigInt(this.readVirtualUint32(rmOperand.address));\n                        else if (sizeBytes === 8) sourceValue = this.readVirtualBigUint64(rmOperand.address);\n                        else throw new Error(\"Unsupported memory read size for AND (dBit=1).\");\n                    }\n                }\n                \n                const result = destValue & sourceValue; // Perform AND operation\n\n                // For logical operations (AND, OR, XOR), CF and OF are always 0.\n                this.flags.cf = 0;\n                this.flags.of = 0;\n                this.flags.zf = (result === 0n) ? 1 : 0;\n                // SF is set if the most significant bit of the result is 1 (after masking to operand size)\n                const bitWidth = BigInt(sizeBytes * 8);\n                const signBitMask = 1n << (bitWidth - 1n);\n                this.flags.sf = ((result & signBitMask) !== 0n) ? 1 : 0;\n\n                // Write the result back to the destination operand\n                if (destOperand.type === 'reg') {\n                    this.writeRegister(destOperand.name, result, sizeBytes);\n                } else { // destOperand.type === 'mem'\n                    if (sizeBytes === 1) this.writeVirtualUint8(destOperand.address, Number(result));\n                    else if (sizeBytes === 2) this.writeVirtualUint16(destOperand.address, Number(result));\n                    else if (sizeBytes === 4) this.writeVirtualUint32(destOperand.address, Number(result));\n                    else if (sizeBytes === 8) this.writeVirtualBigUint64(destOperand.address, result);\n                    else throw new Error(\"Unsupported memory write size for AND.\");\n                }\n                \n                // Improved logging for AND\n                const destOperandString = destOperand.type === 'reg' ? destOperand.name.toUpperCase() : `[0x${destOperand.address.toString(16)}]`;\n                const srcOperandString = (dBit === 0) ? regOpName.toUpperCase() : (rmOperand.type === 'reg' ? rmOperand.name.toUpperCase() : `[0x${rmOperand.address.toString(16)}]`);\n                utils.log(`Decoded: AND ${destOperandString}, ${srcOperandString} (0x${destValue.toString(16)}n & 0x${sourceValue.toString(16)}n) -> Result: 0x${result.toString(16)}n`);\n                return true;\n            }\n\n            // XOR reg, r/m (0x31 / 0x33)\n            if (opcode === 0x31 || opcode === 0x33) {\n                const modrm = this.readModRMByte();\n                const dBit = (opcode >>> 1) & 0x01; \n                const wBit = opcode & 0x01;         \n\n                let sizeBytes = (wBit === 0) ? 1 : defaultOperandSize;\n\n                const regOpFullIndex = modrm.reg + (rex_r << 3);\n                const regOpName = this.getRegisterString(regOpFullIndex, sizeBytes, rexPrefix !== 0); // Pass hasRexPrefix\n                const rmOperand = this.resolveModRMOperand(modrm, sizeBytes, rex_x, rex_b, rexPrefix !== 0); // Pass hasRexPrefixForNaming\n\n                let sourceValue;\n                let destValue;\n                let destOperand;\n\n                if (rmOperand.type === 'reg') {\n                    if (dBit === 0) { \n                        sourceValue = this.readRegister(regOpName, sizeBytes);\n                        destValue = this.readRegister(rmOperand.name, sizeBytes);\n                        destOperand = rmOperand;\n                    } else { \n                        sourceValue = this.readRegister(rmOperand.name, sizeBytes);\n                        destValue = this.readRegister(regOpName, sizeBytes);\n                        destOperand = { type: 'reg', name: regOpName };\n                    }\n                } else { \n                    if (dBit === 0) { \n                        sourceValue = this.readRegister(regOpName, sizeBytes);\n                        if (sizeBytes === 1) destValue = BigInt(this.readVirtualUint8(rmOperand.address));\n                        else if (sizeBytes === 2) destValue = BigInt(this.readVirtualUint16(rmOperand.address));\n                        else if (sizeBytes === 4) destValue = BigInt(this.readVirtualUint32(rmOperand.address));\n                        else if (sizeBytes === 8) destValue = this.readVirtualBigUint64(rmOperand.address);\n                        else throw new Error(\"Unsupported memory read size for XOR.\");\n                        destOperand = rmOperand;\n                    } else { \n                        if (sizeBytes === 1) sourceValue = BigInt(this.readVirtualUint8(rmOperand.address));\n                        else if (sizeBytes === 2) sourceValue = BigInt(this.readVirtualUint16(rmOperand.address));\n                        else if (sizeBytes === 4) sourceValue = BigInt(this.readVirtualUint32(rmOperand.address));\n                        else if (sizeBytes === 8) sourceValue = this.readVirtualBigUint64(rmOperand.address);\n                        else throw new Error(\"Unsupported memory read size for XOR.\");\n                        destValue = this.readRegister(regOpName, sizeBytes);\n                        destOperand = { type: 'reg', name: regOpName };\n                    }\n                }\n                \n                const result = destValue ^ sourceValue; // Perform XOR operation\n\n                this.flags.cf = 0; \n                this.flags.of = 0; \n                this.flags.zf = (result === 0n) ? 1 : 0; \n                this.flags.sf = ((result >> (BigInt(sizeBytes * 8) - 1n)) & 1n) === 1n ? 1 : 0; \n\n                if (destOperand.type === 'reg') {\n                    this.writeRegister(destOperand.name, result, sizeBytes);\n                } else { \n                    if (sizeBytes === 1) this.writeVirtualUint8(destOperand.address, Number(result));\n                    else if (sizeBytes === 2) this.writeVirtualUint16(destOperand.address, Number(result));\n                    else if (sizeBytes === 4) this.writeVirtualUint32(destOperand.address, Number(result));\n                    else if (sizeBytes === 8) this.writeVirtualBigUint64(destOperand.address, result);\n                    else throw new Error(\"Unsupported memory write size for XOR.\");\n                }\n                utils.log(`Decoded: XOR ${destOperand.type === 'reg' ? destOperand.name.toUpperCase() : `[0x${destOperand.address.toString(16)}]`}, ${sourceValue.toString(16)}${sizeBytes === 8 ? 'n' : ''} -> Result: 0x${result.toString(16)}n`);\n                return true;\n            }\n\n            // SUB reg, r/m (0x29 / 0x2B)\n            if (opcode === 0x29 || opcode === 0x2B) {\n                const modrm = this.readModRMByte();\n                const dBit = (opcode >>> 1) & 0x01; // Direction bit\n                const wBit = opcode & 0x01;         // Width bit\n\n                let sizeBytes = (wBit === 0) ? 1 : defaultOperandSize;\n\n                const regOpFullIndex = modrm.reg + (rex_r << 3);\n                const regOpName = this.getRegisterString(regOpFullIndex, sizeBytes, rexPrefix !== 0); // Pass hasRexPrefix\n                const rmOperand = this.resolveModRMOperand(modrm, sizeBytes, rex_x, rex_b, rexPrefix !== 0); // Pass hasRexPrefixForNaming\n\n                let sourceValue; // Subtrahend\n                let destValue;   // Minuend\n                let destOperand; \n\n                if (rmOperand.type === 'reg') {\n                    if (dBit === 0) { // SUB r/m, reg (reg is subtrahend, r/m is minuend/dest)\n                        sourceValue = this.readRegister(regOpName, sizeBytes);\n                        destValue = this.readRegister(rmOperand.name, sizeBytes);\n                        destOperand = rmOperand; \n                    } else { // SUB reg, r/m (r/m is subtrahend, reg is minuend/dest)\n                        sourceValue = this.readRegister(rmOperand.name, sizeBytes);\n                        destValue = this.readRegister(regOpName, sizeBytes);\n                        destOperand = { type: 'reg', name: regOpName }; \n                    }\n                } else { // rmOperand.type === 'mem'\n                    if (dBit === 0) { // SUB r/m, reg (reg is subtrahend, r/m is minuend/dest)\n                        sourceValue = this.readRegister(regOpName, sizeBytes);\n                        if (sizeBytes === 1) destValue = BigInt(this.readVirtualUint8(rmOperand.address));\n                        else if (sizeBytes === 2) destValue = BigInt(this.readVirtualUint16(rmOperand.address));\n                        else if (sizeBytes === 4) destValue = BigInt(this.readVirtualUint32(rmOperand.address));\n                        else if (sizeBytes === 8) destValue = this.readVirtualBigUint64(rmOperand.address);\n                        else throw new Error(\"Unsupported memory read size for SUB.\");\n                        destOperand = rmOperand; \n                    } else { // SUB reg, r/m (r/m is subtrahend, reg is minuend/dest)\n                        if (sizeBytes === 1) sourceValue = BigInt(this.readVirtualUint8(rmOperand.address));\n                        else if (sizeBytes === 2) sourceValue = BigInt(this.readVirtualUint16(rmOperand.address));\n                        else if (sizeBytes === 4) sourceValue = BigInt(this.readVirtualUint32(rmOperand.address));\n                        else if (sizeBytes === 8) sourceValue = this.readVirtualBigUint64(rmOperand.address);\n                        else throw new Error(\"Unsupported memory read size for SUB.\");\n                        destValue = this.readRegister(regOpName, sizeBytes);\n                        destOperand = { type: 'reg', name: regOpName }; \n                    }\n                }\n                \n                const result = destValue - sourceValue;\n                this.updateArithmeticFlags(result, destValue, sourceValue, sizeBytes, 'sub');\n\n                if (destOperand.type === 'reg') {\n                    this.writeRegister(destOperand.name, result, sizeBytes);\n                } else { // destOperand.type === 'mem'\n                    if (sizeBytes === 1) this.writeVirtualUint8(destOperand.address, Number(result));\n                    else if (sizeBytes === 2) this.writeVirtualUint16(destOperand.address, Number(result));\n                    else if (sizeBytes === 4) this.writeVirtualUint32(destOperand.address, Number(result));\n                    else if (sizeBytes === 8) this.writeVirtualBigUint64(destOperand.address, result);\n                    else throw new Error(\"Unsupported memory write size for SUB.\");\n                }\n                utils.log(`Decoded: SUB ${destOperand.type === 'reg' ? destOperand.name.toUpperCase() : `[0x${destOperand.address.toString(16)}]`}, ${sourceValue.toString(16)}${sizeBytes === 8 ? 'n' : ''} -> Result: 0x${result.toString(16)}n`);\n                return true;\n            }\n\n            // CMP reg, r/m; CMP r/m, reg (0x39 / 0x3B for 32/64-bit, 0x38 / 0x3A for 8-bit)\n            if (opcode >= 0x38 && opcode <= 0x3B) {\n                const modrm = this.readModRMByte();\n                const dBit = (opcode >>> 1) & 0x01; // Direction bit\n                const wBit = opcode & 0x01;         // Width bit\n\n                let sizeBytes = (wBit === 0) ? 1 : defaultOperandSize;\n\n                const regOpFullIndex = modrm.reg + (rex_r << 3);\n                const regOpName = this.getRegisterString(regOpFullIndex, sizeBytes, rexPrefix !== 0); // Pass hasRexPrefix\n                const rmOperand = this.resolveModRMOperand(modrm, sizeBytes, rex_x, rex_b, rexPrefix !== 0); // Pass hasRexPrefixForNaming\n\n                let sourceValue; // Subtrahend\n                let destValue;   // Minuend\n\n                if (rmOperand.type === 'reg') {\n                    if (dBit === 0) { // CMP r/m, reg (reg is subtrahend, r/m is minuend)\n                        sourceValue = this.readRegister(regOpName, sizeBytes);\n                        destValue = this.readRegister(rmOperand.name, sizeBytes);\n                    } else { // CMP reg, r/m (r/m is subtrahend, reg is minuend)\n                        sourceValue = this.readRegister(rmOperand.name, sizeBytes);\n                        destValue = this.readRegister(regOpName, sizeBytes);\n                    }\n                } else { // rmOperand.type === 'mem'\n                    if (dBit === 0) { // CMP r/m, reg (reg is subtrahend, r/m is minuend)\n                        sourceValue = this.readRegister(regOpName, sizeBytes);\n                        if (sizeBytes === 1) destValue = BigInt(this.readVirtualUint8(rmOperand.address));\n                        else if (sizeBytes === 2) destValue = BigInt(this.readVirtualUint16(rmOperand.address));\n                        else if (sizeBytes === 4) destValue = BigInt(this.readVirtualUint32(rmOperand.address));\n                        else if (sizeBytes === 8) destValue = this.readVirtualBigUint64(rmOperand.address);\n                        else throw new Error(\"Unsupported memory read size for CMP.\");\n                    } else { // CMP reg, r/m (r/m is subtrahend, reg is minuend)\n                        if (sizeBytes === 1) sourceValue = BigInt(this.readVirtualUint8(rmOperand.address));\n                        else if (sizeBytes === 2) sourceValue = BigInt(this.readVirtualUint16(rmOperand.address));\n                        else if (sizeBytes === 4) sourceValue = BigInt(this.readVirtualUint32(rmOperand.address));\n                        else if (sizeBytes === 8) sourceValue = this.readVirtualBigUint64(rmOperand.address);\n                        else throw new Error(\"Unsupported memory read size for CMP.\");\n                        destValue = this.readRegister(regOpName, sizeBytes);\n                    }\n                }\n                \n                // Perform the subtraction for flags, but do not write the result back\n                const result = destValue - sourceValue;\n                this.updateArithmeticFlags(result, destValue, sourceValue, sizeBytes, 'sub');\n\n                const destOperandString = (dBit === 0) ? (rmOperand.type === 'reg' ? rmOperand.name.toUpperCase() : `[0x${rmOperand.address.toString(16)}]`) : regOpName.toUpperCase();\n                const srcOperandString = (dBit === 0) ? regOpName.toUpperCase() : (rmOperand.type === 'reg' ? rmOperand.name.toUpperCase() : `[0x${rmOperand.address.toString(16)}]`);\n                utils.log(`Decoded: CMP ${destOperandString}, ${srcOperandString} (0x${destValue.toString(16)}n - 0x${sourceValue.toString(16)}n)`);\n                return true;\n            }\n\n            // CMP r/m32, imm32 (0x81 /7)\n            if (opcode === 0x81) {\n                const modrm = this.readModRMByte();\n                if (modrm.reg === 7) {\n                    const imm32 = this.readSignedImmediate(4);\n                    let sizeBytes = 4;\n                    const rmOperand = this.resolveModRMOperand(modrm, sizeBytes, rex_x, rex_b, rexPrefix !== 0);\n\n                    let destValue;\n                    if (rmOperand.type === 'reg') {\n                        destValue = this.readRegister(rmOperand.name, sizeBytes);\n                    } else {\n                        destValue = BigInt(this.readVirtualUint32(rmOperand.address));\n                    }\n                    const result = destValue - imm32;\n                    this.updateArithmeticFlags(result, destValue, imm32, sizeBytes, 'sub');\n                    utils.log(`Decoded: CMP ${rmOperand.type === 'reg' ? rmOperand.name.toUpperCase() : `[0x${rmOperand.address.toString(16)}]`}, 0x${imm32.toString(16)}`);\n                    return true;\n                }\n            }\n\n            // Group 1 Instructions (ADD, OR, ADC, SBB, AND, SUB, XOR, CMP) with immediate\n            // 0x81: r/m, imm32\n            // 0x83: r/m, imm8 (sign-extended)\n            if (opcode === 0x81 || opcode === 0x83) {\n                const modrm = this.readModRMByte();\n                let sizeBytes = defaultOperandSize;\n\n                const rmOperand = this.resolveModRMOperand(modrm, sizeBytes, rex_x, rex_b, rexPrefix !== 0);\n\n                // Opcode 0x83 uses a sign-extended 8-bit immediate.\n                // Opcode 0x81 uses a 16/32-bit immediate.\n                const immediateSizeBytes = (opcode === 0x83) ? 1 : (sizeBytes === 2 ? 2 : 4);\n                const immediateValue = this.readSignedImmediate(immediateSizeBytes);\n\n                // Read the destination value\n                let destValue;\n                if (rmOperand.type === 'reg') {\n                    destValue = this.readRegister(rmOperand.name, sizeBytes);\n                } else { // Memory\n                    if (sizeBytes === 1) destValue = BigInt(this.readVirtualUint8(rmOperand.address));\n                    else if (sizeBytes === 2) destValue = BigInt(this.readVirtualUint16(rmOperand.address));\n                    else if (sizeBytes === 4) destValue = BigInt(this.readVirtualUint32(rmOperand.address));\n                    else destValue = this.readVirtualBigUint64(rmOperand.address);\n                }\n\n                let result;\n                let operation = 'unknown';\n\n                // The 'reg' field selects the operation\n                switch (modrm.reg) {\n                    case 0: // ADD\n                        operation = 'add';\n                        result = destValue + immediateValue;\n                        break;\n                    case 4: // AND\n                        operation = 'and';\n                        result = destValue & immediateValue;\n                        break;\n                    case 5: // SUB\n                        operation = 'sub';\n                        result = destValue - immediateValue;\n                        break;\n                    case 7: // CMP\n                        operation = 'sub'; // CMP performs a subtraction for flags\n                        result = destValue - immediateValue;\n                        break;\n                    // TODO: add OR(/1), ADC(/2), SBB(/3), XOR(/6) here later\n                    default:\n                        throw new Error(`Unsupported Group 1 operation with /reg=${modrm.reg}`);\n                }\n\n                // Update flags based on the operation\n                if (operation === 'add' || operation === 'sub') {\n                    this.updateArithmeticFlags(result, destValue, immediateValue, sizeBytes, operation);\n                } else { // Logical op (AND)\n                    this.flags.cf = 0;\n                    this.flags.of = 0;\n                    this.flags.zf = (result === 0n) ? 1 : 0;\n                    const signBitMask = 1n << (BigInt(sizeBytes * 8) - 1n);\n                    this.flags.sf = ((result & signBitMask) !== 0n) ? 1 : 0;\n                }\n\n                // For all operations except CMP, write the result back\n                if (modrm.reg !== 7) { // if not CMP\n                    if (rmOperand.type === 'reg') {\n                        this.writeRegister(rmOperand.name, result, sizeBytes);\n                    } else { // Memory\n                        if (sizeBytes === 1) this.writeVirtualUint8(rmOperand.address, Number(result));\n                        else if (sizeBytes === 2) this.writeVirtualUint16(rmOperand.address, Number(result));\n                        else if (sizeBytes === 4) this.writeVirtualUint32(rmOperand.address, Number(result));\n                        else this.writeVirtualBigUint64(rmOperand.address, result);\n                    }\n                }\n                \n                const mnemonic = ['ADD', 'OR', 'ADC', 'SBB', 'AND', 'SUB', 'XOR', 'CMP'][modrm.reg];\n                const rmStr = rmOperand.type === 'reg' ? rmOperand.name.toUpperCase() : `[0x${rmOperand.address.toString(16)}]`;\n                utils.log(`Decoded: ${mnemonic} ${rmStr}, 0x${immediateValue.toString(16)}`);\n                return true;\n            }\n\n            // CMP AL/AX/EAX/RAX, imm (0x3C / 0x3D)\n            if (opcode === 0x3C || opcode === 0x3D) {\n                const wBit = opcode & 0x01;\n                let sizeBytes = (wBit === 0) ? 1 : defaultOperandSize;\n\n                const regName = this.getRegisterString(0, sizeBytes, rexPrefix !== 0); // Always AL/AX/EAX/RAX\n                const regValue = this.readRegister(regName, sizeBytes);\n                \n                // Note: Even for CMP RAX, the immediate is only 32 bits and is sign-extended.\n                const immediateSize = (sizeBytes === 1) ? 1 : 4;\n                const immediateValue = this.readSignedImmediate(immediateSize);\n\n                const result = regValue - immediateValue;\n                this.updateArithmeticFlags(result, regValue, immediateValue, sizeBytes, 'sub');\n                \n                // CMP does not store the result, it only sets flags.\n\n                utils.log(`Decoded: CMP ${regName.toUpperCase()}, 0x${immediateValue.toString(16)}`);\n                return true;\n            }\n\n            // MOV r/m, reg; MOV reg, r/m (0x88, 0x89, 0x8A, 0x8B)\n            if (opcode >= 0x88 && opcode <= 0x8B) {\n                const modrm = this.readModRMByte();\n                const dBit = (opcode >>> 1) & 0x01;\n                const wBit = opcode & 0x01;         \n\n                let sizeBytes = (wBit === 0) ? 1 : defaultOperandSize;\n\n                const regOpFullIndex = modrm.reg + (rex_r << 3);\n                const regOpName = this.getRegisterString(regOpFullIndex, sizeBytes, rexPrefix !== 0); // Pass hasRexPrefix\n\n                const rmOperand = this.resolveModRMOperand(modrm, sizeBytes, rex_x, rex_b, rexPrefix !== 0); // Pass hasRexPrefixForNaming\n\n                let sourceValue;\n                let destOperand; \n\n                if (dBit === 0) { \n                    sourceValue = this.readRegister(regOpName, sizeBytes); \n                    destOperand = rmOperand; \n                    utils.log(`  Action: R/M(DEST) <- Reg(SRC)`);\n                } else { \n                    if (rmOperand.type === 'reg') {\n                        sourceValue = this.readRegister(rmOperand.name, sizeBytes);\n                    } else { \n                        if (sizeBytes === 1) sourceValue = BigInt(this.readVirtualUint8(rmOperand.address));\n                        else if (sizeBytes === 2) sourceValue = BigInt(this.readVirtualUint16(rmOperand.address));\n                        else if (sizeBytes === 4) sourceValue = BigInt(this.readVirtualUint32(rmOperand.address));\n                        else if (sizeBytes === 8) sourceValue = this.readVirtualBigUint64(rmOperand.address);\n                        else throw new Error(\"Unsupported memory read size.\");\n                    }\n                    destOperand = { type: 'reg', name: regOpName }; \n                    utils.log(`  Action: Reg(DEST) <- R/M(SRC)`);\n                }\n\n                if (destOperand.type === 'reg') {\n                    this.writeRegister(destOperand.name, sourceValue, sizeBytes);\n                } else { \n                    if (sizeBytes === 1) this.writeVirtualUint8(destOperand.address, Number(sourceValue));\n                    else if (sizeBytes === 2) this.writeVirtualUint16(destOperand.address, Number(sourceValue));\n                    else if (sizeBytes === 4) this.writeVirtualUint32(destOperand.address, Number(sourceValue));\n                    else if (sizeBytes === 8) this.writeVirtualBigUint64(destOperand.address, sourceValue);\n                    else throw new Error(\"Unsupported memory write size.\");\n                }\n\n                utils.log(`Decoded: MOV ${destOperand.type === 'reg' ? destOperand.name.toUpperCase() : `[0x${destOperand.address.toString(16)}]`}, 0x${sourceValue.toString(16)}${sizeBytes === 8 ? 'n' : ''}`);\n                return true;\n            }\n\n            // MOV r/m{16,32,64}, imm{16,32,64} (0xC7 /0)\n            if (opcode === 0xC7) {\n                const modrm = this.readModRMByte();\n                \n                // For 0xC7, the reg field in ModR/M should be 0\n                if (modrm.reg !== 0) {\n                    throw new Error(`Invalid ModR/M reg field for MOV r/m, imm: ${modrm.reg}`);\n                }\n                \n                // Determine operand size based on prefix and mode\n                let sizeBytes, targetSizeBytes;\n                if (rexPrefix !== 0 && (rexPrefix & 0x08)) {  // REX.W prefix\n                    sizeBytes = 4;  // 32-bit immediate sign-extended to 64-bit\n                    targetSizeBytes = 8;  // Target is 64-bit\n                } else if (this.operandSizeOverride) {\n                    sizeBytes = 2; // 16-bit with 66h prefix\n                    targetSizeBytes = 2;\n                } else {\n                    sizeBytes = 4; // 32-bit\n                    targetSizeBytes = 4;\n                }\n                \n                // Read immediate value\n                let immValue = this.readSignedImmediate(sizeBytes);\n                \n                // Sign extend to 64 bits if needed\n                if (sizeBytes === 4 && targetSizeBytes === 8) {\n                    immValue = BigInt.asIntN(32, immValue);\n                }\n                \n                // Resolve the destination operand with target size\n                const rmOperand = this.resolveModRMOperand(modrm, targetSizeBytes, rex_r, rex_b, rexPrefix !== 0);\n                \n                // Write the immediate to the destination\n                if (rmOperand.type === 'reg') {\n                    this.writeRegister(rmOperand.name, immValue, targetSizeBytes);\n                } else {\n                    // For memory destination, use the actual size of the immediate\n                    if (sizeBytes === 1) {\n                        this.writeVirtualUint8(rmOperand.address, Number(immValue));\n                    } else if (sizeBytes === 2) {\n                        this.writeVirtualUint16(rmOperand.address, Number(immValue));\n                    } else if (sizeBytes === 4) {\n                        this.writeVirtualUint32(rmOperand.address, Number(immValue));\n                    } else {\n                        throw new Error(`Unsupported size for MOV r/m, imm: ${sizeBytes} bytes`);\n                    }\n                }\n                \n                utils.log(`Decoded: MOV ${rmOperand.type === 'reg' ? rmOperand.name.toUpperCase() : `[0x${rmOperand.address.toString(16)}]`}, 0x${immValue.toString(16)}`);\n                return true;\n            }\n\n            // MOV r/m8, imm8 (0xC6 /0)\n            if (opcode === 0xC6) {\n                const modrm = this.readModRMByte();\n            \n                if (modrm.reg !== 0) {\n                    throw new Error(`Invalid ModR/M reg field for MOV r/m8, imm8: ${modrm.reg}`);\n                }\n            \n                const rmOperand = this.resolveModRMOperand(modrm, 1, rex_r, rex_b, rexPrefix !== 0);\n            \n                const immValue = this.readSignedImmediate(1); // Reads and advances RIP by 1\n            \n                if (rmOperand.type === 'reg') {\n                    this.writeRegister(rmOperand.name, immValue, 1);\n                } else {\n                    this.writeVirtualUint8(rmOperand.address, Number(immValue));\n                }\n            \n                utils.log(`Decoded: MOV byte ${rmOperand.type === 'reg' ? rmOperand.name.toUpperCase() : `[0x${rmOperand.address.toString(16)}]`}, 0x${immValue.toString(16)}`);\n                return true;\n            }\n\n            // PUSH reg (0x50 + reg_index)\n            if (opcode >= 0x50 && opcode <= 0x57) {\n                const regIdx = opcode - 0x50;\n                const sizeBytes = 8;\n                const regName = this.getRegisterString(regIdx, sizeBytes, rexPrefix !== 0);\n                const value = this.readRegister(regName, sizeBytes);\n                utils.log(`PUSH ${regName.toUpperCase()} - RSP Before: 0x${this.rsp.toString(16)}`);\n                this.rsp -= BigInt(sizeBytes);\n                this.writeVirtualBigUint64(this.rsp, value);\n                utils.log(`Decoded: PUSH ${regName.toUpperCase()} (0x${value.toString(16)}n)`);\n                utils.log(`PUSH ${regName.toUpperCase()} - RSP After: 0x${this.rsp.toString(16)}`);\n                return true;\n            }\n\n            // PUSH r/m (0xFF /6)\n            if (opcode === 0xFF) {\n                const modrm = this.readModRMByte();\n                if (modrm.reg === 6) { // PUSH r/m\n                    let sizeBytes = defaultOperandSize;\n                    const rmOperand = this.resolveModRMOperand(modrm, sizeBytes, rex_x, rex_b, rexPrefix !== 0);\n                    \n                    let value;\n                    if (rmOperand.type === 'reg') {\n                        value = this.readRegister(rmOperand.name, sizeBytes);\n                    } else {\n                        if (sizeBytes === 1) value = BigInt(this.readVirtualUint8(rmOperand.address));\n                        else if (sizeBytes === 2) value = BigInt(this.readVirtualUint16(rmOperand.address));\n                        else if (sizeBytes === 4) value = BigInt(this.readVirtualUint32(rmOperand.address));\n                        else if (sizeBytes === 8) value = this.readVirtualBigUint64(rmOperand.address);\n                        else throw new Error(\"Unsupported memory read size for PUSH r/m.\");\n                    }\n                    utils.log(`PUSH ${rmOperand.type === 'reg' ? rmOperand.name.toUpperCase() : `[0x${rmOperand.address.toString(16)}]`} - RSP Before: 0x${this.rsp.toString(16)}`);\n                    this.rsp -= BigInt(sizeBytes);\n                    this.writeVirtualBigUint64(this.rsp, value);\n                    \n                    utils.log(`Decoded: PUSH ${rmOperand.type === 'reg' ? rmOperand.name.toUpperCase() : `[0x${rmOperand.address.toString(16)}]`} (0x${value.toString(16)}n)`);\n                    utils.log(`PUSH ${rmOperand.type === 'reg' ? rmOperand.name.toUpperCase() : `[0x${rmOperand.address.toString(16)}]`} - RSP After: 0x${this.rsp.toString(16)}`);\n                    return true;\n                }\n            }\n\n            // POP reg (0x58 + reg_index)\n            if (opcode >= 0x58 && opcode <= 0x5F) {\n                const regIdx = opcode - 0x58;\n                const sizeBytes = 8;\n                const regName = this.getRegisterString(regIdx, sizeBytes, rexPrefix !== 0);\n                utils.log(`POP ${regName.toUpperCase()} - RSP Before: 0x${this.rsp.toString(16)}`);\n                const value = this.readVirtualBigUint64(this.rsp);\n                this.writeRegister(regName, value, sizeBytes);\n                this.rsp += BigInt(sizeBytes);\n                \n                utils.log(`Decoded: POP ${regName.toUpperCase()} (0x${value.toString(16)}n)`);\n                utils.log(`POP ${regName.toUpperCase()} - RSP After: 0x${this.rsp.toString(16)}`);\n                return true;\n            }\n\n            // POP r/m (0x8F /0)\n            if (opcode === 0x8F) {\n                const modrm = this.readModRMByte();\n                if (modrm.reg === 0) { // POP r/m\n                    let sizeBytes = defaultOperandSize;\n                    const rmOperand = this.resolveModRMOperand(modrm, sizeBytes, rex_x, rex_b, rexPrefix !== 0);\n                    \n                    utils.log(`POP ${rmOperand.type === 'reg' ? rmOperand.name.toUpperCase() : `[0x${rmOperand.address.toString(16)}]`} - RSP Before: 0x${this.rsp.toString(16)}`);\n                    this.rsp += BigInt(sizeBytes);\n                    this.writeRegister(rmOperand.name, value, sizeBytes);\n\n                    let value;\n                    if (rmOperand.type === 'reg') {\n                        value = this.readRegister(rmOperand.name, sizeBytes);\n                    } else {\n                        if (sizeBytes === 1) value = BigInt(this.readVirtualUint8(rmOperand.address));\n                        else if (sizeBytes === 2) value = BigInt(this.readVirtualUint16(rmOperand.address));\n                        else if (sizeBytes === 4) value = BigInt(this.readVirtualUint32(rmOperand.address));\n                        else if (sizeBytes === 8) value = this.readVirtualBigUint64(rmOperand.address);\n                        else throw new Error(\"Unsupported memory read size for POP r/m.\");\n                    }\n\n                    utils.log(`Decoded: POP ${rmOperand.type === 'reg' ? rmOperand.name.toUpperCase() : `[0x${rmOperand.address.toString(16)}]`} (0x${value.toString(16)}n)`);\n                    utils.log(`POP ${rmOperand.type === 'reg' ? rmOperand.name.toUpperCase() : `[0x${rmOperand.address.toString(16)}]`} - RSP After: 0x${this.rsp.toString(16)}`);\n                    return true;\n                }\n            }\n\n            // CALL rel32 (0xE8) - Near, relative, 32-bit displacement\n            if (opcode === 0xE8) {\n                const displacement = this.readSignedImmediate(4);\n                const retAddr = this.rip;\n                utils.log(`CALL rel32 - RSP Before: 0x${this.rsp.toString(16)}`);\n                this.rsp -= 8n;\n                this.writeVirtualBigUint64(this.rsp, retAddr);\n                this.rip += BigInt(displacement);\n\n                utils.log(`Decoded: CALL rel32 0x${displacement.toString(16)} (RIP adjusted to 0x${this.rip.toString(16)})`);\n                utils.log(`CALL rel32 - RSP After: 0x${this.rsp.toString(16)}`);\n                return true;\n            }\n\n            // CALL r/m (0xFF /2) - Near, absolute, indirect\n            if (opcode === 0xFF) {\n                const modrm = this.readModRMByte();\n                if (modrm.reg === 2) { // opcode extension /2\n                    let sizeBytes = defaultOperandSize;\n                    const rmOperand = this.resolveModRMOperand(modrm, sizeBytes, rex_x, rex_b, rexPrefix !== 0);\n                    \n                    let tgtAddr;\n                    if (rmOperand.type === 'reg') {\n                        tgtAddr = this.readRegister(rmOperand.name, sizeBytes);\n                    } else {\n                        if (sizeBytes === 1) tgtAddr = BigInt(this.readVirtualUint8(rmOperand.address));\n                        else if (sizeBytes === 2) tgtAddr = BigInt(this.readVirtualUint16(rmOperand.address));\n                        else if (sizeBytes === 4) tgtAddr = BigInt(this.readVirtualUint32(rmOperand.address));\n                        else if (sizeBytes === 8) tgtAddr = this.readVirtualBigUint64(rmOperand.address);\n                        else throw new Error(\"Unsupported memory read size for CALL r/m.\");\n                    }\n                    \n                    const retAddr = this.rip;\n                    utils.log(`CALL r/m - RSP Before: 0x${this.rsp.toString(16)}`);\n                    this.rsp -= 8n;\n                    this.writeVirtualBigUint64(this.rsp, retAddr);\n                    this.rip = tgtAddr;\n\n                    utils.log(`Decoded: CALL ${rmOperand.type === 'reg' ? rmOperand.name.toUpperCase() : `[0x${rmOperand.address.toString(16)}]`} (Indirect, jumping to 0x${this.rip.toString(16)})`);\n                    utils.log(`CALL r/m - RSP After: 0x${this.rsp.toString(16)}`);\n                    return true;\n                }\n            }\n\n            // RET (0xC3) - Near return\n            if (opcode === 0xC3) {\n                utils.log(`RET - RSP Before: 0x${this.rsp.toString(16)}`);\n                const retAddr = this.readVirtualBigUint64(this.rsp);\n                this.rsp += 8n;\n                this.rip = retAddr;\n\n                utils.log(`Decoded: RET (Near, jumping to 0x${this.rip.toString(16)})`);\n                utils.log(`RET - RSP After: 0x${this.rsp.toString(16)}`);\n                return true;\n            }\n\n            // RET imm16 (0xC2) - Near, return with immediate\n            if (opcode === 0xC2) {\n                const imm16 = this.readSignedImmediate(2);\n                utils.log(`RET imm16 - RSP Before: 0x${this.rsp.toString(16)}`);\n                const retAddr = this.readVirtualBigUint64(this.rsp);\n                this.rsp += 8n;\n                this.rip = retAddr;\n                this.rsp += BigInt(imm16);\n\n                utils.log(`Decoded: RET imm16 (jumping to 0x${this.rip.toString(16)}, stack adjust by 0x${imm16.toString(16)})`);\n                utils.log(`RET imm16 - RSP After: 0x${this.rsp.toString(16)}`);\n                return true;\n            }\n\n            // LEA r/m, reg (0x8D)\n            if (opcode === 0x8D) {\n                const modrm = this.readModRMByte();\n                // LEA only works with memory sources, so mod must not be 3\n                if (modrm.mod === 3) {\n                    throw new Error(\"Invalid use of LEA with register source.\");\n                }\n\n                let sizeBytes = defaultOperandSize;\n                // Note: In 64-bit mode, operand size can be 16, 32, or 64.\n                // REX.W=1 -> 64-bit. No REX.W -> 32-bit. 0x66 prefix -> 16-bit.\n\n                const destRegFullIndex = modrm.reg + (rex_r << 3);\n                const destRegName = this.getRegisterString(destRegFullIndex, sizeBytes, rexPrefix !== 0);\n\n                // Here's the magic: we use resolveModRMOperand to get the address\n                const memOperand = this.resolveModRMOperand(modrm, sizeBytes, rex_x, rex_b, rexPrefix !== 0);\n                const effectiveAddress = memOperand.address;\n\n                // ...but we write the address itself to the destination register.\n                this.writeRegister(destRegName, effectiveAddress, sizeBytes);\n\n                utils.log(`Decoded: LEA ${destRegName.toUpperCase()}, [address] (Calculated address: 0x${effectiveAddress.toString(16)})`);\n                return true;\n            }\n\n            // TEST r/m, reg (0x84, 0x85)\n            if (opcode === 0x84 || opcode === 0x85) {\n                const modrm = this.readModRMByte();\n                const wBit = opcode & 0x01;\n                let sizeBytes = (wBit === 0) ? 1 : defaultOperandSize;\n\n                const regOpFullIndex = modrm.reg + (rex_r << 3);\n                const regOpName = this.getRegisterString(regOpFullIndex, sizeBytes, rexPrefix !== 0);\n                const rmOperand = this.resolveModRMOperand(modrm, sizeBytes, rex_x, rex_b, rexPrefix !== 0);\n\n                let val1, val2;\n                val1 = this.readRegister(regOpName, sizeBytes); // Operand from reg field\n\n                if (rmOperand.type === 'reg') {\n                    val2 = this.readRegister(rmOperand.name, sizeBytes);\n                } else { // Memory operand\n                    if (sizeBytes === 1) val2 = BigInt(this.readVirtualUint8(rmOperand.address));\n                    else if (sizeBytes === 2) val2 = BigInt(this.readVirtualUint16(rmOperand.address));\n                    else if (sizeBytes === 4) val2 = BigInt(this.readVirtualUint32(rmOperand.address));\n                    else val2 = this.readVirtualBigUint64(rmOperand.address);\n                }\n\n                const result = val1 & val2;\n\n                // TEST sets flags based on the result but doesn't store it\n                this.flags.cf = 0;\n                this.flags.of = 0;\n                this.flags.zf = (result === 0n) ? 1 : 0;\n                const signBitMask = 1n << (BigInt(sizeBytes * 8) - 1n);\n                this.flags.sf = ((result & signBitMask) !== 0n) ? 1 : 0;\n                // Parity Flag (PF) is also affected, but you can add that later.\n\n                const rmOperandStr = rmOperand.type === 'reg' ? rmOperand.name.toUpperCase() : `[0x${rmOperand.address.toString(16)}]`;\n                utils.log(`Decoded: TEST ${rmOperandStr}, ${regOpName.toUpperCase()}`);\n                return true;\n            }\n\n            // TEST AL, imm8 (0xA8)\n            if (opcode === 0xA8) {\n                const imm8 = this.readSignedImmediate(1);\n                const alValue = this.readRegister('al', 1);\n                const result = alValue & imm8;\n\n                // TEST instruction updates flags but does not store the result.\n                // It performs a bitwise AND and sets flags based on the outcome.\n                this.flags.cf = 0; // Cleared by TEST\n                this.flags.of = 0; // Cleared by TEST\n\n                this.flags.zf = (result === 0n) ? 1 : 0;\n                this.flags.sf = ((result & 0x80n) !== 0n) ? 1 : 0;\n                // Note: Parity Flag (PF) is also affected but not implemented here.\n\n                utils.log(`Decoded: TEST AL, 0x${imm8.toString(16)} (Result for flags: 0x${result.toString(16)})`);\n                return true;\n            }\n\n            // TEST AX/EAX/RAX, imm16/imm32 (0xA9)\n            if (opcode === 0xA9) {\n                let sizeBytes = defaultOperandSize;\n\n                // Determine the size of the immediate value. \n                // For 64-bit operations, the immediate is a 32-bit value.\n                const immediateSizeBytes = (sizeBytes === 8) ? 4 : sizeBytes;\n                const immediateValue = this.readSignedImmediate(immediateSizeBytes);\n                \n                const regName = this.getRegisterString(0, sizeBytes, rexPrefix !== 0); // Accumulator (AX/EAX/RAX)\n                const regValue = this.readRegister(regName, sizeBytes);\n\n                const result = regValue & immediateValue;\n\n                // TEST updates flags and discards the result.\n                this.flags.cf = 0;\n                this.flags.of = 0;\n\n                this.flags.zf = (result === 0n) ? 1 : 0;\n                \n                // Set Sign Flag if the most significant bit of the result is 1.\n                const signBitMask = 1n << (BigInt(sizeBytes * 8) - 1n);\n                this.flags.sf = ((result & signBitMask) !== 0n) ? 1 : 0;\n                // Note: Parity Flag (PF) is also affected but not implemented here.\n\n                utils.log(`Decoded: TEST ${regName.toUpperCase()}, 0x${immediateValue.toString(16)} (Result for flags: 0x${result.toString(16)})`);\n                return true;\n            }\n\n            // Group 2 Immediate Instructions (ROL, ROR, RCL, RCR, SHL, SHR, SAR)\n            if (opcode === 0xC0 || opcode === 0xC1) {\n                const modrm = this.readModRMByte();\n                const wBit = opcode & 0x01;\n                let sizeBytes = (wBit === 0) ? 1 : defaultOperandSize;\n                \n                const rmOperand = this.resolveModRMOperand(modrm, sizeBytes, rex_x, rex_b, rexPrefix !== 0);\n                const shiftCount = this.readSignedImmediate(1); // imm8\n\n                // Read the value to be shifted\n                let value;\n                if (rmOperand.type === 'reg') {\n                    value = this.readRegister(rmOperand.name, sizeBytes);\n                } else {\n                    // Read from memory\n                    if (sizeBytes === 1) value = BigInt(this.readVirtualUint8(rmOperand.address));\n                    else if (sizeBytes === 2) value = BigInt(this.readVirtualUint16(rmOperand.address));\n                    else if (sizeBytes === 4) value = BigInt(this.readVirtualUint32(rmOperand.address));\n                    else value = this.readVirtualBigUint64(rmOperand.address);\n                }\n\n                let result;\n                let mnemonic = \"UNKNOWN_SHIFT\";\n\n                // The 'reg' field of ModR/M acts as an opcode extension here\n                switch (modrm.reg) {\n                    case 4: // SHL\n                        mnemonic = \"SHL\";\n                        result = value << shiftCount;\n                        // TODO: Set CF and OF correctly for SHL\n                        break;\n                    case 5: // SHR\n                        mnemonic = \"SHR\";\n                        result = value >> shiftCount;\n                        // TODO: Set CF and OF correctly for SHR\n                        break;\n                    // Add other shifts like SAR (case 7) here\n                    default:\n                        throw new Error(`Unhandled Group 2 instruction with /reg=${modrm.reg}`);\n                }\n\n                // Update flags (simplified for now)\n                this.flags.zf = (result === 0n) ? 1 : 0;\n                // SF update needs to consider the size\n                const bitWidth = BigInt(sizeBytes * 8);\n                const signBitMask = 1n << (bitWidth - 1n);\n                this.flags.sf = ((result & signBitMask) !== 0n) ? 1 : 0;\n\n                // Write the result back\n                if (rmOperand.type === 'reg') {\n                    this.writeRegister(rmOperand.name, result, sizeBytes);\n                } else {\n                    // Write to memory\n                    if (sizeBytes === 1) this.writeVirtualUint8(rmOperand.address, Number(result));\n                    else if (sizeBytes === 2) this.writeVirtualUint16(rmOperand.address, Number(result));\n                    else if (sizeBytes === 4) this.writeVirtualUint32(rmOperand.address, Number(result));\n                    else this.writeVirtualBigUint64(rmOperand.address, result);\n                }\n\n                const rmOperandStr = rmOperand.type === 'reg' ? rmOperand.name.toUpperCase() : `[0x${rmOperand.address.toString(16)}]`;\n                utils.log(`Decoded: ${mnemonic} ${rmOperandStr}, ${shiftCount}`);\n                return true;\n            }\n\n            // JL rel8 (0x7C)\n            if (opcode === 0x7C) {\n                const displacement = this.readSignedImmediate(1);\n                utils.log(`Decoded: JL rel8 0x${displacement.toString(16)}`);\n                if (this.flags.sf !== this.flags.of) { // Condition for JL\n                    this.rip += displacement;\n                    utils.log(`  Condition Met (SF!=OF). Jumping to 0x${this.rip.toString(16)}`);\n                } else {\n                    utils.log(`  Condition Not Met. Not jumping.`);\n                }\n                return true;\n            }\n\n            // JB rel8 (0x72)\n            if (opcode === 0x72) {\n                const displacement = this.readSignedImmediate(1);\n                utils.log(`Decoded: JB rel8 0x${displacement.toString(16)}`);\n                if (this.flags.cf !== 0) { // Condition for JB\n                    this.rip += displacement;\n                    utils.log(`  Condition Met (CF!=0). Jumping to 0x${this.rip.toString(16)}`);\n                } else {\n                    utils.log(`  Condition Not Met. Not jumping.`);\n                }\n                return true;\n            }\n\n            // JMP rel8 (0xEB)\n            if (opcode === 0xEB) {\n                // Read the 8-bit signed relative displacement\n                const displacement = this.readSignedImmediate(1);\n                \n                // Add the displacement to the current RIP to perform the jump\n                this.rip += displacement;\n                \n                utils.log(`Decoded: JMP rel8 0x${displacement.toString(16)} (Jumping to 0x${this.rip.toString(16)})`);\n                return true;\n            }\n\n            // IRETQ (0xCF)\n            if (opcode === 0xCF) {\n                // For a return from a Page Fault (#14), an error code was pushed\n                // after RIP/CS/RFLAGS. We need to pop and discard it.\n                // A more advanced handler would handle interrupts that *don't*\n                // push an error code, but for this test, this is correct.\n                this.rsp += 8n; // Discard the error code from the stack\n\n                // Pop RIP\n                this.rip = this.readVirtualBigUint64(this.rsp);\n                this.rsp += 8n;\n\n                // Pop CS - we don't use it yet, but we must advance the stack\n                const new_cs = this.readVirtualBigUint64(this.rsp);\n                this.rsp += 8n;\n                \n                // Pop RFLAGS and update the flags object\n                const new_rflags = this.readVirtualBigUint64(this.rsp);\n                this.disassembleRFlags(new_rflags);\n                this.rsp += 8n;\n                \n                utils.log(`Decoded: IRETQ (Returning to 0x${this.rip.toString(16)}, restoring flags)`);\n                return true;\n            }\n\n            // OUT DX, AL (0xEE)\n            if (opcode === 0xEE) {\n                // The port number is read from the 16-bit DX register\n                const port = this.readRegister('dx', 2);\n                const value = this.readRegister('al', 1);\n                \n                this.io.portOut(Number(port), Number(value), 1); // size is 1 byte\n                \n                utils.log(`Decoded: OUT DX, AL (Wrote 0x${value.toString(16)} to port 0x${port.toString(16)})`);\n                return true;\n            }\n\n            // OUT imm8, AL (0xE6)\n            if (opcode === 0xE6) {\n                const port = this.readInstructionByte(); // Read the port number from the instruction\n                const value = this.readRegister('al', 1); // Get the value from the AL register\n                \n                this.io.portOut(port, Number(value), 1); // Send the data to the I/O bus\n\n                utils.log(`Decoded: OUT imm8, AL (Wrote 0x${value.toString(16)} to port 0x${port.toString(16)})`);\n                return true;\n            }\n\n            // LODSB (0xAC)\n            if (opcode === 0xAC) {\n                // 1. Read the byte from memory at [RSI]\n                const value = this.readVirtualUint8(this.rsi);\n                \n                // 2. Put that byte into AL\n                this.writeRegister('al', value, 1);\n                \n                // 3. Increment RSI by 1\n                // (Note: A full implementation would check the Direction Flag (DF),\n                // but the default is to increment, which is all we need here).\n                this.rsi += 1n;\n    \n                utils.log(`Decoded: LODSB (Loaded 0x${value.toString(16)} into AL, RSI is now 0x${this.rsi.toString(16)})`);\n                return true;\n            }\n\n            // IN AL, imm8 (0xE4)\n            if (opcode === 0xE4) {\n                const port = this.readInstructionByte(); // Read 8-bit port from instruction\n                const value = this.io.portIn(port, 1);   // Read 1 byte from the I/O bus\n                this.writeRegister('al', value, 1);      // Write the value to AL\n\n                utils.log(`Decoded: IN AL, imm8 (Read 0x${value.toString(16)} from port 0x${port.toString(16)} into AL)`);\n                return true;\n            }\n\n            // IN AL, DX (0xEC)\n            if (opcode === 0xEC) {\n                const port = this.readRegister('dx', 2);   // Read 16-bit port from DX\n                const value = this.io.portIn(Number(port), 1); // Read 1 byte from the I/O bus\n                this.writeRegister('al', value, 1);        // Write the value to AL\n\n                utils.log(`Decoded: IN AL, DX (Read 0x${value.toString(16)} from port 0x${port.toString(16)} into AL)`);\n                return true;\n            }\n\n            // If an instruction falls through all specific handlers, it's truly unknown\n            utils.log(`Unknown opcode: 0x${(twoByteOpcode ? '0F ' : '')}${opcode.toString(16)} at 0x${currentRIPBeforeFetch.toString(16)}`); // Use currentRIPBeforeFetch for unknown opcodes\n            return false;\n        } catch (e) {\n            if (e instanceof PageFaultException) {\n                console.warn(`--- Caught Page Fault at RIP 0x${currentRIPBeforeFetch.toString(16)}. Invoking handler. ---`);\n                this.rip = currentRIPBeforeFetch; // IMPORTANT: Restore RIP to the address of the *faulting* instruction\n                this.triggerInterrupt(14, e.errorCode);\n            } else {\n                console.error(`Fatal error during execution at RIP 0x${currentRIPBeforeFetch.toString(16)}:`, e);\n                throw e;\n            }\n        }\n        return true;\n    }\n\n    readInstructionByte() {\n        let byte;\n        // Instruction fetches (RIP-relative access) depend on current mode and paging state\n        // If Protected Mode (CR0.PE) is enabled, all accesses are virtual from instruction stream's perspective.\n        // The translateVirtualToPhysical will handle the specific paging checks (PG, PAE, LME).\n        if ((this.cr0 & CPU.CR0_PE) !== 0n) { \n            byte = this.readVirtualUint8(this.rip);\n        } else { // Real Mode\n            byte = this.memory.readUint8(Number(this.rip));\n        }\n        this.rip++;\n        return byte;\n    }\n\n    readModRMByte() {\n        // ModR/M byte is also part of the instruction stream, so it should use readInstructionByte logic\n        // This ensures it correctly reads from virtual or physical memory.\n        const modrm = this.readInstructionByte(); \n        const mod = (modrm >>> 6) & 0x03;\n        const reg = (modrm >>> 3) & 0x07;\n        const rm = modrm & 0x07;\n        return { mod, reg, rm, raw: modrm };\n    }\n\n    getRegisterString(regIndex, sizeBytes, hasRexPrefix = false) {\n        const regNames64 = ['rax', 'rcx', 'rdx', 'rbx', 'rsp', 'rbp', 'rsi', 'rdi', 'r8', 'r9', 'r10', 'r11', 'r12', 'r13', 'r14', 'r15'];\n        const regNames32 = ['eax', 'ecx', 'edx', 'ebx', 'esp', 'ebp', 'esi', 'edi', 'r8d', 'r9d', 'r10d', 'r11d', 'r12d', 'r13d', 'r14d', 'r15d'];\n        const regNames16 = ['ax', 'cx', 'dx', 'bx', 'sp', 'bp', 'si', 'di', 'r8w', 'r9w', 'r10w', 'r11w', 'r12w', 'r13w', 'r14w', 'r15w'];\n        \n        // Arrays for 8-bit register naming based on REX prefix presence\n        const regNames8Low = ['al', 'cl', 'dl', 'bl']; // Indices 0-3 (always same)\n        const regNames8HighNoRex = ['ah', 'ch', 'dh', 'bh']; // Indices 4-7 (if NO REX prefix)\n        const regNames8NewRex = ['spl', 'bpl', 'sil', 'dil']; // Indices 4-7 (if REX prefix IS present)\n        const regNames8Extended = ['r8b', 'r9b', 'r10b', 'r11b', 'r12b', 'r13b', 'r14b', 'r15b']; // Indices 8-15 (always used with REX)\n\n        if (regIndex < 0 || regIndex > 15) {\n            throw new Error(`Invalid register index: ${regIndex}`);\n        }\n\n        switch (sizeBytes) {\n            case 1:\n                if (regIndex >= 8) { // Registers R8B-R15B (always require REX to be accessed by these names)\n                    return regNames8Extended[regIndex - 8];\n                } else if (regIndex >= 4) { // Registers AX/CX/DX/BX's high byte or SPL/BPL/SIL/DIL\n                    if (hasRexPrefix) {\n                        return regNames8NewRex[regIndex - 4];\n                    } else {\n                        return regNames8HighNoRex[regIndex - 4];\n                    }\n                } else { // Registers AL/CL/DL/BL\n                    return regNames8Low[regIndex];\n                }\n            case 2: return regNames16[regIndex];\n            case 4: return regNames32[regIndex];\n            case 8: return regNames64[regIndex];\n            default: throw new Error(`Invalid register size for naming: ${sizeBytes}`);\n        }\n    }\n\n    readSignedImmediate(sizeBytes) {\n        let value;\n        let rawValue; \n        \n        // Use readVirtualUintX if Protected Mode is enabled, otherwise use physical\n        const getRawValue = (currentRip, numBytes) => {\n            if ((this.cr0 & CPU.CR0_PE) !== 0n) { // If Protected Mode is enabled\n                if (numBytes === 1) return this.readVirtualUint8(currentRip);\n                else if (numBytes === 2) return this.readVirtualUint16(currentRip);\n                else if (numBytes === 4) return this.readVirtualUint32(currentRip);\n                else if (numBytes === 8) return this.readVirtualBigUint64(currentRip); \n            } else { // Real Mode\n                if (numBytes === 1) return this.memory.readUint8(Number(currentRip));\n                else if (numBytes === 2) return this.memory.readUint16(Number(currentRip));\n                else if (numBytes === 4) return this.memory.readUint32(Number(currentRip));\n                else if (numBytes === 8) return this.memory.readBigUint64(Number(currentRip)); \n            }\n            throw new Error(`Unsupported size for raw signed immediate read: ${numBytes}`);\n        };\n\n\n        if (sizeBytes === 1) {\n            rawValue = getRawValue(this.rip, 1);\n            this.rip += 1n;\n            value = rawValue;\n            if (value & 0x80) value = value - 0x100; \n        } else if (sizeBytes === 2) {\n            rawValue = getRawValue(this.rip, 2);\n            this.rip += 2n;\n            value = rawValue;\n            if (value & 0x8000) value = value - 0x10000; \n        } else if (sizeBytes === 4) {\n            rawValue = getRawValue(this.rip, 4);\n            this.rip += 4n;\n            value = rawValue;\n            if (value & 0x80000000) value = value - 0x100000000; \n        } else if (sizeBytes === 8) { \n            rawValue = getRawValue(this.rip, 8);\n            this.rip += 8n;\n            return rawValue; \n        } else {\n            throw new Error(`Invalid immediate size for signed read: ${sizeBytes}`); \n        }\n        return BigInt(value); \n    }\n\n    readSIBByte(mod) {\n        const sib = this.readInstructionByte();\n        const scaleBits = (sib >>> 6) & 0x03;\n        const indexBits = (sib >>> 3) & 0x07;\n        const baseBits = sib & 0x07;\n\n        // Scale is either 1, 2, 4, or 8\n        const scale = 1 << scaleBits;\n\n        const idxRegName = this.getRegisterString(indexBits, 8, false);\n        const baseRegName = this.getRegisterString(baseBits, 8, false);\n\n        let baseValue = 0n;\n\n        // Special case: if base is RBP/EBP and mod is 00, there is no base register\n        if (!(baseBits === 5 && mod === 0)) {\n            baseValue = this.readRegister(baseRegName, 8);\n        }\n\n        let indexValue = 0n;\n       // Special case: if index is RSP, there is no index register\n        if (indexBits !== 4) {\n            indexValue = this.readRegister(idxRegName, 8);\n        }\n\n        const addr = baseValue + (indexValue * BigInt(scale));\n        utils.log(`  SIB Decoded: Base=${baseRegName}, Index=${idxRegName}, Scale=${scale} => Address component = 0x${addr.toString(16)}`);\n        return addr;\n    }\n\n    resolveModRMOperand(modrm, sizeBytes, rex_x, rex_b, hasRexPrefixForNaming) {\n        if (modrm.mod === 0x03) {\n            const rmIndex = modrm.rm + (rex_b << 3);\n            return { type: 'reg', name: this.getRegisterString(rmIndex, sizeBytes, hasRexPrefixForNaming) };\n        }\n\n        let effectiveAddress = 0n;\n        let displacement = 0n;\n        const sibPresent = (modrm.rm === 0x04);\n\n        // --- Step 1: Calculate Base + Index*Scale ---\n        if (sibPresent) {\n            const sib = this.readInstructionByte();\n            const scale = 1 << ((sib >>> 6) & 0x03);\n            const indexBits = ((sib >>> 3) & 0x07) + (rex_x << 3);\n            const baseBits = (sib & 0x07) + (rex_b << 3);\n\n            // Add Index * Scale (if index is not RSP)\n            if (indexBits !== 4) {\n                const indexRegName = this.getRegisterString(indexBits, 8, true);\n                effectiveAddress += this.readRegister(indexRegName, 8) * BigInt(scale);\n            }\n\n            // Add Base register. The special disp32-only case is handled below.\n            if (modrm.mod !== 0x00 || baseBits !== 5) {\n                const baseRegName = this.getRegisterString(baseBits, 8, true);\n                effectiveAddress += this.readRegister(baseRegName, 8);\n            }\n\n        } else if (modrm.rm === 0x05) {\n            // RIP-relative addressing is a disp32 added to the *next* RIP\n            effectiveAddress = this.rip; // Base for calculation is the RIP after this instruction\n        } else {\n            // Simple [reg] base\n            const baseRegIndex = modrm.rm + (rex_b << 3);\n            const baseRegName = this.getRegisterString(baseRegIndex, 8, true);\n            effectiveAddress = this.readRegister(baseRegName, 8);\n        }\n\n        // --- Step 2: Add Displacement based on ModR/M.mod ---\n        if (modrm.mod === 0x01) {\n            displacement = this.readSignedImmediate(1); // disp8\n            effectiveAddress += displacement;\n        } else if (modrm.mod === 0x02) {\n            displacement = this.readSignedImmediate(4); // disp32\n            effectiveAddress += displacement;\n        } else if (modrm.mod === 0x00) {\n            // THIS IS THE CRITICAL FIX\n            // Check for disp32 cases that exist even when mod is 00.\n            // Case 1: [RIP + disp32] (ModR/M.r/m = 5)\n            // Case 2: [SIB + disp32] (SIB.base = 5)\n            const sibBaseIsRBP = sibPresent && ((this.memory.readUint8(Number(this.rip - 1n)) & 0x07) === 5);\n            if ((!sibPresent && modrm.rm === 5) || sibBaseIsRBP) {\n                displacement = this.readSignedImmediate(4);\n                effectiveAddress += displacement;\n            }\n        }\n\n        return { type: 'mem', address: effectiveAddress, sizeBytes: sizeBytes };\n    }\n\n    updateCPUMode() {\n        const peBit = (this.cr0 & CPU.CR0_PE) !== 0n;       \n        const pgBit = (this.cr0 & CPU.CR0_PG) !== 0n; \n        const paeBit = (this.cr4 & CPU.CR4_PAE) !== 0n; \n        const lmeBit = (this.efer & CPU.EFER_LME) !== 0n; \n\n        // --- NEW DEBUGGING LOGS ---\n        utils.log(`\\n--- DEBUG: updateCPUMode called ---`);\n        utils.log(`  Current CR0:  0x${this.cr0.toString(16).padStart(16, '0')} (PE: ${peBit}, PG: ${pgBit})`);\n        utils.log(`  Current CR4:  0x${this.cr4.toString(16).padStart(16, '0')} (PAE: ${paeBit})`);\n        utils.log(`  Current EFER: 0x${this.efer.toString(16).padStart(16, '0')} (LME: ${lmeBit})`);\n        utils.log(`  Combined Condition (LME && PAE && PG): ${lmeBit && paeBit && pgBit}`);\n        // --- END DEBUGGING LOGS ---\n    \n        if (!peBit) {\n            this.mode = 'real';\n        } else { \n            if (lmeBit && paeBit && pgBit) { \n                this.mode = 'long';\n                utils.log(\"CPU Mode: Long Mode (64-bit) enabled.\");\n            } else if (pgBit && paeBit) { \n                this.mode = 'protected_pae'; \n                utils.log(\"CPU Mode: Protected Mode (32-bit) with PAE enabled.\");\n            } else if (pgBit) {\n                this.mode = 'protected_32bit_paging'; \n                utils.log(\"CPU Mode: Protected Mode (32-bit) with Paging enabled.\");\n            } else {\n                this.mode = 'protected'; \n                utils.log(\"CPU Mode: Protected Mode (32-bit) enabled (no paging).\");\n            }\n        }\n        utils.log(`DEBUG: updateCPUMode - Mode finalized as: ${this.mode}\\n`);\n    }\n\n    readVirtualUint8(virtualAddr) {\n        const physicalAddr = this.translateVirtualToPhysical(virtualAddr, 1, 'read');\n        // Add bounds check for physical memory to catch issues *before* DataView throws\n        if (physicalAddr < 0n || physicalAddr >= BigInt(this.memory.buffer.byteLength)) {\n            console.error(`Attempt to read physical address 0x${physicalAddr.toString(16)} outside memory bounds (0x0 to 0x${BigInt(this.memory.buffer.byteLength).toString(16)}).`);\n            throw new Error(`MEMORY_ACCESS_VIOLATION: Read from physical address 0x${physicalAddr.toString(16)}`);\n        }\n        return this.memory.readUint8(Number(physicalAddr));\n    }\n\n    writeVirtualUint8(virtualAddr, value) {\n        const physicalAddr = this.translateVirtualToPhysical(virtualAddr, 1, 'write');\n        if (physicalAddr < 0n || physicalAddr >= BigInt(this.memory.buffer.byteLength)) {\n            console.error(`Attempt to write physical address 0x${physicalAddr.toString(16)} outside memory bounds (0x0 to 0x${BigInt(this.memory.buffer.byteLength).toString(16)}).`);\n            throw new Error(`MEMORY_ACCESS_VIOLATION: Write to physical address 0x${physicalAddr.toString(16)}`);\n        }\n        this.memory.writeUint8(Number(physicalAddr), value);\n    }\n\n    readVirtualUint16(virtualAddr) {\n        const physicalAddr = this.translateVirtualToPhysical(virtualAddr, 2, 'read');\n        if (physicalAddr < 0n || physicalAddr + 1n >= BigInt(this.memory.buffer.byteLength)) { // +1n for 2-byte read\n            console.error(`Attempt to read physical address 0x${physicalAddr.toString(16)} outside memory bounds.`);\n            throw new Error(`MEMORY_ACCESS_VIOLATION: Read from physical address 0x${physicalAddr.toString(16)}`);\n        }\n        return this.memory.readUint16(Number(physicalAddr));\n    }\n\n    writeVirtualUint16(virtualAddr, value) {\n        const physicalAddr = this.translateVirtualToPhysical(virtualAddr, 2, 'write');\n        if (physicalAddr < 0n || physicalAddr + 1n >= BigInt(this.memory.buffer.byteLength)) { // +1n for 2-byte write\n            console.error(`Attempt to write physical address 0x${physicalAddr.toString(16)} outside memory bounds.`);\n            throw new Error(`MEMORY_ACCESS_VIOLATION: Write to physical address 0x${physicalAddr.toString(16)}`);\n        }\n        this.memory.writeUint16(Number(physicalAddr), value);\n    }\n\n    readVirtualUint32(virtualAddr) {\n        const physicalAddr = this.translateVirtualToPhysical(virtualAddr, 4, 'read');\n        if (physicalAddr < 0n || physicalAddr + 3n >= BigInt(this.memory.buffer.byteLength)) { // +3n for 4-byte read\n            console.error(`Attempt to read physical address 0x${physicalAddr.toString(16)} outside memory bounds.`);\n            throw new Error(`MEMORY_ACCESS_VIOLATION: Read from physical address 0x${physicalAddr.toString(16)}`);\n        }\n        return this.memory.readUint32(Number(physicalAddr));\n    }\n\n    writeVirtualUint32(virtualAddr, value) {\n        const physicalAddr = this.translateVirtualToPhysical(virtualAddr, 4, 'write');\n        if (physicalAddr < 0n || physicalAddr + 3n >= BigInt(this.memory.buffer.byteLength)) { // +3n for 4-byte write\n            console.error(`Attempt to write physical address 0x${physicalAddr.toString(16)} outside memory bounds.`);\n            throw new Error(`MEMORY_ACCESS_VIOLATION: Write to physical address 0x${physicalAddr.toString(16)}`);\n        }\n        this.memory.writeUint32(Number(physicalAddr), value);\n    }\n\n    readVirtualBigUint64(virtualAddr) {\n        const physicalAddr = this.translateVirtualToPhysical(virtualAddr, 8, 'read');\n        if (physicalAddr < 0n || physicalAddr + 7n >= BigInt(this.memory.buffer.byteLength)) { // +7n for 8-byte read\n            console.error(`Attempt to read physical address 0x${physicalAddr.toString(16)} outside memory bounds.`);\n            throw new Error(`MEMORY_ACCESS_VIOLATION: Read from physical address 0x${physicalAddr.toString(16)}`);\n        }\n        return this.memory.readBigUint64(Number(physicalAddr)); \n    }\n\n    writeVirtualBigUint64(virtualAddr, value) {\n        const physicalAddr = this.translateVirtualToPhysical(virtualAddr, 8, 'write');\n        if (physicalAddr < 0n || physicalAddr + 7n >= BigInt(this.memory.buffer.byteLength)) { // +7n for 8-byte write\n            console.error(`Attempt to write physical address 0x${physicalAddr.toString(16)} outside memory bounds.`);\n            throw new Error(`MEMORY_ACCESS_VIOLATION: Write to physical address 0x${physicalAddr.toString(16)}`);\n        }\n        this.memory.writeBigUint64(Number(physicalAddr), value); \n    }\n\n    translateVirtualToPhysical(virtualAddr, sizeBytes, accessType) {\n        if (this.mode === 'real') {\n            return virtualAddr;\n        }\n\n        const pgBit = (this.cr0 & CPU.CR0_PG) !== 0n;\n        const paeBit = (this.cr4 & CPU.CR4_PAE) !== 0n;\n        const lmeBit = (this.efer & CPU.EFER_LME) !== 0n;\n\n        // This guard determines when the full 4-level paging logic is active.\n        if (this.mode !== 'long' || !pgBit || !paeBit || !lmeBit) {\n            console.warn(`Paging not fully enabled for Long Mode. Current mode: ${this.mode}. CR0.PG=${pgBit}, CR4.PAE=${paeBit}, EFER.LME=${lmeBit}. Returning virtual as physical.`);\n            return virtualAddr; // Pass through if paging is not fully active\n        }\n\n        // --- Paging Enabled for Long Mode (the real work begins here) ---\n        utils.log(`Paging: Translating virtual address 0x${virtualAddr.toString(16)} in ${this.mode} mode.`);\n\n        const pml4BasePhys = this.cr3 & ~0xFFFn;\n        utils.log(`  PML4 Base Phys: 0x${pml4BasePhys.toString(16).padStart(16, '0')}`); \n\n        const pml4Index = (virtualAddr >> 39n) & 0x1FFn; \n        let pml4eAddr = pml4BasePhys + (pml4Index * 8n); \n        utils.log(`  PML4E Addr: 0x${pml4eAddr.toString(16).padStart(16, '0')} (Index: ${pml4Index})`);\n        let pml4e = this.memory.readBigUint64(Number(pml4eAddr));\n        utils.log(`  PML4E Value: 0x${pml4e.toString(16).padStart(16, '0')}`);\n\n        if ((pml4e & CPU.PTE_PRESENT) === 0n) {\n            console.error(`Page Fault (#PF): PML4E not present for VA 0x${virtualAddr.toString(16)}`);\n            throw new PageFaultException(`PML4E not present`, 0n);\n        }        \n\n        let pdptBasePhys = pml4e & ~0xFFFn;\n        utils.log(`  PDPT Base Phys: 0x${pdptBasePhys.toString(16).padStart(16, '0')}`); \n        const pdptIndex = (virtualAddr >> 30n) & 0x1FFn; \n        let pdpteAddr = pdptBasePhys + (pdptIndex * 8n); \n        utils.log(`  PDPTE Addr: 0x${pdpteAddr.toString(16).padStart(16, '0')} (Index: ${pdptIndex})`);\n        let pdpte = this.memory.readBigUint64(Number(pdpteAddr));\n        utils.log(`  PDPTE Value: 0x${pdpte.toString(16).padStart(16, '0')}`);\n\n        if ((pdpte & CPU.PTE_PRESENT) === 0n) {\n            console.error(`Page Fault (#PF): PDPTE not present for VA 0x${virtualAddr.toString(16)}`);\n            throw new PageFaultException(`PDPTE not present`, 0n);\n        }\n\n        if ((pdpte & CPU.PTE_PAGE_SIZE) !== 0n) { // 1GB page\n            const pageBaseAddr = pdpte & 0xFFFFFFFC0000000n; \n            const offset = virtualAddr & 0x3FFFFFFFfn; \n            const physical = pageBaseAddr | offset;\n            utils.log(`  Translated 1GB page: VA 0x${virtualAddr.toString(16)} -> PA 0x${physical.toString(16)}`);\n            return physical;\n        }\n\n        let pdBasePhys = pdpte & ~0xFFFn;\n        utils.log(`  PD Base Phys: 0x${pdBasePhys.toString(16).padStart(16, '0')}`); \n        const pdIndex = (virtualAddr >> 21n) & 0x1FFn; \n        let pdeAddr = pdBasePhys + (pdIndex * 8n); \n        utils.log(`  PDE Addr: 0x${pdeAddr.toString(16).padStart(16, '0')} (Index: ${pdIndex})`);\n        let pde = this.memory.readBigUint64(Number(pdeAddr));\n        utils.log(`  PDE Value: 0x${pde.toString(16).padStart(16, '0')}`);\n\n        if ((pde & CPU.PTE_PRESENT) === 0n) {\n            console.error(`Page Fault (#PF): PDE not present for VA 0x${virtualAddr.toString(16)}`);\n            throw new PageFaultException(`PDE not present`, 0n);\n        }\n\n        if ((pde & CPU.PTE_PAGE_SIZE) !== 0n) { // 2MB page\n            const pageBaseAddr = pde & 0xFFFFFFFE00000n; \n            const offset = virtualAddr & 0x1FFFFFn; \n            const physical = pageBaseAddr | offset;\n            utils.log(`  Translated 2MB page: VA 0x${virtualAddr.toString(16)} -> PA 0x${physical.toString(16)}`);\n            return physical;\n        }\n\n        let ptBasePhys = pde & ~0xFFFn;\n        utils.log(`  PT Base Phys: 0x${ptBasePhys.toString(16).padStart(16, '0')}`); \n        const ptIndex = (virtualAddr >> 12n) & 0x1FFn; \n        let pteAddr = ptBasePhys + (ptIndex * 8n); \n        utils.log(`  PTE Addr: 0x${pteAddr.toString(16).padStart(16, '0')} (Index: ${ptIndex})`);\n        let pte = this.memory.readBigUint64(Number(pteAddr));\n        utils.log(`  PTE Value: 0x${pte.toString(16).padStart(16, '0')}`);\n\n        if ((pte & CPU.PTE_PRESENT) === 0n) {\n            console.error(`Page Fault (#PF): PTE not present for VA 0x${virtualAddr.toString(16)}`);\n            throw new PageFaultException(`PTE not present`, 0n);\n        }\n\n        const pageBaseAddr = pte & ~0xFFFn; \n        const offset = virtualAddr & 0xFFFn; \n        const physical = pageBaseAddr | offset;\n        utils.log(`  Final Page Base Addr: 0x${pageBaseAddr.toString(16).padStart(16, '0')}`);\n        utils.log(`  Page Offset: 0x${offset.toString(16).padStart(3, '0')}`);\n        utils.log(`  Calculated Physical: 0x${physical.toString(16).padStart(16, '0')}`);\n\n        return physical;\n    }\n\n    triggerInterrupt(interruptNumber, errorCode = null) {\n        utils.log(`--- INTERRUPT TRIGGERED: #${interruptNumber} ---`);\n\n        const descriptorAddr = this.idtr.base + BigInt(interruptNumber * 16);\n\n        const lowSlice = this.readVirtualBigUint64(descriptorAddr);\n        const highSlice = this.readVirtualBigUint64(descriptorAddr + 8n);\n        utils.log(`DEBUG: Descriptor at 0x${descriptorAddr.toString(16)} is: LOW=0x${lowSlice.toString(16)} HIGH=0x${highSlice.toString(16)}`);\n\n        // === FINAL, CORRECTED PARSING LOGIC v3 ===\n        // This logic correctly decodes the structure created by the assembly code.\n        const offset_15_0  = lowSlice & 0xFFFFn;\n        const offset_31_16 = (lowSlice >> 48n) & 0xFFFFn;\n        const offset_63_32 = highSlice & 0xFFFFFFFFn;\n\n        const handlerAddr = (offset_63_32 << 32n) | (offset_31_16 << 16n) | offset_15_0;\n        // ===========================================\n\n        const segmentSelector = (lowSlice >> 16n) & 0xFFFFn;\n        const type_attrs = (lowSlice >> 40n) & 0xFFn;\n        const present = (type_attrs & 0x80n) !== 0n;\n\n        if (!present) {\n            throw new Error(`Interrupt Handler #${interruptNumber} not present! Double Fault.`);\n        }\n\n        // Push state onto the stack\n        this.rsp -= 8n;\n        this.writeVirtualBigUint64(this.rsp, this.assembleRFlags());\n        this.rsp -= 8n;\n        this.writeVirtualBigUint64(this.rsp, segmentSelector);\n        this.rsp -= 8n;\n        this.writeVirtualBigUint64(this.rsp, this.rip);\n        if (errorCode !== null) {\n            this.rsp -= 8n;\n            this.writeVirtualBigUint64(this.rsp, errorCode);\n        }\n        \n        // Jump to the handler\n        this.rip = handlerAddr;\n        \n        utils.log(`  Jumping to handler at 0x${handlerAddr.toString(16)}`);\n    }\n\n    assembleRFlags() {\n        let flags = 0n;\n        if (this.flags.cf) flags |= (1n << CPU.FLAG_CF_BIT);\n        if (this.flags.zf) flags |= (1n << CPU.FLAG_ZF_BIT);\n        if (this.flags.sf) flags |= (1n << CPU.FLAG_SF_BIT);\n        if (this.flags.of) flags |= (1n << CPU.FLAG_OF_BIT);\n        // Always set bit 1 to 1, as per specification\n        flags |= (1n << 1n);\n        return flags;\n    }\n\n    disassembleRFlags(rflagsValue) {\n        this.flags.cf = ((rflagsValue >> CPU.FLAG_CF_BIT) & 1n) === 1n ? 1 : 0;\n        this.flags.zf = ((rflagsValue >> CPU.FLAG_ZF_BIT) & 1n) === 1n ? 1 : 0;\n        this.flags.sf = ((rflagsValue >> CPU.FLAG_SF_BIT) & 1n) === 1n ? 1 : 0;\n        this.flags.of = ((rflagsValue >> CPU.FLAG_OF_BIT) & 1n) === 1n ? 1 : 0;\n    }\n}"],"names":["_console","console","mode","log","args","Memory","constructor","size","this","buffer","ArrayBuffer","view","DataView","Uint8Array","fill","readUint8","addr","getUint8","readUint16","getUint16","readUint32","getUint32","readBigUint64","getBigUint64","writeUint8","value","setUint8","writeUint16","setUint16","writeUint32","setUint32","writeBigUint64","setBigUint64","load","data","sourceUint8Array","mainBufferView","Number","byteLength","Error","toString","set","IOManager","devices","Map","registerDevice","ports","device","portArray","Array","isArray","port","name","portIn","get","portOut","PageFaultException","message","errorCode","super","CPU","static","setupIdentityPaging","memory","virtualStart","physicalStart","sizeBytes","pageTableBasePhysAddr","PAGE_SIZE","numPages","currentTableAddr","pml4TablePhys","pdptTablePhys","pdTablePhys","ptTablePhys","utils.log","i","writeAndVerifyPTE","description","readBack","error","PTE_PRESENT","PTE_READ_WRITE","PTE_USER_SUPER","currentVirtualPage","pte_value","pteWriteAddr","io","idtr","base","limit","gdtr","rax","rbx","rcx","rdx","rsp","rbp","rsi","rdi","r8","r9","r10","r11","r12","r13","r14","r15","rflags","rip","flags","cf","zf","sf","of","cr0","cr3","cr4","efer","registers","eax","ecx","edx","ebx","esp","ebp","esi","edi","r8d","r9d","r10d","r11d","r12d","r13d","r14d","r15d","ax","cx","dx","bx","sp","bp","si","di","r8w","r9w","r10w","r11w","r12w","r13w","r14w","r15w","al","cl","dl","bl","ah","ch","dh","bh","spl","bpl","sil","dil","r8b","r9b","r10b","r11b","r12b","r13b","r14b","r15b","eflags","readRegister","regName","assembleRFlags","fullReg","val","includes","writeRegister","undefined","currentVal","valToWrite","BigInt","updateArithmeticFlags","result","operand1","operand2","operation","bitWidth","bitMask","signBitMask","maskedResult","maskedOperand1","maskedOperand2","s1","s2","sR","step","rexPrefix","defaultOperandSize","operandSizeOverride","opcode","rex_w","rex_r","rex_x","rex_b","currentRIPBeforeFetch","byte","readInstructionByte","twoByteOpcode","padStart","modrm","readModRMByte","crIdx","reg","sourceRegFullIndex","rm","sourceRegName","getRegisterString","sourceValue","toUpperCase","updateCPUMode","cr2","warn","msrAddr","valueHigh","EFER_LME","displacement","readSignedImmediate","memOperand","resolveModRMOperand","readVirtualUint16","address","readVirtualBigUint64","destRegIdx","immValue","destRegName","getImmediateValue","currentRip","numBytes","CR0_PE","readVirtualUint8","readVirtualUint32","dBit","regOpFullIndex","regOpName","rmOperand","destValue","destOperand","type","writeVirtualUint8","writeVirtualUint16","writeVirtualUint32","writeVirtualBigUint64","imm32","eaxValue","destOperandString","immediateSizeBytes","immediateValue","mnemonic","regValue","immediateSize","targetSizeBytes","asIntN","regIdx","retAddr","tgtAddr","imm16","mod","destRegFullIndex","effectiveAddress","val1","val2","imm8","shiftCount","new_rflags","disassembleRFlags","e","triggerInterrupt","raw","regIndex","hasRexPrefix","regNames64","regNames32","regNames16","regNames8Low","regNames8HighNoRex","regNames8NewRex","regNames8Extended","rawValue","getRawValue","readSIBByte","sib","indexBits","baseBits","scale","idxRegName","baseRegName","baseValue","indexValue","hasRexPrefixForNaming","rmIndex","sibPresent","indexRegName","baseRegIndex","sibBaseIsRBP","peBit","pgBit","CR0_PG","paeBit","CR4_PAE","lmeBit","virtualAddr","physicalAddr","translateVirtualToPhysical","accessType","pml4BasePhys","pml4Index","pml4eAddr","pml4e","pdptBasePhys","pdptIndex","pdpteAddr","pdpte","PTE_PAGE_SIZE","physical","pdBasePhys","pdIndex","pdeAddr","pde","ptBasePhys","ptIndex","pteAddr","pte","pageBaseAddr","offset","interruptNumber","descriptorAddr","lowSlice","highSlice","handlerAddr","segmentSelector","FLAG_CF_BIT","FLAG_ZF_BIT","FLAG_SF_BIT","FLAG_OF_BIT","rflagsValue","m"],"mappings":"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"}