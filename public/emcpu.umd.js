!function(t,e){"object"==typeof exports&&"undefined"!=typeof module?e(exports):"function"==typeof define&&define.amd?define(["exports"],e):e((t="undefined"!=typeof globalThis?globalThis:t||self).EmCPU={})}(this,function(t){"use strict";const e=console;let r="prod";function i(...t){"dev"===r&&e.log(...t)}class s{constructor(t){this.buffer=new ArrayBuffer(t),this.view=new DataView(this.buffer),new Uint8Array(this.buffer).fill(0)}readUint8(t){return this.view.getUint8(t)}readUint16(t){return this.view.getUint16(t,!0)}readUint32(t){return this.view.getUint32(t,!0)}readBigUint64(t){return this.view.getBigUint64(t,!0)}writeUint8(t,e){this.view.setUint8(t,Number(e))}writeUint16(t,e){this.view.setUint16(t,Number(e),!0)}writeUint32(t,e){this.view.setUint32(t,Number(e),!0)}writeBigUint64(t,e){this.view.setBigUint64(t,e,!0)}load(t,e){const r=new Uint8Array(e),s=new Uint8Array(this.buffer);if(Number(t)<0||Number(t)+r.byteLength>s.byteLength)throw new Error(`Memory.load: Attempted to load 0x${r.byteLength.toString(16)} bytes at 0x${t.toString(16)} which is outside the allocated memory bounds (0x0 to 0x${s.byteLength.toString(16)}).`);s.set(r,Number(t)),i(`Memory.load: Loaded 0x${r.byteLength.toString(16)} bytes to 0x${t.toString(16)}`)}}class n{constructor(){this.devices=new Map}registerDevice(t,e){const r=Array.isArray(t)?t:[t];for(const t of r)this.devices.set(t,e),i(`Registered device ${e.name} at port ${t}`)}portIn(t,e){const r=this.devices.get(t);return r&&r.portIn?r.portIn(t,e):0}portOut(t,e,r){const i=this.devices.get(t);i&&i.portOut&&i.portOut(t,e,r)}}class a extends Error{constructor(t,e){super(t),this.name="PageFaultException",this.errorCode=e}}class d{static CR0_PE=1n;static CR0_PG=1n<<31n;static CR4_PAE=32n;static FLAG_CF_BIT=0n;static FLAG_ZF_BIT=6n;static FLAG_SF_BIT=7n;static FLAG_IF_BIT=9n;static FLAG_OF_BIT=11n;static EFER_LME=256n;static EFER_NXE=2048n;static PTE_PRESENT=1n;static PTE_READ_WRITE=2n;static PTE_USER_SUPER=4n;static PTE_WRITE_THROUGH=8n;static PTE_CACHE_DISABLE=16n;static PTE_ACCESSED=32n;static PTE_DIRTY=64n;static PTE_PAGE_SIZE=128n;static PTE_GLOBAL=256n;static setupIdentityPaging(t,e,r,s,n){const a=4096n;if(s%a!==0n)throw new Error("Mapped size must be a multiple of 4KB.");const o=s/a;let g=n;const h=g;g+=a;const l=g;g+=a;const u=g;g+=a;const f=g;g+=a,i(`Setting up identity map from VA 0x${e.toString(16)} to PA 0x${r.toString(16)}, size 0x${s.toString(16)}`),i(`  PML4 Table at PA 0x${h.toString(16)}`),i(`  PDPT Table at PA 0x${l.toString(16)}`),i(`  PD Table at PA 0x${u.toString(16)}`),i(`  PT Table at PA 0x${f.toString(16)}`);for(let e=0n;e<512n;e++)t.writeBigUint64(Number(h+8n*e),0n),t.writeBigUint64(Number(l+8n*e),0n),t.writeBigUint64(Number(u+8n*e),0n),t.writeBigUint64(Number(f+8n*e),0n);const p=(e,r,s)=>{t.writeBigUint64(Number(e),r);const n=t.readBigUint64(Number(e));if(n!==r)throw console.error(`ERROR: ${s} write mismatch at 0x${e.toString(16)}! Written: 0x${r.toString(16)}, Readback: 0x${n.toString(16)}`),new Error("Page table write verification failed.");i(`  VERIFIED: ${s} at 0x${e.toString(16)} is 0x${n.toString(16)}`)};p(h,l|d.PTE_PRESENT|d.PTE_READ_WRITE|d.PTE_USER_SUPER,"PML4E[0] -> PDPT[0]"),p(l,u|d.PTE_PRESENT|d.PTE_READ_WRITE|d.PTE_USER_SUPER,"PDPTE[0] -> PD[0]"),p(u,f|d.PTE_PRESENT|d.PTE_READ_WRITE|d.PTE_USER_SUPER,"PDE[0] -> PT[0]");for(let i=0n;i<o;i++){const s=e+i*a;let n=r+i*a|d.PTE_PRESENT|d.PTE_READ_WRITE|d.PTE_USER_SUPER;const o=f+8n*(s>>12n&0x1FFn);i%100n==0n||0x7C00n===s||0x8000n===s?p(o,n,`PTE for VA 0x${s.toString(16)}`):t.writeBigUint64(Number(o),n)}return h}constructor(t=new s(1048576),e=new n){this.memory=t,this.io=e,this.idtr={base:0n,limit:0},this.gdtr={base:0n,limit:0},this.interruptQueue=[],this.rax=0n,this.rbx=0n,this.rcx=0n,this.rdx=0n,this.rsp=0n,this.rbp=0n,this.rsi=0n,this.rdi=0n,this.r8=0n,this.r9=0n,this.r10=0n,this.r11=0n,this.r12=0n,this.r13=0n,this.r14=0n,this.r15=0n,this.cs=0n,this.ds=0n,this.ss=0n,this.es=0n,this.fs=0n,this.gs=0n,this.rflags=0n,this.rip=0n,this.halted=!1,this.flags={cf:0,zf:0,sf:0,of:0,if:1},this.mode="real",this.cr0=0n,this.cr3=0n,this.cr4=0n,this.efer=0n,this.registers={rax:"rax",rcx:"rcx",rdx:"rdx",rbx:"rbx",rsp:"rsp",rbp:"rbp",rsi:"rsi",rdi:"rdi",r8:"r8",r9:"r9",r10:"r10",r11:"r11",r12:"r12",r13:"r13",r14:"r14",r15:"r15",eax:"rax",ecx:"rcx",edx:"rdx",ebx:"rbx",esp:"rsp",ebp:"rbp",esi:"rsi",edi:"rdi",r8d:"r8",r9d:"r9",r10d:"r10",r11d:"r11",r12d:"r12",r13d:"r13",r14d:"r14",r15d:"r15",ax:"rax",cx:"rcx",dx:"rdx",bx:"rbx",sp:"rsp",bp:"rbp",si:"rsi",di:"rdi",r8w:"r8",r9w:"r9",r10w:"r10",r11w:"r11",r12w:"r12",r13w:"r13",r14w:"r14",r15w:"r15",al:"rax",cl:"rcx",dl:"rdx",bl:"rbx",ah:"rax",ch:"rcx",dh:"rdx",bh:"rbx",spl:"rsp",bpl:"rbp",sil:"rsi",dil:"rdi",r8b:"r8",r9b:"r9",r10b:"r10",r11b:"r11",r12b:"r12",r13b:"r13",r14b:"r14",r15b:"r15",rflags:"rflags",eflags:"rflags",cs:"cs",ds:"ds",es:"es",ss:"ss",fs:"fs",gs:"gs"}}readRegister(t,e){if("rflags"===t||"eflags"===t)return this.assembleRFlags();const r=this.registers[t];if(!r)throw new Error(`Attempted to read unknown register name: ${t}`);let i=this[r];if(1===e)return["ah","ch","dh","bh"].includes(t)?i>>8n&0xFFn:0xFFn&i;if(2===e)return 0xFFFFn&i;if(4===e)return 0xFFFFFFFFn&i;if(8===e)return i;throw new Error(`Invalid register size: ${e}`)}writeRegister(t,e,r){const i=this.registers[t];if(void 0===i)throw new Error(`Attempted to write to unknown register name: ${t}`);let s=this[i],n=BigInt(e);if(1===r)["ah","ch","dh","bh"].includes(t)?this[i]=-65281n&s|(0xFFn&n)<<8n:this[i]=-256n&s|0xFFn&n;else if(2===r)this[i]=-65536n&s|0xFFFFn&n;else if(4===r)this[i]=0xFFFFFFFFn&n;else{if(8!==r)throw new Error(`Invalid register size for writing: ${r} for register ${t}`);this[i]=n}}updateArithmeticFlags(t,e,r,i,s){const n=BigInt(8*i),a=(1n<<n)-1n,d=1n<<n-1n,o=t&a,g=e&a,h=r&a;this.flags.zf=0n===o?1:0,this.flags.sf=0n!==(o&d)?1:0,this.flags.cf="add"===s?t>a?1:0:"sub"===s&&g<h?1:0;const l=0n!==(g&d),u=0n!==(h&d),f=0n!==(o&d);this.flags.of=0,"add"===s?l===u&&l!==f&&(this.flags.of=1):"sub"===s?l!==u&&l!==f&&(this.flags.of=1):this.flags.of=0}step(){let t,e=0;this.operandSizeOverride=!1;let r,s=0,n=0,o=0,g=0,h=this.rip;if(this.flags.if&&this.interruptQueue.length>0){this.halted=!1;const t=this.interruptQueue.shift();this.triggerInterrupt(t)}if(this.halted)return!0;try{let a=this.readInstructionByte();for(;;)if(102===a)this.operandSizeOverride=!0,a=this.readInstructionByte();else{if(64!=(240&a)){r=a;break}e=a,s=(8&e)>>>3,n=(4&e)>>>2,o=(2&e)>>>1,g=1&e,a=this.readInstructionByte()}t="long"===this.mode?s?8:this.operandSizeOverride?2:4:this.operandSizeOverride?4:2;let l=!1;if(15===r&&(l=!0,r=this.readInstructionByte()),i(`RIP: 0x${h.toString(16).padStart(4,"0")}, OPCODE: 0x${l?"0F":""}${r.toString(16).padStart(2,"0")}${e?` (REX: 0x${e.toString(16)})`:""}${this.operandSizeOverride?" (0x66)":""}`),l){if(32===r){const r=this.readModRMByte(),n=r.reg,a=r.rm+(g<<3);let d=t;"long"===this.mode&&(d=s?8:4);const o=this.getRegisterString(a,d,0!==e);let h;switch(n){case 0:h=this.cr0;break;case 2:h=this.cr2;break;case 3:h=this.cr3;break;case 4:h=this.cr4;break;default:throw new Error(`Attempted to read from unknown/unsupported CR${n}`)}return this.writeRegister(o,h,d),i(`Decoded: MOV ${o.toUpperCase()}, CR${n}`),!0}if(34===r){const t=this.readModRMByte(),r=t.reg,s=t.rm+(g<<3),n=this.getRegisterString(s,8,0!==e),a=this.readRegister(n,8);switch(r){case 0:this.cr0=a,i(`Decoded: MOV CR0, ${n.toUpperCase()} (0x${a.toString(16)}n)`),this.updateCPUMode();break;case 2:this.cr2=a,i(`Decoded: MOV CR2, ${n.toUpperCase()} (0x${a.toString(16)}n)`);break;case 3:this.cr3=a,i(`Decoded: MOV CR3, ${n.toUpperCase()} (0x${a.toString(16)}n)`);break;case 4:this.cr4=a,i(`Decoded: MOV CR4, ${n.toUpperCase()} (0x${a.toString(16)}n)`),this.updateCPUMode();break;default:console.warn(`MOV CR${r}, ${n.toUpperCase()} not fully implemented/valid.`)}return!0}if(48===r){const t=this.readRegister("rcx",8),e=this.readRegister("rdx",8)<<32n,r=e|0xFFFFFFFFn&this.readRegister("rax",8);return 0xC0000080n===t?(this.efer=r,0n!==(this.efer&d.EFER_LME)&&i("Long Mode Enable (LME) bit set in EFER!"),this.updateCPUMode()):console.warn(`WRMSR to unknown MSR 0x${t.toString(16)}`),!0}if(132===r){const t=this.readSignedImmediate(4);return i(`Decoded: JE/JZ rel32 0x${t.toString(16)} (RIP adjusted)`),1===this.flags.zf?(this.rip+=t,i(`  Condition Met (ZF=1). Jumping to 0x${this.rip.toString(16)}`)):i("  Condition Not Met (ZF=0). Not jumping."),!0}if(133===r){const t=this.readSignedImmediate(4);return i(`Decoded: JNE/JNZ rel32 0x${t.toString(16)} (RIP adjusted)`),0===this.flags.zf?(this.rip+=t,i(`  Condition Met (ZF=0). Jumping to 0x${this.rip.toString(16)}`)):i("  Condition Not Met (ZF=1). Not jumping."),!0}if(1===r){const t=this.readModRMByte();if(2===t.reg){const r=this.resolveModRMOperand(t,8,o,g,0!==e),s=this.readVirtualUint16(r.address),n=this.readVirtualBigUint64(r.address+2n);return this.gdtr.limit=s,this.gdtr.base=n,i(`Decoded: LGDT [0x${r.address.toString(16)}] (Base: 0x${n.toString(16)}, Limit: 0x${s.toString(16)})`),!0}if(3===t.reg){const r=this.resolveModRMOperand(t,8,o,g,0!==e),s=this.readVirtualUint16(r.address),n=this.readVirtualBigUint64(r.address+2n);return this.idtr.limit=s,this.idtr.base=n,i(`Decoded: LIDT [0x${r.address.toString(16)}] (Base: 0x${n.toString(16)}, Limit: 0x${s.toString(16)})`),!0}}return i(`Unknown 2-byte opcode: 0x0F ${r.toString(16)} at 0x${h.toString(16)}`),!1}if(0===r){const t=this.readModRMByte(),e=this.getRegisterString(t.reg,1,!1),r=0xFFn&this.readRegister(e,1);let s;if(0!==t.mod||0!==t.rm)throw new Error(`ADD: Mod/RM mode not yet implemented (mod=${t.mod}, rm=${t.rm})`);{const t=this.readRegister("bx",2),e=this.readRegister("si",2);s=Number(t+e&0xFFFFn)}const n=(0xFFn&BigInt(this.memory.readUint8(s)))+r&0xFFn;return this.memory.writeUint8(s,Number(n)),i(`Decoded: ADD [BX+SI], ${e} (0x${r.toString(16)}) â†’ Result: 0x${n.toString(16)}`),!0}if(144===r)return i("Decoded: NOP"),!0;if(244===r)return this.halted=!0,i("HLT instruction encountered. Emulation halted."),!0;if(116===r){const t=this.readSignedImmediate(1);return i(`Decoded: JE/JZ rel8 0x${t.toString(16)} (RIP adjusted)`),1===this.flags.zf?(this.rip+=t,i(`  Condition Met (ZF=1). Jumping to 0x${this.rip.toString(16)}`)):i("  Condition Not Met (ZF=0). Not jumping."),!0}if(117===r){const t=this.readSignedImmediate(1);return i(`Decoded: JNE/JNZ rel8 0x${t.toString(16)} (RIP adjusted)`),0===this.flags.zf?(this.rip+=t,i(`  Condition Met (ZF=0). Jumping to 0x${this.rip.toString(16)}`)):i("  Condition Not Met (ZF=1). Not jumping."),!0}if(r>=176&&r<=191){const t=(7&r)+(g<<3);let n;n=r>=176&&r<=183?1:"long"===this.mode?s?8:this.operandSizeOverride?2:4:this.operandSizeOverride?4:2;const a=this.getRegisterString(t,n,0!==e),d=this.readSignedImmediate(8===n?8:n);return this.writeRegister(a,d,n),i(`Decoded: MOV ${a.toUpperCase()}, 0x${d.toString(16)}`),!0}if(1===r||3===r){const s=this.readModRMByte(),a=r>>>1&1;let d=0===(1&r)?1:t;const h=s.reg+(n<<3),l=this.getRegisterString(h,d,0!==e),u=this.resolveModRMOperand(s,d,o,g,0!==e);let f,p,c;if("reg"===u.type)0===a?(f=this.readRegister(l,d),p=this.readRegister(u.name,d),c=u):(f=this.readRegister(u.name,d),p=this.readRegister(l,d),c={type:"reg",name:l});else if(0===a){if(f=this.readRegister(l,d),1===d)p=BigInt(this.readVirtualUint8(u.address));else if(2===d)p=BigInt(this.readVirtualUint16(u.address));else if(4===d)p=BigInt(this.readVirtualUint32(u.address));else{if(8!==d)throw new Error("Unsupported memory read size for ADD.");p=this.readVirtualBigUint64(u.address)}c=u}else{if(1===d)f=BigInt(this.readVirtualUint8(u.address));else if(2===d)f=BigInt(this.readVirtualUint16(u.address));else if(4===d)f=BigInt(this.readVirtualUint32(u.address));else{if(8!==d)throw new Error("Unsupported memory read size for ADD.");f=this.readVirtualBigUint64(u.address)}p=this.readRegister(l,d),c={type:"reg",name:l}}const m=p+f;if(this.updateArithmeticFlags(m,p,f,d,"add"),"reg"===c.type)this.writeRegister(c.name,m,d);else if(1===d)this.writeVirtualUint8(c.address,Number(m));else if(2===d)this.writeVirtualUint16(c.address,Number(m));else if(4===d)this.writeVirtualUint32(c.address,Number(m));else{if(8!==d)throw new Error("Unsupported memory write size for ADD.");this.writeVirtualBigUint64(c.address,m)}return i(`Decoded: ADD ${"reg"===c.type?c.name.toUpperCase():`[0x${c.address.toString(16)}]`}, ${f.toString(16)}${8===d?"n":""} -> Result: 0x${m.toString(16)}n`),!0}if(5===r){const t=this.readSignedImmediate(4),e=this.readRegister("eax",4),r=e+t;return this.updateArithmeticFlags(r,e,t,4,"add"),this.writeRegister("eax",r,4),i(`Decoded: ADD EAX, 0x${t.toString(16)} (Result: 0x${r.toString(16)})`),!0}if(r>=8&&r<=11){const s=this.readModRMByte(),a=r>>>1&1;let d=0===(1&r)?1:t;const h=s.reg+(n<<3),l=this.getRegisterString(h,d,0!==e),u=this.resolveModRMOperand(s,d,o,g,0!==e);let f,p,c;if("reg"===u.type)0===a?(f=this.readRegister(l,d),p=this.readRegister(u.name,d),c=u):(f=this.readRegister(u.name,d),p=this.readRegister(l,d),c={type:"reg",name:l});else if(0===a){if(f=this.readRegister(l,d),1===d)p=BigInt(this.readVirtualUint8(u.address));else if(2===d)p=BigInt(this.readVirtualUint16(u.address));else if(4===d)p=BigInt(this.readVirtualUint32(u.address));else{if(8!==d)throw new Error("Unsupported memory read size for OR.");p=this.readVirtualBigUint64(u.address)}c=u}else{if(1===d)f=BigInt(this.readVirtualUint8(u.address));else if(2===d)f=BigInt(this.readVirtualUint16(u.address));else if(4===d)f=BigInt(this.readVirtualUint32(u.address));else{if(8!==d)throw new Error("Unsupported memory read size for OR.");f=this.readVirtualBigUint64(u.address)}p=this.readRegister(l,d),c={type:"reg",name:l}}const m=p|f;this.flags.cf=0,this.flags.of=0,this.flags.zf=0n===m?1:0;const S=1n<<BigInt(8*d)-1n;if(this.flags.sf=0n!==(m&S)?1:0,"reg"===c.type)this.writeRegister(c.name,m,d);else if(1===d)this.writeVirtualUint8(c.address,Number(m));else if(2===d)this.writeVirtualUint16(c.address,Number(m));else if(4===d)this.writeVirtualUint32(c.address,Number(m));else{if(8!==d)throw new Error("Unsupported memory write size for OR.");this.writeVirtualBigUint64(c.address,m)}const R="reg"===c.type?c.name.toUpperCase():`[0x${c.address.toString(16)}]`;return i(`Decoded: OR ${R}, ${0===a?l.toUpperCase():"reg"===u.type?u.name.toUpperCase():`[0x${u.address.toString(16)}]`} (0x${p.toString(16)}n | 0x${f.toString(16)}n) -> Result: 0x${m.toString(16)}n`),!0}if(12===r||13===r){let s=0===(1&r)?1:t;const n=this.getRegisterString(0,s,0!==e),a=this.readRegister(n,s),d=8===s?4:s,o=this.readSignedImmediate(d),g=a|o;this.flags.of=0,this.flags.cf=0;const h=(1n<<BigInt(8*s))-1n;this.flags.zf=0n===(g&h)?1:0;const l=1n<<BigInt(8*s)-1n;return this.flags.sf=0n!==(g&l)?1:0,this.writeRegister(n,g,s),i(`Decoded: OR ${n.toUpperCase()}, 0x${o.toString(16)}`),!0}if(r>=32&&r<=35){const s=this.readModRMByte(),a=r>>>1&1;let d=0===(1&r)?1:t;const h=s.reg+(n<<3),l=this.getRegisterString(h,d,0!==e),u=this.resolveModRMOperand(s,d,o,g,0!==e);let f,p,c;if(0===a)if(f=this.readRegister(l,d),"reg"===u.type)p=this.readRegister(u.name,d),c=u;else{if(1===d)p=BigInt(this.readVirtualUint8(u.address));else if(2===d)p=BigInt(this.readVirtualUint16(u.address));else if(4===d)p=BigInt(this.readVirtualUint32(u.address));else{if(8!==d)throw new Error("Unsupported memory read size for AND (dBit=0).");p=this.readVirtualBigUint64(u.address)}c=u}else if(p=this.readRegister(l,d),c={type:"reg",name:l},"reg"===u.type)f=this.readRegister(u.name,d);else if(1===d)f=BigInt(this.readVirtualUint8(u.address));else if(2===d)f=BigInt(this.readVirtualUint16(u.address));else if(4===d)f=BigInt(this.readVirtualUint32(u.address));else{if(8!==d)throw new Error("Unsupported memory read size for AND (dBit=1).");f=this.readVirtualBigUint64(u.address)}const m=p&f;this.flags.cf=0,this.flags.of=0,this.flags.zf=0n===m?1:0;const S=1n<<BigInt(8*d)-1n;if(this.flags.sf=0n!==(m&S)?1:0,"reg"===c.type)this.writeRegister(c.name,m,d);else if(1===d)this.writeVirtualUint8(c.address,Number(m));else if(2===d)this.writeVirtualUint16(c.address,Number(m));else if(4===d)this.writeVirtualUint32(c.address,Number(m));else{if(8!==d)throw new Error("Unsupported memory write size for AND.");this.writeVirtualBigUint64(c.address,m)}const R="reg"===c.type?c.name.toUpperCase():`[0x${c.address.toString(16)}]`;return i(`Decoded: AND ${R}, ${0===a?l.toUpperCase():"reg"===u.type?u.name.toUpperCase():`[0x${u.address.toString(16)}]`} (0x${p.toString(16)}n & 0x${f.toString(16)}n) -> Result: 0x${m.toString(16)}n`),!0}if(49===r||51===r){const s=this.readModRMByte(),a=r>>>1&1;let d=0===(1&r)?1:t;const h=s.reg+(n<<3),l=this.getRegisterString(h,d,0!==e),u=this.resolveModRMOperand(s,d,o,g,0!==e);let f,p,c;if("reg"===u.type)0===a?(f=this.readRegister(l,d),p=this.readRegister(u.name,d),c=u):(f=this.readRegister(u.name,d),p=this.readRegister(l,d),c={type:"reg",name:l});else if(0===a){if(f=this.readRegister(l,d),1===d)p=BigInt(this.readVirtualUint8(u.address));else if(2===d)p=BigInt(this.readVirtualUint16(u.address));else if(4===d)p=BigInt(this.readVirtualUint32(u.address));else{if(8!==d)throw new Error("Unsupported memory read size for XOR.");p=this.readVirtualBigUint64(u.address)}c=u}else{if(1===d)f=BigInt(this.readVirtualUint8(u.address));else if(2===d)f=BigInt(this.readVirtualUint16(u.address));else if(4===d)f=BigInt(this.readVirtualUint32(u.address));else{if(8!==d)throw new Error("Unsupported memory read size for XOR.");f=this.readVirtualBigUint64(u.address)}p=this.readRegister(l,d),c={type:"reg",name:l}}const m=p^f;if(this.flags.cf=0,this.flags.of=0,this.flags.zf=0n===m?1:0,this.flags.sf=1n==(m>>BigInt(8*d)-1n&1n)?1:0,"reg"===c.type)this.writeRegister(c.name,m,d);else if(1===d)this.writeVirtualUint8(c.address,Number(m));else if(2===d)this.writeVirtualUint16(c.address,Number(m));else if(4===d)this.writeVirtualUint32(c.address,Number(m));else{if(8!==d)throw new Error("Unsupported memory write size for XOR.");this.writeVirtualBigUint64(c.address,m)}return i(`Decoded: XOR ${"reg"===c.type?c.name.toUpperCase():`[0x${c.address.toString(16)}]`}, ${f.toString(16)}${8===d?"n":""} -> Result: 0x${m.toString(16)}n`),!0}if(41===r||43===r){const s=this.readModRMByte(),a=r>>>1&1;let d=0===(1&r)?1:t;const h=s.reg+(n<<3),l=this.getRegisterString(h,d,0!==e),u=this.resolveModRMOperand(s,d,o,g,0!==e);let f,p,c;if("reg"===u.type)0===a?(f=this.readRegister(l,d),p=this.readRegister(u.name,d),c=u):(f=this.readRegister(u.name,d),p=this.readRegister(l,d),c={type:"reg",name:l});else if(0===a){if(f=this.readRegister(l,d),1===d)p=BigInt(this.readVirtualUint8(u.address));else if(2===d)p=BigInt(this.readVirtualUint16(u.address));else if(4===d)p=BigInt(this.readVirtualUint32(u.address));else{if(8!==d)throw new Error("Unsupported memory read size for SUB.");p=this.readVirtualBigUint64(u.address)}c=u}else{if(1===d)f=BigInt(this.readVirtualUint8(u.address));else if(2===d)f=BigInt(this.readVirtualUint16(u.address));else if(4===d)f=BigInt(this.readVirtualUint32(u.address));else{if(8!==d)throw new Error("Unsupported memory read size for SUB.");f=this.readVirtualBigUint64(u.address)}p=this.readRegister(l,d),c={type:"reg",name:l}}const m=p-f;if(this.updateArithmeticFlags(m,p,f,d,"sub"),"reg"===c.type)this.writeRegister(c.name,m,d);else if(1===d)this.writeVirtualUint8(c.address,Number(m));else if(2===d)this.writeVirtualUint16(c.address,Number(m));else if(4===d)this.writeVirtualUint32(c.address,Number(m));else{if(8!==d)throw new Error("Unsupported memory write size for SUB.");this.writeVirtualBigUint64(c.address,m)}return i(`Decoded: SUB ${"reg"===c.type?c.name.toUpperCase():`[0x${c.address.toString(16)}]`}, ${f.toString(16)}${8===d?"n":""} -> Result: 0x${m.toString(16)}n`),!0}if(r>=56&&r<=59){const s=this.readModRMByte(),a=r>>>1&1;let d=0===(1&r)?1:t;const h=s.reg+(n<<3),l=this.getRegisterString(h,d,0!==e),u=this.resolveModRMOperand(s,d,o,g,0!==e);let f,p;if("reg"===u.type)0===a?(f=this.readRegister(l,d),p=this.readRegister(u.name,d)):(f=this.readRegister(u.name,d),p=this.readRegister(l,d));else if(0===a)if(f=this.readRegister(l,d),1===d)p=BigInt(this.readVirtualUint8(u.address));else if(2===d)p=BigInt(this.readVirtualUint16(u.address));else if(4===d)p=BigInt(this.readVirtualUint32(u.address));else{if(8!==d)throw new Error("Unsupported memory read size for CMP.");p=this.readVirtualBigUint64(u.address)}else{if(1===d)f=BigInt(this.readVirtualUint8(u.address));else if(2===d)f=BigInt(this.readVirtualUint16(u.address));else if(4===d)f=BigInt(this.readVirtualUint32(u.address));else{if(8!==d)throw new Error("Unsupported memory read size for CMP.");f=this.readVirtualBigUint64(u.address)}p=this.readRegister(l,d)}const c=p-f;this.updateArithmeticFlags(c,p,f,d,"sub");const m=0===a?"reg"===u.type?u.name.toUpperCase():`[0x${u.address.toString(16)}]`:l.toUpperCase();return i(`Decoded: CMP ${m}, ${0===a?l.toUpperCase():"reg"===u.type?u.name.toUpperCase():`[0x${u.address.toString(16)}]`} (0x${p.toString(16)}n - 0x${f.toString(16)}n)`),!0}if(129===r){const t=this.readModRMByte();if(7===t.reg){const r=this.readSignedImmediate(4);let s=4;const n=this.resolveModRMOperand(t,s,o,g,0!==e);let a;a="reg"===n.type?this.readRegister(n.name,s):BigInt(this.readVirtualUint32(n.address));const d=a-r;return this.updateArithmeticFlags(d,a,r,s,"sub"),i(`Decoded: CMP ${"reg"===n.type?n.name.toUpperCase():`[0x${n.address.toString(16)}]`}, 0x${r.toString(16)}`),!0}}if(129===r||131===r){const s=this.readModRMByte();let n=t;const a=this.resolveModRMOperand(s,n,o,g,0!==e),d=131===r?1:2===n?2:4,h=this.readSignedImmediate(d);let l,u;l="reg"===a.type?this.readRegister(a.name,n):1===n?BigInt(this.readVirtualUint8(a.address)):2===n?BigInt(this.readVirtualUint16(a.address)):4===n?BigInt(this.readVirtualUint32(a.address)):this.readVirtualBigUint64(a.address);let f="unknown";switch(s.reg){case 0:f="add",u=l+h;break;case 1:f="or",u=l|h;break;case 2:f="adc",u=l+h+this.flags.cf;break;case 3:f="sbb",u=l-h-this.flags.cf;break;case 4:f="and",u=l&h;break;case 5:case 7:f="sub",u=l-h;break;case 6:f="xor",u=l^h;break;default:throw new Error(`Unsupported Group 1 operation with /reg=${s.reg}`)}if("add"===f||"sub"===f||"adc"===f||"sbb"===f){const t="adc"===f||"sbb"===f?h+BigInt(this.flags.cf):h,e="add"===f||"adc"===f?"add":"sub";this.updateArithmeticFlags(u,l,t,n,e)}else{this.flags.cf=0,this.flags.of=0;const t=(1n<<BigInt(8*n))-1n;this.flags.zf=0n===(u&t)?1:0;const e=1n<<BigInt(8*n)-1n;this.flags.sf=0n!==(u&e)?1:0}7!==s.reg&&("reg"===a.type?this.writeRegister(a.name,u,n):1===n?this.writeVirtualUint8(a.address,Number(u)):2===n?this.writeVirtualUint16(a.address,Number(u)):4===n?this.writeVirtualUint32(a.address,Number(u)):this.writeVirtualBigUint64(a.address,u));const p=["ADD","OR","ADC","SBB","AND","SUB","XOR","CMP"][s.reg];return i(`Decoded: ${p} ${"reg"===a.type?a.name.toUpperCase():`[0x${a.address.toString(16)}]`}, 0x${h.toString(16)}`),!0}if(60===r||61===r){let s=0===(1&r)?1:t;const n=this.getRegisterString(0,s,0!==e),a=this.readRegister(n,s),d=1===s?1:4,o=this.readSignedImmediate(d),g=a-o;return this.updateArithmeticFlags(g,a,o,s,"sub"),i(`Decoded: CMP ${n.toUpperCase()}, 0x${o.toString(16)}`),!0}if(r>=136&&r<=139){const s=this.readModRMByte(),a=r>>>1&1;let d=0===(1&r)?1:t;const h=s.reg+(n<<3),l=this.getRegisterString(h,d,0!==e),u=this.resolveModRMOperand(s,d,n,g,o,0!==e),f=this.registers[l];if(i(`--- MOV [r/m],reg START (Opcode: 0x${r.toString(16)}) ---`),i(`  dBit=${a}, sizeBytes=${d}, regOp=${l}, rmOperand.addr=0x${u.address?.toString(16)}`),0===a){const t=this.readRegister(l,d);i(`  DIRECTION: r/m <- reg. Writing 0x${t.toString(16)} from ${l}...`),"reg"===u.type?this.writeRegister(u.name,t,d):(i(`  ...to MEMORY at 0x${u.address.toString(16)}`),1===d?this.writeVirtualUint8(u.address,t):2===d?this.writeVirtualUint16(u.address,t):4===d?this.writeVirtualUint32(u.address,t):this.writeVirtualBigUint64(u.address,t))}else{const t=l;let e;i("  DIRECTION: reg <- r/m. Reading from r/m operand..."),e="reg"===u.type?this.readRegister(u.name,d):1===d?BigInt(this.readVirtualUint8(u.address)):2===d?BigInt(this.readVirtualUint16(u.address)):4===d?BigInt(this.readVirtualUint32(u.address)):this.readVirtualBigUint64(u.address),i(`  Read value 0x${e.toString(16)} from r/m. Writing to ${t}.`),this.writeRegister(t,e,d),i(`  VERIFY: After writing to ${t}, the full register ${f} is now 0x${this[f].toString(16)}`)}return i("--- MOV [r/m],reg END ---"),!0}if(199===r){const t=this.readModRMByte();if(0!==t.reg)throw new Error(`Invalid ModR/M reg field for MOV r/m, imm: ${t.reg}`);let r,s;0!==e&&8&e?(r=4,s=8):this.operandSizeOverride?(r=2,s=2):(r=4,s=4);let a=this.readSignedImmediate(r);4===r&&8===s&&(a=BigInt.asIntN(32,a));const d=this.resolveModRMOperand(t,s,n,g,0!==e);if("reg"===d.type)this.writeRegister(d.name,a,s);else if(1===r)this.writeVirtualUint8(d.address,Number(a));else if(2===r)this.writeVirtualUint16(d.address,Number(a));else{if(4!==r)throw new Error(`Unsupported size for MOV r/m, imm: ${r} bytes`);this.writeVirtualUint32(d.address,Number(a))}return i(`Decoded: MOV ${"reg"===d.type?d.name.toUpperCase():`[0x${d.address.toString(16)}]`}, 0x${a.toString(16)}`),!0}if(198===r){const t=this.readModRMByte();if(0!==t.reg)throw new Error(`Invalid ModR/M reg field for MOV r/m8, imm8: ${t.reg}`);const r=this.resolveModRMOperand(t,1,n,g,0!==e),s=this.readSignedImmediate(1);return"reg"===r.type?this.writeRegister(r.name,s,1):this.writeVirtualUint8(r.address,Number(s)),i(`Decoded: MOV byte ${"reg"===r.type?r.name.toUpperCase():`[0x${r.address.toString(16)}]`}, 0x${s.toString(16)}`),!0}if(142===r){const t=this.readModRMByte(),r=["es","cs","ss","ds","fs","gs"][t.reg];if(!r)throw new Error(`Invalid segment register index: ${t.reg}`);const s=this.resolveModRMOperand(t,2,n,g,0!==e);let a;return a="reg"===s.type?Number(this.readRegister(s.name,2)):this.readVirtualUint16(s.address),this.writeRegister(r,BigInt(a),2),i(`Decoded: MOV ${r.toUpperCase()}, ${"reg"===s.type?s.name.toUpperCase():`[0x${s.address.toString(16)}]`} (0x${a.toString(16)})`),!0}if(r>=80&&r<=87){const t=r-80,s=8,n=this.getRegisterString(t,s,0!==e),a=this.readRegister(n,s);return i(`PUSH ${n.toUpperCase()} - RSP Before: 0x${this.rsp.toString(16)}`),this.rsp-=BigInt(s),this.writeVirtualBigUint64(this.rsp,a),i(`Decoded: PUSH ${n.toUpperCase()} (0x${a.toString(16)}n)`),i(`PUSH ${n.toUpperCase()} - RSP After: 0x${this.rsp.toString(16)}`),!0}if(255===r){const r=this.readModRMByte();if(6===r.reg){let s=t;const n=this.resolveModRMOperand(r,s,o,g,0!==e);let a;if("reg"===n.type)a=this.readRegister(n.name,s);else if(1===s)a=BigInt(this.readVirtualUint8(n.address));else if(2===s)a=BigInt(this.readVirtualUint16(n.address));else if(4===s)a=BigInt(this.readVirtualUint32(n.address));else{if(8!==s)throw new Error("Unsupported memory read size for PUSH r/m.");a=this.readVirtualBigUint64(n.address)}return i(`PUSH ${"reg"===n.type?n.name.toUpperCase():`[0x${n.address.toString(16)}]`} - RSP Before: 0x${this.rsp.toString(16)}`),this.rsp-=BigInt(s),this.writeVirtualBigUint64(this.rsp,a),i(`Decoded: PUSH ${"reg"===n.type?n.name.toUpperCase():`[0x${n.address.toString(16)}]`} (0x${a.toString(16)}n)`),i(`PUSH ${"reg"===n.type?n.name.toUpperCase():`[0x${n.address.toString(16)}]`} - RSP After: 0x${this.rsp.toString(16)}`),!0}}if(r>=88&&r<=95){const t=r-88,s=8,n=this.getRegisterString(t,s,0!==e);i(`POP ${n.toUpperCase()} - RSP Before: 0x${this.rsp.toString(16)}`);const a=this.readVirtualBigUint64(this.rsp);return this.writeRegister(n,a,s),this.rsp+=BigInt(s),i(`Decoded: POP ${n.toUpperCase()} (0x${a.toString(16)}n)`),i(`POP ${n.toUpperCase()} - RSP After: 0x${this.rsp.toString(16)}`),!0}if(143===r){const r=this.readModRMByte();if(0===r.reg){let s=t;const n=this.resolveModRMOperand(r,s,o,g,0!==e);let a;if(i(`POP ${"reg"===n.type?n.name.toUpperCase():`[0x${n.address.toString(16)}]`} - RSP Before: 0x${this.rsp.toString(16)}`),this.rsp+=BigInt(s),this.writeRegister(n.name,a,s),"reg"===n.type)a=this.readRegister(n.name,s);else if(1===s)a=BigInt(this.readVirtualUint8(n.address));else if(2===s)a=BigInt(this.readVirtualUint16(n.address));else if(4===s)a=BigInt(this.readVirtualUint32(n.address));else{if(8!==s)throw new Error("Unsupported memory read size for POP r/m.");a=this.readVirtualBigUint64(n.address)}return i(`Decoded: POP ${"reg"===n.type?n.name.toUpperCase():`[0x${n.address.toString(16)}]`} (0x${a.toString(16)}n)`),i(`POP ${"reg"===n.type?n.name.toUpperCase():`[0x${n.address.toString(16)}]`} - RSP After: 0x${this.rsp.toString(16)}`),!0}}if(232===r){const t=this.readSignedImmediate(4),e=this.rip;return i(`CALL rel32 - RSP Before: 0x${this.rsp.toString(16)}`),this.rsp-=8n,this.writeVirtualBigUint64(this.rsp,e),this.rip+=BigInt(t),i(`Decoded: CALL rel32 0x${t.toString(16)} (RIP adjusted to 0x${this.rip.toString(16)})`),i(`CALL rel32 - RSP After: 0x${this.rsp.toString(16)}`),!0}if(255===r){const r=this.readModRMByte();if(2===r.reg){let s=t;const n=this.resolveModRMOperand(r,s,o,g,0!==e);let a;if("reg"===n.type)a=this.readRegister(n.name,s);else if(1===s)a=BigInt(this.readVirtualUint8(n.address));else if(2===s)a=BigInt(this.readVirtualUint16(n.address));else if(4===s)a=BigInt(this.readVirtualUint32(n.address));else{if(8!==s)throw new Error("Unsupported memory read size for CALL r/m.");a=this.readVirtualBigUint64(n.address)}const d=this.rip;return i(`CALL r/m - RSP Before: 0x${this.rsp.toString(16)}`),this.rsp-=8n,this.writeVirtualBigUint64(this.rsp,d),this.rip=a,i(`Decoded: CALL ${"reg"===n.type?n.name.toUpperCase():`[0x${n.address.toString(16)}]`} (Indirect, jumping to 0x${this.rip.toString(16)})`),i(`CALL r/m - RSP After: 0x${this.rsp.toString(16)}`),!0}}if(195===r){i(`RET - RSP Before: 0x${this.rsp.toString(16)}`);const t=this.readVirtualBigUint64(this.rsp);return this.rsp+=8n,this.rip=t,i(`Decoded: RET (Near, jumping to 0x${this.rip.toString(16)})`),i(`RET - RSP After: 0x${this.rsp.toString(16)}`),!0}if(194===r){const t=this.readSignedImmediate(2);i(`RET imm16 - RSP Before: 0x${this.rsp.toString(16)}`);const e=this.readVirtualBigUint64(this.rsp);return this.rsp+=8n,this.rip=e,this.rsp+=BigInt(t),i(`Decoded: RET imm16 (jumping to 0x${this.rip.toString(16)}, stack adjust by 0x${t.toString(16)})`),i(`RET imm16 - RSP After: 0x${this.rsp.toString(16)}`),!0}if(141===r){const r=this.readModRMByte();if(3===r.mod)throw new Error("Invalid use of LEA with register source.");let s=t;const a=r.reg+(n<<3),d=this.getRegisterString(a,s,0!==e),h=this.resolveModRMOperand(r,s,o,g,0!==e).address;return this.writeRegister(d,h,s),i(`Decoded: LEA ${d.toUpperCase()}, [address] (Calculated address: 0x${h.toString(16)})`),!0}if(132===r||133===r){const s=this.readModRMByte();let a=0===(1&r)?1:t;const d=s.reg+(n<<3),h=this.getRegisterString(d,a,0!==e),l=this.resolveModRMOperand(s,a,o,g,0!==e);let u,f;u=this.readRegister(h,a),f="reg"===l.type?this.readRegister(l.name,a):1===a?BigInt(this.readVirtualUint8(l.address)):2===a?BigInt(this.readVirtualUint16(l.address)):4===a?BigInt(this.readVirtualUint32(l.address)):this.readVirtualBigUint64(l.address);const p=u&f;this.flags.cf=0,this.flags.of=0,this.flags.zf=0n===p?1:0;const c=1n<<BigInt(8*a)-1n;this.flags.sf=0n!==(p&c)?1:0;return i(`Decoded: TEST ${"reg"===l.type?l.name.toUpperCase():`[0x${l.address.toString(16)}]`}, ${h.toUpperCase()}`),!0}if(168===r){const t=this.readSignedImmediate(1),e=this.readRegister("al",1)&t;return this.flags.cf=0,this.flags.of=0,this.flags.zf=0n===e?1:0,this.flags.sf=0n!=(0x80n&e)?1:0,i(`Decoded: TEST AL, 0x${t.toString(16)} (Result for flags: 0x${e.toString(16)})`),!0}if(169===r){let r=t;const s=8===r?4:r,n=this.readSignedImmediate(s),a=this.getRegisterString(0,r,0!==e),d=this.readRegister(a,r)&n;this.flags.cf=0,this.flags.of=0,this.flags.zf=0n===d?1:0;const o=1n<<BigInt(8*r)-1n;return this.flags.sf=0n!==(d&o)?1:0,i(`Decoded: TEST ${a.toUpperCase()}, 0x${n.toString(16)} (Result for flags: 0x${d.toString(16)})`),!0}if(192===r||193===r){const s=this.readModRMByte();let n=0===(1&r)?1:t;const a=this.resolveModRMOperand(s,n,o,g,0!==e),d=this.readSignedImmediate(1);let h,l;h="reg"===a.type?this.readRegister(a.name,n):1===n?BigInt(this.readVirtualUint8(a.address)):2===n?BigInt(this.readVirtualUint16(a.address)):4===n?BigInt(this.readVirtualUint32(a.address)):this.readVirtualBigUint64(a.address);let u="UNKNOWN_SHIFT";switch(s.reg){case 4:u="SHL",l=h<<d;break;case 5:u="SHR",l=h>>d;break;default:throw new Error(`Unhandled Group 2 instruction with /reg=${s.reg}`)}this.flags.zf=0n===l?1:0;const f=1n<<BigInt(8*n)-1n;this.flags.sf=0n!==(l&f)?1:0,"reg"===a.type?this.writeRegister(a.name,l,n):1===n?this.writeVirtualUint8(a.address,Number(l)):2===n?this.writeVirtualUint16(a.address,Number(l)):4===n?this.writeVirtualUint32(a.address,Number(l)):this.writeVirtualBigUint64(a.address,l);return i(`Decoded: ${u} ${"reg"===a.type?a.name.toUpperCase():`[0x${a.address.toString(16)}]`}, ${d}`),!0}if(124===r){const t=this.readSignedImmediate(1);return i(`Decoded: JL rel8 0x${t.toString(16)}`),this.flags.sf!==this.flags.of?(this.rip+=t,i(`  Condition Met (SF!=OF). Jumping to 0x${this.rip.toString(16)}`)):i("  Condition Not Met. Not jumping."),!0}if(114===r){const t=this.readSignedImmediate(1);return i(`Decoded: JB rel8 0x${t.toString(16)}`),0!==this.flags.cf?(this.rip+=t,i(`  Condition Met (CF!=0). Jumping to 0x${this.rip.toString(16)}`)):i("  Condition Not Met. Not jumping."),!0}if(235===r){const t=this.readSignedImmediate(1);return this.rip+=t,i(`Decoded: JMP rel8 0x${t.toString(16)} (Jumping to 0x${this.rip.toString(16)})`),!0}if(207===r){const t=Number(this.readVirtualBigUint64(this.rsp));this.rsp+=8n;[8,10,11,12,13,14,17].includes(t)&&(this.rsp+=8n),this.rip=this.readVirtualBigUint64(this.rsp),this.rsp+=8n;this.readVirtualBigUint64(this.rsp);this.rsp+=8n;const e=this.readVirtualBigUint64(this.rsp);return this.disassembleRFlags(e),this.rsp+=8n,i(`Decoded: IRETQ from INT #${t} (Returning to 0x${this.rip.toString(16)})`),!0}if(238===r){const t=this.readRegister("dx",2),e=this.readRegister("al",1);return this.io.portOut(Number(t),Number(e),1),i(`Decoded: OUT DX, AL (Wrote 0x${e.toString(16)} to port 0x${t.toString(16)})`),!0}if(230===r){const t=this.readInstructionByte(),e=this.readRegister("al",1);return this.io.portOut(t,Number(e),1),i(`Decoded: OUT imm8, AL (Wrote 0x${e.toString(16)} to port 0x${t.toString(16)})`),!0}if(172===r){const t=this.readVirtualUint8(this.rsi);return this.writeRegister("al",t,1),this.rsi+=1n,i(`Decoded: LODSB (Loaded 0x${t.toString(16)} into AL, RSI is now 0x${this.rsi.toString(16)})`),!0}if(228===r){const t=this.readInstructionByte(),e=this.io.portIn(t,1);return this.writeRegister("al",e,1),i(`Decoded: IN AL, imm8 (Read 0x${e.toString(16)} from port 0x${t.toString(16)} into AL)`),!0}if(236===r){const t=this.readRegister("dx",2),e=this.io.portIn(Number(t),1);return this.writeRegister("al",e,1),i(`Decoded: IN AL, DX (Read 0x${e.toString(16)} from port 0x${t.toString(16)} into AL)`),!0}if(254===r||255===r){const s=this.readModRMByte();if(0===s.reg){let a=0===(1&r)?1:t;const d=this.resolveModRMOperand(s,a,n,g,o,0!==e);let h;h="reg"===d.type?this.readRegister(d.name,a):1===a?BigInt(this.readVirtualUint8(d.address)):2===a?BigInt(this.readVirtualUint16(d.address)):4===a?BigInt(this.readVirtualUint32(d.address)):this.readVirtualBigUint64(d.address);const l=h+1n,u=this.flags.cf;this.updateArithmeticFlags(l,h,1n,a,"add"),this.flags.cf=u,"reg"===d.type?this.writeRegister(d.name,l,a):1===a?this.writeVirtualUint8(d.address,Number(l)):2===a?this.writeVirtualUint16(d.address,Number(l)):4===a?this.writeVirtualUint32(d.address,Number(l)):this.writeVirtualBigUint64(d.address,l);return i(`Decoded: INC ${"reg"===d.type?d.name.toUpperCase():`[0x${d.address.toString(16)}]`}`),!0}}if(251===r)return this.flags.if=1,i("Decoded: STI"),!0;if(250===r)return this.flags.if=0,i("Decoded: CLI"),!0;if(234===r){const t=this.memory.readUint16(Number(this.rip));this.rip+=2n;const e=this.memory.readUint16(Number(this.rip));return this.rip+=2n,this.cs=BigInt(e),this.rip=BigInt(t),this.updateCPUMode(),i(`Decoded: JMP far 0x${e.toString(16)}:0x${t.toString(16)}`),!0}return i(`Unknown opcode: 0x${l?"0F ":""}${r.toString(16)} at 0x${h.toString(16)}`),!1}catch(t){if(!(t instanceof a))throw console.error(`Fatal error during execution at RIP 0x${h.toString(16)}:`,t),t;console.warn(`--- Caught Page Fault at RIP 0x${h.toString(16)}. Invoking handler. ---`),this.rip=h,this.triggerInterrupt(14,t.errorCode)}return!0}readInstructionByte(){let t;return t=0n!==(this.cr0&d.CR0_PE)?this.readVirtualUint8(this.rip):this.memory.readUint8(Number(this.rip)),this.rip++,t}readInstructionUint16(){const t=this.readInstructionByte();return this.readInstructionByte()<<8|t}readInstructionUint32(){const t=this.readInstructionByte(),e=this.readInstructionByte(),r=this.readInstructionByte();return this.readInstructionByte()<<24|r<<16|e<<8|t}readModRMByte(){const t=this.readInstructionByte();return{mod:t>>>6&3,reg:t>>>3&7,rm:7&t,raw:t}}getRegisterString(t,e,r=!1){const i=["rax","rcx","rdx","rbx","rsp","rbp","rsi","rdi","r8","r9","r10","r11","r12","r13","r14","r15"],s=["eax","ecx","edx","ebx","esp","ebp","esi","edi","r8d","r9d","r10d","r11d","r12d","r13d","r14d","r15d"],n=["ax","cx","dx","bx","sp","bp","si","di","r8w","r9w","r10w","r11w","r12w","r13w","r14w","r15w"],a=["al","cl","dl","bl"],d=["ah","ch","dh","bh"],o=["spl","bpl","sil","dil"],g=["r8b","r9b","r10b","r11b","r12b","r13b","r14b","r15b"];if(t<0||t>15)throw new Error(`Invalid register index: ${t}`);switch(e){case 1:return t>=8?g[t-8]:t>=4?r?o[t-4]:d[t-4]:a[t];case 2:return n[t];case 4:return s[t];case 8:return i[t];default:throw new Error(`Invalid register size for naming: ${e}`)}}readSignedImmediate(t){let e;if(1===t)return e=this.readInstructionByte(),128&e?BigInt(e-256):BigInt(e);if(2===t)return e=this.readInstructionUint16(),32768&e?BigInt(e-65536):BigInt(e);if(4===t)return e=this.readInstructionUint32(),2147483648&e?BigInt(e-4294967296):BigInt(e);const r=this.readInstructionUint32(),i=this.readInstructionUint32();return BigInt(i)<<32n|BigInt(r)}readSIBByte(t){const e=this.readInstructionByte(),r=e>>>3&7,s=7&e,n=1<<(e>>>6&3),a=this.getRegisterString(r,8,!1),d=this.getRegisterString(s,8,!1);let o=0n;5===s&&0===t||(o=this.readRegister(d,8));let g=0n;4!==r&&(g=this.readRegister(a,8));const h=o+g*BigInt(n);return i(`  SIB Decoded: Base=${d}, Index=${a}, Scale=${n} => Address component = 0x${h.toString(16)}`),h}resolveModRMOperand(t,e,r,i,s){if(3===t.mod){const r=t.rm+(i<<3);return{type:"reg",name:this.getRegisterString(r,e,s)}}let n=0n,a=0n;const d=4===t.rm;if(d){const e=this.readInstructionByte(),s=1<<(e>>>6&3),a=(e>>>3&7)+(r<<3),d=(7&e)+(i<<3);if(4!==a){const t=this.getRegisterString(a,8,!0);n+=this.readRegister(t,8)*BigInt(s)}if(0!==t.mod||5!==d){const t=this.getRegisterString(d,8,!0);n+=this.readRegister(t,8)}}else if(5===t.rm)n=this.rip;else{const e=t.rm+(i<<3),r=this.getRegisterString(e,8,!0);n=this.readRegister(r,8)}if(1===t.mod)a=this.readSignedImmediate(1),n+=a;else if(2===t.mod)a=this.readSignedImmediate(4),n+=a;else if(0===t.mod){const e=d&&5==(7&this.memory.readUint8(Number(this.rip-1n)));(!d&&5===t.rm||e)&&(a=this.readSignedImmediate(4),n+=a)}return{type:"mem",address:n,sizeBytes:e}}updateCPUMode(){const t=0n!==(this.cr0&d.CR0_PE),e=0n!==(this.cr0&d.CR0_PG),r=0n!==(this.cr4&d.CR4_PAE),s=0n!==(this.efer&d.EFER_LME);i("\n--- DEBUG: updateCPUMode called ---"),i(`  Current CR0:  0x${this.cr0.toString(16).padStart(16,"0")} (PE: ${t}, PG: ${e})`),i(`  Current CR4:  0x${this.cr4.toString(16).padStart(16,"0")} (PAE: ${r})`),i(`  Current EFER: 0x${this.efer.toString(16).padStart(16,"0")} (LME: ${s})`),i(`  Combined Condition (LME && PAE && PG): ${s&&r&&e}`),t?s&&r&&e?(this.mode="long",i("CPU Mode: Long Mode (64-bit) enabled.")):e&&r?(this.mode="protected_pae",i("CPU Mode: Protected Mode (32-bit) with PAE enabled.")):e?(this.mode="protected_32bit_paging",i("CPU Mode: Protected Mode (32-bit) with Paging enabled.")):(this.mode="protected",i("CPU Mode: Protected Mode (32-bit) enabled (no paging).")):this.mode="real",i(`DEBUG: updateCPUMode - Mode finalized as: ${this.mode}\n`)}readVirtualUint8(t){const e=this.translateVirtualToPhysical(t,1,"read");if(e<0n||e>=BigInt(this.memory.buffer.byteLength))throw console.error(`Attempt to read physical address 0x${e.toString(16)} outside memory bounds (0x0 to 0x${BigInt(this.memory.buffer.byteLength).toString(16)}).`),new Error(`MEMORY_ACCESS_VIOLATION: Read from physical address 0x${e.toString(16)}`);return this.memory.readUint8(Number(e))}writeVirtualUint8(t,e){const r=this.translateVirtualToPhysical(t,1,"write");if(r<0n||r>=BigInt(this.memory.buffer.byteLength))throw console.error(`Attempt to write physical address 0x${r.toString(16)} outside memory bounds (0x0 to 0x${BigInt(this.memory.buffer.byteLength).toString(16)}).`),new Error(`MEMORY_ACCESS_VIOLATION: Write to physical address 0x${r.toString(16)}`);this.memory.writeUint8(Number(r),e)}readVirtualUint16(t){const e=this.translateVirtualToPhysical(t,2,"read");if(e<0n||e+1n>=BigInt(this.memory.buffer.byteLength))throw console.error(`Attempt to read physical address 0x${e.toString(16)} outside memory bounds.`),new Error(`MEMORY_ACCESS_VIOLATION: Read from physical address 0x${e.toString(16)}`);return this.memory.readUint16(Number(e))}writeVirtualUint16(t,e){const r=this.translateVirtualToPhysical(t,2,"write");if(r<0n||r+1n>=BigInt(this.memory.buffer.byteLength))throw console.error(`Attempt to write physical address 0x${r.toString(16)} outside memory bounds.`),new Error(`MEMORY_ACCESS_VIOLATION: Write to physical address 0x${r.toString(16)}`);this.memory.writeUint16(Number(r),e)}readVirtualUint32(t){const e=this.translateVirtualToPhysical(t,4,"read");if(e<0n||e+3n>=BigInt(this.memory.buffer.byteLength))throw console.error(`Attempt to read physical address 0x${e.toString(16)} outside memory bounds.`),new Error(`MEMORY_ACCESS_VIOLATION: Read from physical address 0x${e.toString(16)}`);return this.memory.readUint32(Number(e))}writeVirtualUint32(t,e){const r=this.translateVirtualToPhysical(t,4,"write");if(r<0n||r+3n>=BigInt(this.memory.buffer.byteLength))throw console.error(`Attempt to write physical address 0x${r.toString(16)} outside memory bounds.`),new Error(`MEMORY_ACCESS_VIOLATION: Write to physical address 0x${r.toString(16)}`);this.memory.writeUint32(Number(r),e)}readVirtualBigUint64(t){const e=this.translateVirtualToPhysical(t,8,"read");if(e<0n||e+7n>=BigInt(this.memory.buffer.byteLength))throw console.error(`Attempt to read physical address 0x${e.toString(16)} outside memory bounds.`),new Error(`MEMORY_ACCESS_VIOLATION: Read from physical address 0x${e.toString(16)}`);return this.memory.readBigUint64(Number(e))}writeVirtualBigUint64(t,e){const r=this.translateVirtualToPhysical(t,8,"write");if(r<0n||r+7n>=BigInt(this.memory.buffer.byteLength))throw console.error(`Attempt to write physical address 0x${r.toString(16)} outside memory bounds.`),new Error(`MEMORY_ACCESS_VIOLATION: Write to physical address 0x${r.toString(16)}`);this.memory.writeBigUint64(Number(r),e)}translateVirtualToPhysical(t,e,r){if("real"===this.mode)return t;const s=0n!==(this.cr0&d.CR0_PG),n=0n!==(this.cr4&d.CR4_PAE),o=0n!==(this.efer&d.EFER_LME);if("long"!==this.mode||!s||!n||!o)return console.warn(`Paging not fully enabled for Long Mode. Current mode: ${this.mode}. CR0.PG=${s}, CR4.PAE=${n}, EFER.LME=${o}. Returning virtual as physical.`),t;i(`Paging: Translating virtual address 0x${t.toString(16)} in ${this.mode} mode.`);const g=-4096n&this.cr3;i(`  PML4 Base Phys: 0x${g.toString(16).padStart(16,"0")}`);const h=t>>39n&0x1FFn;let l=g+8n*h;i(`  PML4E Addr: 0x${l.toString(16).padStart(16,"0")} (Index: ${h})`);let u=this.memory.readBigUint64(Number(l));if(i(`  PML4E Value: 0x${u.toString(16).padStart(16,"0")}`),0n===(u&d.PTE_PRESENT))throw console.error(`Page Fault (#PF): PML4E not present for VA 0x${t.toString(16)}`),new a("PML4E not present",0n);let f=-4096n&u;i(`  PDPT Base Phys: 0x${f.toString(16).padStart(16,"0")}`);const p=t>>30n&0x1FFn;let c=f+8n*p;i(`  PDPTE Addr: 0x${c.toString(16).padStart(16,"0")} (Index: ${p})`);let m=this.memory.readBigUint64(Number(c));if(i(`  PDPTE Value: 0x${m.toString(16).padStart(16,"0")}`),0n===(m&d.PTE_PRESENT))throw console.error(`Page Fault (#PF): PDPTE not present for VA 0x${t.toString(16)}`),new a("PDPTE not present",0n);if(0n!==(m&d.PTE_PAGE_SIZE)){const e=0xFFFFFFFC0000000n&m|0x3FFFFFFFfn&t;return i(`  Translated 1GB page: VA 0x${t.toString(16)} -> PA 0x${e.toString(16)}`),e}let S=-4096n&m;i(`  PD Base Phys: 0x${S.toString(16).padStart(16,"0")}`);const R=t>>21n&0x1FFn;let U=S+8n*R;i(`  PDE Addr: 0x${U.toString(16).padStart(16,"0")} (Index: ${R})`);let $=this.memory.readBigUint64(Number(U));if(i(`  PDE Value: 0x${$.toString(16).padStart(16,"0")}`),0n===($&d.PTE_PRESENT))throw console.error(`Page Fault (#PF): PDE not present for VA 0x${t.toString(16)}`),new a("PDE not present",0n);if(0n!==($&d.PTE_PAGE_SIZE)){const e=0xFFFFFFFE00000n&$|0x1FFFFFn&t;return i(`  Translated 2MB page: VA 0x${t.toString(16)} -> PA 0x${e.toString(16)}`),e}let x=-4096n&$;i(`  PT Base Phys: 0x${x.toString(16).padStart(16,"0")}`);const w=t>>12n&0x1FFn;let B=x+8n*w;i(`  PTE Addr: 0x${B.toString(16).padStart(16,"0")} (Index: ${w})`);let I=this.memory.readBigUint64(Number(B));if(i(`  PTE Value: 0x${I.toString(16).padStart(16,"0")}`),0n===(I&d.PTE_PRESENT))throw console.error(`Page Fault (#PF): PTE not present for VA 0x${t.toString(16)}`),new a("PTE not present",0n);if("write"===r&&0n===(I&d.PTE_READ_WRITE))throw new a(`Protection Violation on write to VA 0x${t.toString(16)}`,1n);const E=-4096n&I,y=0xFFFn&t,b=E|y;return i(`  Final Page Base Addr: 0x${E.toString(16).padStart(16,"0")}`),i(`  Page Offset: 0x${y.toString(16).padStart(3,"0")}`),i(`  Calculated Physical: 0x${b.toString(16).padStart(16,"0")}`),b}triggerInterrupt(t,e=null){i(`--- INTERRUPT TRIGGERED: #${t} ---`);const r=this.idtr.base+BigInt(16*t);i(`  IDTR.base = 0x${this.idtr.base.toString(16)}`),i(`  Interrupt #${t} @ 0x${r.toString(16)}`),i(`  Raw bytes: ${[...new Uint8Array(this.memory.buffer.slice(Number(r),Number(r+16n)))].map(t=>t.toString(16).padStart(2,"0")).join(" ")}`);const s=this.readVirtualBigUint64(r),n=this.readVirtualBigUint64(r+8n);i(`DEBUG: Descriptor at 0x${r.toString(16)} is: LOW=0x${s.toString(16)} HIGH=0x${n.toString(16)}`);const a=0xFFFFn&s,d=s>>48n&0xFFFFn,o=0xFFFFFFFFn&n,g=o<<32n|d<<16n|a,h=s>>16n&0xFFFFn;if(!(0n!=(0x80n&(s>>40n&0xFFn))))throw new Error(`Interrupt Handler #${t} not present! Double Fault.`);this.rsp-=8n,this.writeVirtualBigUint64(this.rsp,this.assembleRFlags()),this.rsp-=8n,this.writeVirtualBigUint64(this.rsp,h),this.rsp-=8n,this.writeVirtualBigUint64(this.rsp,this.rip),null!==e&&(this.rsp-=8n,this.writeVirtualBigUint64(this.rsp,e)),this.rsp-=8n,this.writeVirtualBigUint64(this.rsp,BigInt(t)),i(`DEBUG: Parsed handlerAddr = 0x${g.toString(16)}`),i(`  offset_15_0  = 0x${a.toString(16)}`),i(`  offset_31_16 = 0x${d.toString(16)}`),i(`  offset_63_32 = 0x${o.toString(16)}`),this.rip=g,i(`  Jumping to handler at 0x${g.toString(16)}`)}assembleRFlags(){let t=0n;return this.flags.cf&&(t|=1n<<d.FLAG_CF_BIT),this.flags.zf&&(t|=1n<<d.FLAG_ZF_BIT),this.flags.sf&&(t|=1n<<d.FLAG_SF_BIT),this.flags.of&&(t|=1n<<d.FLAG_OF_BIT),this.flags.if&&(t|=1n<<d.FLAG_IF_BIT),t|=2n,t}disassembleRFlags(t){this.flags.cf=1n==(t>>d.FLAG_CF_BIT&1n)?1:0,this.flags.zf=1n==(t>>d.FLAG_ZF_BIT&1n)?1:0,this.flags.sf=1n==(t>>d.FLAG_SF_BIT&1n)?1:0,this.flags.of=1n==(t>>d.FLAG_OF_BIT&1n)?1:0,this.flags.if=1n==(t>>d.FLAG_IF_BIT&1n)?1:0}raiseInterrupt(t){this.interruptQueue.push(t)}}t.CPU=d,t.Device=class{constructor(t="Unnamed Device"){this.name=t}portIn(t,e){return 0}portOut(t,e,r){}},t.IOManager=n,t.Memory=s,t.PageFaultException=a,t.getMode=function(){return r},t.log=i,t.setMode=function(t){if("dev"!==t&&"prod"!==t)throw new Error("Invalid mode");r=t}});
//# sourceMappingURL=emcpu.umd.js.map
